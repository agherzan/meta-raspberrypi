From e2f1ea3c9ee450c9c6c6af0ac6ca505cbbe10968 Mon Sep 17 00:00:00 2001
From: John Cox <jc@kynesim.co.uk>
Date: Tue, 11 Jun 2024 17:05:36 +0100
Subject: [PATCH 18/41] qt/interface_widgets: Use window locks when handle
 might change

Qt/Wayland changes its surface when the window is hidden and then shown.
Hidden includes being resized to a zero dimension which seems to happen
shortly after window creation when playing video.

Use the new window handle locks to signal this to the player to avoid it
trying to use stale handles which will crash VLC.


Upstream-Status: Inappropriate

RPI-Distro repo forks original vlc and applies patches

to enable raspiberry pi support.
---

 .../gui/qt/components/interface_widgets.cpp   | 79 ++++++++++++++++++-
 .../gui/qt/components/interface_widgets.hpp   |  4 +
 2 files changed, 82 insertions(+), 1 deletion(-)

--- a/modules/gui/qt/components/interface_widgets.cpp
+++ b/modules/gui/qt/components/interface_widgets.cpp
@@ -81,7 +81,8 @@ static inline int qrand() {
  **********************************************************************/
 
 VideoWidget::VideoWidget( intf_thread_t *_p_i, QWidget* p_parent )
-            : QFrame( p_parent ) , p_intf( _p_i )
+            : QFrame( p_parent ) , p_intf( _p_i ),
+              p_last_window(NULL)
 {
     /* Set the policy to expand in both directions */
     // setSizePolicy( QSizePolicy::Expanding, QSizePolicy::Expanding );
@@ -112,6 +113,44 @@ void VideoWidget::sync( void )
 #endif
 }
 
+static inline void incnz(unsigned int * px)
+{
+    if ( ++*px == 0 )
+        *px = 1;
+}
+
+/**
+ * The wayland surface may change if the window is hidden which
+ * seems to happen sometimes on resize
+ * In Qt it looks like this happens if the window is hidden
+ **/
+void VideoWidget::refreshHandle()
+{
+#ifdef QT5_HAS_WAYLAND
+    if (!p_window || p_window->type != VOUT_WINDOW_TYPE_WAYLAND)
+        return;
+
+    QWindow *window = stable->windowHandle();
+    assert(window != NULL);
+    window->create();
+
+    QPlatformNativeInterface *qni = qApp->platformNativeInterface();
+    assert(qni != NULL);
+
+    struct wl_surface * const new_surface = static_cast<wl_surface*>(
+        qni->nativeResourceForWindow(QByteArrayLiteral("surface"),
+                                     window));
+
+    if ( p_window->handle.wl != new_surface )
+    {
+        vlc_mutex_lock(&p_window->handle_lock);
+        p_window->handle.wl = new_surface;
+        incnz(&p_window->handle_seq);
+        vlc_mutex_unlock(&p_window->handle_lock);
+    }
+#endif
+}
+
 /**
  * Request the video to avoid the conflicts
  **/
@@ -182,6 +221,7 @@ bool VideoWidget::request( struct vout_w
                                              window));
             p_wnd->display.wl = static_cast<wl_display*>(
                 qni->nativeResourceForIntegration(QByteArrayLiteral("wl_display")));
+            p_wnd->handle_seq = 1;
             break;
         }
 #endif
@@ -240,6 +280,8 @@ void VideoWidget::reportSize()
     if( !p_window )
         return;
 
+    refreshHandle();
+
     QSize size = physicalSize();
     WindowResized(p_window, size);
 }
@@ -299,6 +341,32 @@ bool VideoWidget::nativeEventFilter(cons
     return false;
 }
 
+void VideoWidget::showEvent(QShowEvent *event)
+{
+    if (p_last_window && p_last_window->type == VOUT_WINDOW_TYPE_WAYLAND && p_last_window->handle.wl == NULL)
+        request(p_last_window);
+    else
+        QFrame::showEvent(event);
+}
+
+void VideoWidget::hideEvent(QHideEvent *event)
+{
+    if (p_window && p_window->type == VOUT_WINDOW_TYPE_WAYLAND && p_window->handle.wl != NULL)
+    {
+        vlc_mutex_lock(&p_window->handle_lock);
+        p_window->handle.wl = NULL;
+        incnz(&p_window->handle_seq);
+        vlc_mutex_unlock(&p_window->handle_lock);
+
+        p_last_window = p_window;
+        release(false);
+    }
+    else
+    {
+        QFrame::hideEvent(event);
+    }
+}
+
 void VideoWidget::resizeEvent( QResizeEvent *event )
 {
     QWidget::resizeEvent( event );
@@ -419,6 +487,15 @@ void VideoWidget::release( bool forced )
         layout->removeWidget( stable );
         stable->deleteLater();
         stable = NULL;
+
+#ifdef QT5_HAS_WAYLAND
+        vlc_mutex_lock(&p_window->handle_lock);
+        msg_Dbg( p_intf, "video widget handle zap" );
+        p_window->handle.wl = NULL;
+        incnz(&p_window->handle_seq);
+        vlc_mutex_unlock(&p_window->handle_lock);
+#endif
+
         p_window = NULL;
     }
 
--- a/modules/gui/qt/components/interface_widgets.hpp
+++ b/modules/gui/qt/components/interface_widgets.hpp
@@ -69,6 +69,8 @@ protected:
         return NULL;
     }
 
+    void hideEvent(QHideEvent *event) Q_DECL_OVERRIDE;
+    void showEvent(QShowEvent *event) Q_DECL_OVERRIDE;
 #if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     bool nativeEventFilter(const QByteArray &eventType, void *message, qintptr *result) override;
 #else
@@ -85,6 +87,7 @@ private:
     int qtMouseButton2VLC( Qt::MouseButton );
     intf_thread_t *p_intf;
     vout_window_t *p_window;
+    vout_window_t *p_last_window;
 
     QWidget *stable;
     QLayout *layout;
@@ -92,6 +95,7 @@ private:
     bool enable_mouse_events;
 
     void reportSize();
+    void refreshHandle();
 
 signals:
     void sizeChanged( int, int );
