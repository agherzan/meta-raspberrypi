From 7dc565ecb6e84c5ba03e6eeec88b0cdc50e28aa5 Mon Sep 17 00:00:00 2001
From: John Cox <jc@kynesim.co.uk>
Date: Wed, 12 Jun 2024 10:54:53 +0100
Subject: [PATCH 34/41] video_output/drmu: Add DRM video output

Heavily based on my somewhat independent drmu project
Can do HDR setup and mode matching


Upstream-Status: Inappropriate

RPI-Distro repo forks original vlc and applies patches

to enable raspiberry pi support.
---

 modules/video_output/Makefile.am           |   29 +
 modules/video_output/drmu/drm_vout.c       | 1503 ++++++++
 modules/video_output/drmu/drmu.c           | 3922 ++++++++++++++++++++
 modules/video_output/drmu/drmu.h           |  703 ++++
 modules/video_output/drmu/drmu_atomic.c    |  992 +++++
 modules/video_output/drmu/drmu_chroma.h    |   47 +
 modules/video_output/drmu/drmu_dmabuf.c    |  206 +
 modules/video_output/drmu/drmu_dmabuf.h    |   47 +
 modules/video_output/drmu/drmu_fmts.c      |  253 ++
 modules/video_output/drmu/drmu_fmts.h      |   31 +
 modules/video_output/drmu/drmu_log.h       |   81 +
 modules/video_output/drmu/drmu_math.c      |   43 +
 modules/video_output/drmu/drmu_math.h      |  149 +
 modules/video_output/drmu/drmu_output.c    |  589 +++
 modules/video_output/drmu/drmu_output.h    |  114 +
 modules/video_output/drmu/drmu_poll.c      |  549 +++
 modules/video_output/drmu/drmu_poll.h      |   80 +
 modules/video_output/drmu/drmu_pool.c      |  307 ++
 modules/video_output/drmu/drmu_pool.h      |   60 +
 modules/video_output/drmu/drmu_scan.c      |   60 +
 modules/video_output/drmu/drmu_scan.h      |   20 +
 modules/video_output/drmu/drmu_util.c      |  199 +
 modules/video_output/drmu/drmu_util.h      |   64 +
 modules/video_output/drmu/drmu_vlc.c       |  381 ++
 modules/video_output/drmu/drmu_vlc.h       |   81 +
 modules/video_output/drmu/drmu_vlc_fmts.c  |  258 ++
 modules/video_output/drmu/drmu_vlc_fmts.h  |   57 +
 modules/video_output/drmu/drmu_writeback.c |  429 +++
 modules/video_output/drmu/drmu_writeback.h |   64 +
 modules/video_output/drmu/drmu_xlease.c    |  143 +
 modules/video_output/drmu/pollqueue.c      |  716 ++++
 modules/video_output/drmu/pollqueue.h      |  101 +
 32 files changed, 12278 insertions(+)
 create mode 100644 modules/video_output/drmu/drm_vout.c
 create mode 100644 modules/video_output/drmu/drmu.c
 create mode 100644 modules/video_output/drmu/drmu.h
 create mode 100644 modules/video_output/drmu/drmu_atomic.c
 create mode 100644 modules/video_output/drmu/drmu_chroma.h
 create mode 100644 modules/video_output/drmu/drmu_dmabuf.c
 create mode 100644 modules/video_output/drmu/drmu_dmabuf.h
 create mode 100644 modules/video_output/drmu/drmu_fmts.c
 create mode 100644 modules/video_output/drmu/drmu_fmts.h
 create mode 100644 modules/video_output/drmu/drmu_log.h
 create mode 100644 modules/video_output/drmu/drmu_math.c
 create mode 100644 modules/video_output/drmu/drmu_math.h
 create mode 100644 modules/video_output/drmu/drmu_output.c
 create mode 100644 modules/video_output/drmu/drmu_output.h
 create mode 100644 modules/video_output/drmu/drmu_poll.c
 create mode 100644 modules/video_output/drmu/drmu_poll.h
 create mode 100644 modules/video_output/drmu/drmu_pool.c
 create mode 100644 modules/video_output/drmu/drmu_pool.h
 create mode 100644 modules/video_output/drmu/drmu_scan.c
 create mode 100644 modules/video_output/drmu/drmu_scan.h
 create mode 100644 modules/video_output/drmu/drmu_util.c
 create mode 100644 modules/video_output/drmu/drmu_util.h
 create mode 100644 modules/video_output/drmu/drmu_vlc.c
 create mode 100644 modules/video_output/drmu/drmu_vlc.h
 create mode 100644 modules/video_output/drmu/drmu_vlc_fmts.c
 create mode 100644 modules/video_output/drmu/drmu_vlc_fmts.h
 create mode 100644 modules/video_output/drmu/drmu_writeback.c
 create mode 100644 modules/video_output/drmu/drmu_writeback.h
 create mode 100644 modules/video_output/drmu/drmu_xlease.c
 create mode 100644 modules/video_output/drmu/pollqueue.c
 create mode 100644 modules/video_output/drmu/pollqueue.h

--- a/modules/video_output/Makefile.am
+++ b/modules/video_output/Makefile.am
@@ -191,6 +191,35 @@ vout_LTLIBRARIES += libglx_plugin.la
 endif
 endif
 
+### DRM ###
+
+libdrm_vout_plugin_la_SOURCES = video_output/drmu/drm_vout.c \
+	video_output/drmu/drmu_vlc.c video_output/drmu/drmu_vlc.h \
+	video_output/drmu/drmu_vlc_fmts.c video_output/drmu/drmu_vlc_fmts.h \
+	video_output/drmu/drmu_fmts.c video_output/drmu/drmu_fmts.h \
+	video_output/drmu/drmu_chroma.h \
+	video_output/drmu/drmu_writeback.h video_output/drmu/drmu_writeback.c \
+	video_output/drmu/drmu_poll.h video_output/drmu/drmu_poll.c \
+	video_output/drmu/drmu_log.h video_output/drmu/drmu.c \
+	video_output/drmu/drmu_xlease.c video_output/drmu/drmu_atomic.c \
+	video_output/drmu/drmu_util.c video_output/drmu/drmu_util.h \
+	video_output/drmu/drmu_output.c video_output/drmu/drmu_output.h \
+	video_output/drmu/drmu_scan.c video_output/drmu/drmu_scan.h \
+	video_output/drmu/drmu.h\
+	video_output/drmu/drmu_dmabuf.c video_output/drmu/drmu_dmabuf.h \
+	video_output/drmu/drmu_pool.c video_output/drmu/drmu_pool.h \
+	video_output/drmu/drmu_math.c video_output/drmu/drmu_math.h \
+	video_output/drmu/pollqueue.c video_output/drmu/pollqueue.h
+libdrm_vout_plugin_la_CFLAGS = $(AM_CFLAGS) -pthread -I/usr/include/libdrm
+libdrm_vout_plugin_la_LDFLAGS = $(AM_LDFLAGS) -pthread
+libdrm_vout_plugin_la_LIBADD = -ldrm -lxcb-randr -lxcb
+if HAVE_MMAL
+libdrm_vout_plugin_la_CFLAGS += -DHAS_ZC_CMA=1
+libdrm_vout_plugin_la_SOURCES += hw/mmal/mmal_cma_pic.h
+endif
+if HAVE_DRM
+vout_LTLIBRARIES += libdrm_vout_plugin.la
+endif
 
 ### Wayland ###
 libwl_shm_plugin_la_SOURCES = video_output/wayland/shm.c
--- /dev/null
+++ b/modules/video_output/drmu/drm_vout.c
@@ -0,0 +1,1503 @@
+/*****************************************************************************
+ * drm_vout.c: DRM based output device
+ *****************************************************************************
+ * Copyright ï¿½ 2014 jusst technologies GmbH
+ *
+ * Authors: Dennis Hamester <dennis.hamester@gmail.com>
+ *          Julian Scheel <julian@jusst.de>
+ *          John Cox <jc@kynesim.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <errno.h>
+#include <pthread.h>
+
+#include "drmu.h"
+#include "drmu_dmabuf.h"
+#include "drmu_fmts.h"
+#include "drmu_log.h"
+#include "drmu_output.h"
+#include "drmu_pool.h"
+#include "drmu_scan.h"
+#include "drmu_util.h"
+#include "drmu_vlc.h"
+#include "drmu_writeback.h"
+
+#include <vlc_common.h>
+
+#include <vlc_codec.h>
+#include <vlc_picture.h>
+#include <vlc_plugin.h>
+#include <vlc_vout_display.h>
+
+#include <libdrm/drm.h>
+#include <libdrm/drm_mode.h>
+#include <libdrm/drm_fourcc.h>
+
+#define TRACE_ALL 0
+#define PIC_POOL_FB 1
+
+#define SUBPICS_MAX 4
+
+#define DRM_MODULE "vc4"
+
+
+#define DRM_VOUT_SOURCE_MODESET_NAME "drm-vout-source-modeset"
+#define DRM_VOUT_SOURCE_MODESET_TEXT N_("Attempt to match display to source")
+#define DRM_VOUT_SOURCE_MODESET_LONGTEXT N_("Attempt to match display resolution and refresh rate to source.\
+ Defaults to the 'preferred' mode if no good enough match found. \
+ If unset then resolution & refresh will not be set.")
+
+#define DRM_VOUT_MODE_NAME "drm-vout-mode"
+#define DRM_VOUT_MODE_TEXT N_("Set this mode for display")
+#define DRM_VOUT_MODE_LONGTEXT N_("arg: <w>x<h>@<hz> Force mode to arg")
+
+#define DRM_VOUT_NO_MODESET_NAME "drm-vout-no-modeset"
+#define DRM_VOUT_NO_MODESET_TEXT N_("Do not modeset")
+#define DRM_VOUT_NO_MODESET_LONGTEXT N_("Do no operation that would cause a modeset.\
+ This overrides the operation of all other flags.")
+
+#define DRM_VOUT_NO_MAX_BPC "drm-vout-no-max-bpc"
+#define DRM_VOUT_NO_MAX_BPC_TEXT N_("Do not set bpc on output")
+#define DRM_VOUT_NO_MAX_BPC_LONGTEXT N_("Do not try to switch from 8-bit RGB to 12-bit YCC on UHD frames.\
+ 12 bit is dependant on kernel and display support so may not be availible")
+
+#define DRM_VOUT_WINDOW_NAME "drm-vout-window"
+#define DRM_VOUT_WINDOW_TEXT N_("Display window for Rpi fullscreen")
+#define DRM_VOUT_WINDOW_LONGTEXT N_("Display window for Rpi fullscreen."\
+"fullscreen|<width>x<height>+<x>+<y>")
+
+#define DRM_VOUT_DISPLAY_NAME "drm-vout-display"
+#define DRM_VOUT_DISPLAY_TEXT N_("Output device for Rpi fullscreen.")
+#define DRM_VOUT_DISPLAY_LONGTEXT N_("Output device for Rpi fullscreen. " \
+"Valid values are HDMI-1,HDMI-2 or a drm connector name.  By default if qt-fullscreen-screennumber " \
+"is specified (or set by Fullscreen Output Device in Preferences) " \
+"HDMI-<qt-fullscreen-screennumber+1> will be used, otherwise HDMI-1.")
+
+#define DRM_VOUT_MODULE_NAME "drm-vout-module"
+#define DRM_VOUT_MODULE_TEXT N_("DRM module to use")
+#define DRM_VOUT_MODULE_LONGTEXT N_("DRM module for Rpi fullscreen")
+
+#define DRM_VOUT_POOL_DMABUF_NAME "drm-vout-pool-dmabuf"
+#define DRM_VOUT_POOL_DMABUF_TEXT N_("Use dmabufs for pic pool")
+#define DRM_VOUT_POOL_DMABUF_LONGTEXT N_("Use dmabufs for pic pool. Saves a frame copy on output but may use up limited dmabuf resource.")
+
+
+typedef struct subpic_ent_s {
+    drmu_fb_t * fb;
+    drmu_rect_t pos;
+    drmu_rect_t space;  // display space of pos
+    picture_t * pic;
+    unsigned int alpha; // out of 0xff * 0xff
+} subpic_ent_t;
+
+typedef struct wb_display_env_s {
+    drmu_atomic_t * da;
+    drmu_rect_t display_rect;
+    drmu_plane_t * dp;
+} wb_display_env_t;
+
+typedef struct vout_display_sys_t {
+    drmu_env_t * du;
+    drmu_output_t * dout;
+    drmu_plane_t * dp;
+    drmu_pool_t * pic_pool;
+    drmu_pool_t * sub_fb_pool;
+
+    unsigned int display_orientation;
+    drmu_writeback_env_t * wbe;
+    drmu_writeback_fb_t * pic_wbq;
+    wb_display_env_t * wde;
+    drmu_fb_t * wb_fb;
+
+    drmu_plane_t * subplanes[SUBPICS_MAX];
+    subpic_ent_t subpics[SUBPICS_MAX];
+    vlc_fourcc_t * subpic_chromas;
+
+    drmu_atomic_t * display_set;
+
+    vout_display_place_t req_win;
+    vout_display_place_t spu_rect;
+    vout_display_place_t dest_rect;
+    vout_display_place_t win_rect;
+    vout_display_place_t display_rect;
+
+    video_transform_t display_transform;
+    video_transform_t video_transform;
+    video_transform_t dest_transform;
+
+    bool pool_try_fb;
+    bool pool_is_fb;
+    bool output_simple;
+    uint32_t con_id;
+    int mode_id;
+
+    picture_pool_t * vlc_pic_pool;
+} vout_display_sys_t;
+
+#define PIC_SYS_SIG VLC_FOURCC('D', 'R', 'M', 'U')
+
+
+// pic->p_sys when we are allocating our own pics
+struct picture_sys_t {
+    uint32_t sig;
+    drmu_fb_t * fb;
+};
+
+static drmu_fb_t *
+copy_pic_to_fb(vout_display_t *const vd, drmu_pool_t *const pool, picture_t *const src)
+{
+    uint64_t mod;
+    const uint32_t drm_fmt = drmu_format_vlc_to_drm(&src->format, &mod);
+    drmu_fb_t * fb;
+    int i;
+
+    if (drm_fmt == 0 || mod != DRM_FORMAT_MOD_LINEAR) {
+        msg_Warn(vd, "Failed vlc->drm format for copy_pic: %s", drmu_log_fourcc(src->format.i_chroma));
+        return NULL;
+    }
+
+    fb = drmu_pool_fb_new(pool, src->format.i_width, src->format.i_height, drm_fmt, mod);
+    if (fb == NULL) {
+        msg_Warn(vd, "Failed alloc for copy_pic: %dx%d", src->format.i_width, src->format.i_height);
+        return NULL;
+    }
+
+    drmu_fb_write_start(fb);
+    for (i = 0; i != src->i_planes; ++i) {
+        plane_t dst_plane;
+        dst_plane = drmu_fb_vlc_plane(fb, i);
+        plane_CopyPixels(&dst_plane, src->p + i);
+    }
+    drmu_fb_write_end(fb);
+
+    drmu_fb_vlc_pic_set_metadata(fb, src);
+
+    return fb;
+}
+
+static void
+create_box(drmu_fb_t * const fb, const unsigned int layer_no)
+{
+    const drmu_fmt_info_t *const f = drmu_fb_format_info_get(fb);
+    unsigned int hdiv = drmu_fmt_info_hdiv(f, layer_no);
+    unsigned int wdiv = drmu_fmt_info_wdiv(f, layer_no);
+    const unsigned int pby = (drmu_fmt_info_pixel_bits(f) + 7) / 8;
+    const uint32_t pitch_n = drmu_fb_pitch(fb, layer_no);
+    const drmu_rect_t crop = drmu_rect_shr16_rnd(drmu_fb_crop_frac(fb));
+    const drmu_rect_t active = drmu_fb_active(fb);
+
+    uint8_t * const p0 = drmu_fb_data(fb, layer_no);
+    uint8_t * p1 = p0;
+    uint8_t * p2;
+
+    // Assumes RGB as currently no better idea (and it is RGB in the case we expect)
+    const unsigned int c = 0;
+
+    // Top
+    p2 = p1 + pitch_n * (crop.y / hdiv) + (crop.x / wdiv) * pby;
+    if (p1 != p2)
+        memset(p1, c, p2 - p1);
+    if (active.w == crop.w) {
+        p1 = p2 + (crop.h / hdiv) * pitch_n; // We expect crop.x == 0
+    }
+    else {
+        unsigned int i;
+        const unsigned int vis_pitch = (crop.w / wdiv) * pby;
+        for (i = 1; i < (crop.h / hdiv); ++i) {
+            p1 = p2 + vis_pitch;
+            p2 = p2 + pitch_n;
+            memset(p1, c, p2 - p1);
+        }
+        p1 = p2 + vis_pitch;
+    }
+    p2 = p0 + pitch_n * (active.h / hdiv);
+    if (p1 != p2)
+        memset(p1, c, p2 - p1);
+}
+
+static drmu_fb_t *
+copy_pic_to_fixed_fb(vout_display_t * const vd, vout_display_sys_t * const sys,
+                     drmu_pool_t *const pool, picture_t *const src)
+{
+    uint64_t mod;
+    const uint32_t drm_fmt = drmu_format_vlc_to_drm(&src->format, &mod);
+    drmu_fb_t * fb;
+    int i;
+
+    if (drm_fmt == 0 || mod != DRM_FORMAT_MOD_LINEAR) {
+        msg_Warn(vd, "Failed vlc->drm format for copy_pic: %s", drmu_log_fourcc(src->format.i_chroma));
+        return NULL;
+    }
+
+    fb = drmu_pool_fb_new(pool, sys->display_rect.width, sys->display_rect.height, drm_fmt, mod);
+    if (fb == NULL) {
+        msg_Warn(vd, "Failed alloc for copy_pic_fixed: %dx%d", sys->display_rect.width, sys->display_rect.height);
+        return NULL;
+    }
+
+    drmu_fb_crop_frac_set(fb, drmu_rect_shl16(drmu_rect_vlc_place(&sys->dest_rect)));
+
+    {
+        const drmu_fmt_info_t *const f = drmu_fb_format_info_get(fb);
+        const drmu_rect_t crop = drmu_rect_shr16_rnd(drmu_fb_crop_frac(fb));
+        const unsigned int bypp = (drmu_fmt_info_pixel_bits(f) + 7) / 8;
+
+        drmu_fb_write_start(fb);
+        for (i = 0; i != src->i_planes; ++i) {
+            // It would seem more logical to use src->format than to use vd->fmt
+            // for the source rect but src->fmt doesn't have offset_x/y set (bug?)
+            drmu_memcpy_rect(drmu_fb_data(fb, i), drmu_fb_pitch(fb, i),
+                             drmu_rect_div_xy(crop, drmu_fmt_info_wdiv(f, i), drmu_fmt_info_hdiv(f, i)),
+                             src->p[i].p_pixels, src->p[i].i_pitch,
+                             drmu_rect_vlc_format_crop(&vd->fmt),
+                             bypp);
+            create_box(fb, i);
+        }
+        drmu_fb_write_end(fb);
+    }
+
+    // Reset crop for display after we've used it for copy
+    drmu_fb_crop_frac_set(fb, drmu_rect_shl16(drmu_fb_active(fb)));
+
+    drmu_fb_vlc_pic_set_metadata(fb, src);
+
+    return fb;
+}
+
+
+static vout_display_place_t str_to_rect(const char * s)
+{
+    vout_display_place_t rect = {0};
+    rect.width = strtoul(s, (char**)&s, 0);
+    if (*s == '\0')
+        return rect;
+    if (*s++ != 'x')
+        goto fail;
+    rect.height = strtoul(s, (char**)&s, 0);
+    if (*s == '\0')
+        return rect;
+    if (*s++ != '+')
+        goto fail;
+    rect.x = strtoul(s, (char**)&s, 0);
+    if (*s == '\0')
+        return rect;
+    if (*s++ != '+')
+        goto fail;
+    rect.y = strtoul(s, (char**)&s, 0);
+    if (*s != '\0')
+        goto fail;
+    return rect;
+
+fail:
+    return (vout_display_place_t){0,0,0,0};
+}
+
+// MMAL headers comment these (getting 2 a bit wrong) but do not give
+// defines
+#define VXF_H_SHIFT 0  // Hflip
+#define VXF_V_SHIFT 1  // Vflip
+#define VXF_T_SHIFT 2  // Transpose
+#define VXF_H_BIT   (1 << VXF_H_SHIFT)
+#define VXF_V_BIT   (1 << VXF_V_SHIFT)
+#define VXF_T_BIT   (1 << VXF_T_SHIFT)
+
+static inline bool
+is_vxf_transpose(const video_transform_t t)
+{
+    return ((unsigned int)t & VXF_T_BIT) != 0;
+}
+
+static inline bool
+is_vxf_hflip(const video_transform_t t)
+{
+    return ((unsigned int)t & VXF_H_BIT) != 0;
+}
+
+static inline bool
+is_vxf_vflip(const video_transform_t t)
+{
+    return ((unsigned int)t & VXF_V_BIT) != 0;
+}
+
+static inline video_transform_t
+swap_vxf_hv(const video_transform_t x)
+{
+    return (((x >> VXF_H_SHIFT) & 1) << VXF_V_SHIFT) |
+           (((x >> VXF_V_SHIFT) & 1) << VXF_H_SHIFT) |
+           (x & VXF_T_BIT);
+}
+
+static inline video_transform_t
+vxf_inverse(const video_transform_t x)
+{
+    return is_vxf_transpose(x) ? swap_vxf_hv(x) : x;
+}
+
+// Transform generated by A then B
+// All ops are self inverse so can simply be XORed on their own
+// H & V flips after a transpose need to be swapped
+static inline video_transform_t
+combine_vxf(const video_transform_t a, const video_transform_t b)
+{
+    return a ^ (is_vxf_transpose(a) ? swap_vxf_hv(b) : b);
+}
+
+static inline vout_display_place_t
+vplace_transpose(const vout_display_place_t s)
+{
+    return (vout_display_place_t){
+        .x      = s.y,
+        .y      = s.x,
+        .width  = s.height,
+        .height = s.width
+    };
+}
+
+// hflip s in c
+static inline vout_display_place_t vplace_hflip(const vout_display_place_t s, const vout_display_place_t c)
+{
+    return (vout_display_place_t){
+        .x = c.x + (c.x + c.width) - (s.x + s.width),
+        .y = s.y,
+        .width = s.width,
+        .height = s.height
+    };
+}
+
+// vflip s in c
+static inline vout_display_place_t vplace_vflip(const vout_display_place_t s, const vout_display_place_t c)
+{
+    return (vout_display_place_t){
+        .x = s.x,
+        .y = (c.y + c.height) - (s.y - c.y) - s.height,
+        .width = s.width,
+        .height = s.height
+    };
+}
+
+static vout_display_place_t
+place_out(const vout_display_cfg_t * cfg,
+          const video_format_t * fmt,
+          const vout_display_place_t r)
+{
+    video_format_t tfmt;
+    vout_display_cfg_t tcfg;
+    vout_display_place_t place;
+
+    // Fix SAR if unknown
+    if (fmt->i_sar_den == 0 || fmt->i_sar_num == 0) {
+        tfmt = *fmt;
+        tfmt.i_sar_den = 1;
+        tfmt.i_sar_num = 1;
+        fmt = &tfmt;
+    }
+
+    // Override what VLC thinks might be going on with display size
+    // if we know better
+    if (r.width != 0 && r.height != 0)
+    {
+        tcfg = *cfg;
+        tcfg.display.width = r.width;
+        tcfg.display.height = r.height;
+        cfg = &tcfg;
+    }
+
+    vout_display_PlacePicture(&place, fmt, cfg, false);
+
+    place.x += r.x;
+    place.y += r.y;
+
+    return place;
+}
+
+static vout_display_place_t
+rect_transform(vout_display_place_t s, const vout_display_place_t c, const video_transform_t t)
+{
+    if (is_vxf_transpose(t))
+        s = vplace_transpose(s);
+    if (is_vxf_hflip(t))
+        s = vplace_hflip(s, c);
+    if (is_vxf_vflip(t) != 0)
+        s = vplace_vflip(s, c);
+    return s;
+}
+
+static void
+place_dest_rect(vout_display_sys_t * const sys,
+          const vout_display_cfg_t * const cfg,
+          const video_format_t * fmt)
+{
+    sys->dest_rect = rect_transform(place_out(cfg, fmt, sys->win_rect),
+                                    sys->display_rect, sys->dest_transform);
+}
+
+static void
+place_spu_rect(vout_display_sys_t * const sys,
+               const vout_display_cfg_t * const cfg,
+               const video_format_t * fmt)
+{
+    static const vout_display_place_t r0 = {0};
+
+    sys->spu_rect = place_out(cfg, fmt, r0);
+    sys->spu_rect.x = 0;
+    sys->spu_rect.y = 0;
+
+    // Copy place override logic for spu pos from video_output.c
+    // This info doesn't appear to reside anywhere natively
+
+    if (fmt->i_width * fmt->i_height >= (unsigned int)(sys->spu_rect.width * sys->spu_rect.height)) {
+        sys->spu_rect.width  = fmt->i_visible_width;
+        sys->spu_rect.height = fmt->i_visible_height;
+    }
+
+    if (ORIENT_IS_SWAP(fmt->orientation))
+        sys->spu_rect = vplace_transpose(sys->spu_rect);
+}
+
+static void
+place_rects(vout_display_sys_t * const sys,
+            const vout_display_cfg_t * const cfg,
+            const video_format_t * fmt)
+{
+    place_dest_rect(sys, cfg, fmt);
+    place_spu_rect(sys, cfg, fmt);
+}
+
+static int configure_display(const vout_display_t *vd, vout_display_sys_t *const sys,
+                             const vout_display_cfg_t *cfg, const video_format_t *fmt)
+{
+    if (!cfg && !fmt)
+    {
+        msg_Err(vd, "%s: Missing cfg & fmt", __func__);
+        return -EINVAL;
+    }
+
+    if (!fmt)
+        fmt = &vd->source;
+
+    if (!cfg)
+        cfg = vd->cfg;
+
+    sys->video_transform = combine_vxf((video_transform_t)fmt->orientation, sys->display_transform);
+
+    place_rects(sys, cfg, fmt);
+    return 0;
+}
+
+static void set_display_windows(vout_display_t *const vd, vout_display_sys_t *const sys)
+{
+    const drmu_mode_simple_params_t * const mode = drmu_output_mode_simple_params(sys->dout);
+    VLC_UNUSED(vd);
+
+    sys->display_rect = (vout_display_place_t) {0, 0, mode->width, mode->height};
+
+    sys->win_rect = (sys->req_win.width != 0) ?
+            sys->req_win :
+         is_vxf_transpose(sys->display_transform) ?
+            vplace_transpose(sys->display_rect) : sys->display_rect;
+}
+
+static void
+wb_display_done_cb(void * v, drmu_fb_t * fb)
+{
+    wb_display_env_t * const wde = v;
+    if (fb != NULL) {
+        drmu_atomic_plane_add_fb(wde->da, wde->dp, fb, wde->display_rect);
+        drmu_atomic_queue(&wde->da);
+    }
+    drmu_atomic_unref(&wde->da);
+    drmu_plane_unref(&wde->dp);
+    free(wde);
+}
+
+static void vd_drm_prepare(vout_display_t *vd, picture_t *pic,
+                       subpicture_t *subpicture)
+{
+    vout_display_sys_t * const sys = vd->sys;
+    unsigned int n = 0;
+    drmu_atomic_t * da = drmu_atomic_new(sys->du);
+    drmu_fb_t * dfb = NULL;
+    drmu_rect_t r;
+    unsigned int i;
+    int ret;
+
+    if (da == NULL)
+        goto fail;
+
+    if (sys->display_set != NULL) {
+        msg_Warn(vd, "sys->display_set != NULL");
+        drmu_atomic_unref(&sys->display_set);
+    }
+
+    // * Mode (currently) doesn't change whilst running so no need to set here
+
+    // Attempt to import the subpics
+    for (subpicture_t * spic = subpicture; spic != NULL; spic = spic->p_next)
+    {
+        for (subpicture_region_t *sreg = spic->p_region; sreg != NULL; sreg = sreg->p_next) {
+            picture_t * const src = sreg->p_picture;
+            subpic_ent_t * const dst = sys->subpics + n;
+
+            // If we've run out of subplanes we could allocate - give up now
+            if (!sys->subplanes[n])
+                goto subpics_done;
+
+            // If the same picture then assume the same contents
+            // We keep a ref to the previous pic to ensure that the same picture
+            // structure doesn't get reused and confuse us.
+            if (src != dst->pic) {
+                drmu_fb_unref(&dst->fb);
+                if (dst->pic != NULL) {
+                    picture_Release(dst->pic);
+                    dst->pic = NULL;
+                }
+
+                dst->fb = copy_pic_to_fb(vd, sys->sub_fb_pool, src);
+                if (dst->fb == NULL)
+                    continue;
+                drmu_fb_pixel_blend_mode_set(dst->fb, DRMU_FB_PIXEL_BLEND_COVERAGE);
+
+                dst->pic = picture_Hold(src);
+            }
+            drmu_fb_crop_frac_set(dst->fb, drmu_rect_shl16(drmu_rect_vlc_format_crop(&sreg->fmt)));
+
+            // *** More transform required
+            dst->pos = (drmu_rect_t){
+                .x = sreg->i_x,
+                .y = sreg->i_y,
+                .w = sreg->fmt.i_visible_width,
+                .h = sreg->fmt.i_visible_height,
+            };
+            dst->alpha = spic->i_alpha * sreg->i_alpha;
+
+//            msg_Info(vd, "Orig: %dx%d, (%d,%d) %dx%d; offset %d,%d", spic->i_original_picture_width, spic->i_original_picture_height,
+//                     sreg->i_x, sreg->i_y, src->format.i_visible_width, src->format.i_visible_height,
+//                     sreg->fmt.i_x_offset, sreg->fmt.i_y_offset);
+            dst->space = drmu_rect_vlc_place(&sys->spu_rect);
+
+            if (++n == SUBPICS_MAX)
+                goto subpics_done;
+        }
+    }
+subpics_done:
+
+    // Clear any other entries
+    for (; n != SUBPICS_MAX; ++n) {
+        subpic_ent_t * const dst = sys->subpics + n;
+        if (dst->pic != NULL) {
+            picture_Release(dst->pic);
+            dst->pic = NULL;
+        }
+        drmu_fb_unref(&dst->fb);
+    }
+
+    r = sys->output_simple ? drmu_rect_vlc_place(&sys->display_rect): drmu_rect_vlc_place(&sys->dest_rect);
+
+#if 0
+    {
+        static int z = 0;
+        if (--z < 0) {
+            z = 200;
+            msg_Info(vd, "Pic: %d,%d %dx%d/%dx%d %d/%d Fmt: %d,%d %dx%d/%dx%d %d/%d Src: %d,%d %dx%d/%dx%d %d/%d Display: %dx%d %d/%d Place: %d,%d %dx%d",
+                     pic->format.i_x_offset, pic->format.i_y_offset,
+                     pic->format.i_width, pic->format.i_height,
+                     pic->format.i_visible_width, pic->format.i_visible_height,
+                     pic->format.i_sar_num, pic->format.i_sar_den,
+                     vd->fmt.i_x_offset, vd->fmt.i_y_offset,
+                     vd->fmt.i_width, vd->fmt.i_height,
+                     vd->fmt.i_visible_width, vd->fmt.i_visible_height,
+                     vd->fmt.i_sar_num, vd->fmt.i_sar_den,
+                     vd->source.i_x_offset, vd->source.i_y_offset,
+                     vd->source.i_width, vd->source.i_height,
+                     vd->source.i_visible_width, vd->source.i_visible_height,
+                     vd->source.i_sar_num, vd->source.i_sar_den,
+                     vd->cfg->display.width,   vd->cfg->display.height,
+                     vd->cfg->display.sar.num, vd->cfg->display.sar.den,
+                     r.x, r.y, r.w, r.h);
+        }
+    }
+#endif
+
+#if HAS_ZC_CMA
+    if (drmu_format_vlc_to_drm_cma(&pic->format, NULL) != 0) {
+        dfb = drmu_fb_vlc_new_pic_cma_attach(sys->du, pic);
+    }
+    else
+#endif
+#if HAS_DRMPRIME
+    if (drmu_format_vlc_to_drm_prime(&pic->format, NULL) != 0) {
+        dfb = drmu_fb_vlc_new_pic_attach(sys->du, pic);
+    }
+    else
+#endif
+
+    if (sys->pool_is_fb && pic->p_sys != NULL && pic->p_sys->sig == PIC_SYS_SIG) {
+        dfb = drmu_fb_ref(pic->p_sys->fb);
+    }
+    else if (sys->output_simple) {
+        dfb = copy_pic_to_fixed_fb(vd, sys, sys->pic_pool, pic);
+    }
+    else {
+        dfb = copy_pic_to_fb(vd, sys->pic_pool, pic);
+    }
+
+    if (dfb == NULL) {
+        msg_Err(vd, "Failed to create frme buffer from pic");
+        return;
+    }
+    // * Maybe scale cropping by vd->fmt.i_width/height / vd->source.i_width/height
+    //   to get pic coord cropping
+    //   Wait until we have a bad test case before doing this as I'm worried
+    //   that we may get unexpected w/h mismatches that do unwanted scaling
+#if 0
+    drmu_fb_crop_frac_set(dfb,
+        drmu_rect_rescale(
+            drmu_rect_vlc_format_crop(&vd->source),
+            drmu_rect_shl16(drmu_rect_wh(vd->fmt.i_width, vd->fmt.i_height)),
+            drmu_rect_wh(vd->source.i_width, vd->source.i_height)));
+#else
+    if (!sys->output_simple)
+        drmu_fb_crop_frac_set(dfb, drmu_rect_shl16(drmu_rect_vlc_format_crop(&vd->source)));
+#endif
+    drmu_output_fb_info_set(sys->dout, dfb);
+
+    {
+        unsigned int pic_rot = drmu_fb_rotation(dfb, sys->display_orientation);
+        if (!drmu_plane_rotation_valid(sys->dp, pic_rot)) {
+
+            if (sys->wbe == NULL) {
+                sys->wbe = drmu_writeback_env_new(sys->du);
+                sys->pic_wbq = drmu_writeback_fb_new(sys->wbe, sys->pic_pool);
+            }
+
+            sys->wde = calloc(1, sizeof(*sys->wde));
+            sys->wde->display_rect = r;
+            sys->wde->dp = drmu_plane_ref(sys->dp);
+            sys->wde->da = drmu_atomic_ref(da); // Just a ref - not a copy so later adds apply
+            sys->wb_fb = drmu_fb_ref(dfb);
+            ret = 0;
+        }
+        else {
+            ret = drmu_atomic_plane_add_fb(da, sys->dp, dfb, r);
+            drmu_atomic_plane_add_rotation(da, sys->dp, pic_rot);
+        }
+    }
+
+    drmu_atomic_output_add_props(da, sys->dout);
+    drmu_fb_unref(&dfb);
+
+    if (ret != 0) {
+        msg_Err(vd, "Failed to set video plane: %s", strerror(-ret));
+        goto fail;
+    }
+
+    for (i = 0; i != SUBPICS_MAX; ++i) {
+        subpic_ent_t * const spe = sys->subpics + i;
+
+//        msg_Info(vd, "pic=%dx%d @ %d,%d, r=%dx%d @ %d,%d, space=%dx%d @ %d,%d",
+//                 spe->pos.w, spe->pos.h, spe->pos.x, spe->pos.y,
+//                 r.w, r.h, r.x, r.y,
+//                 spe->space.w, spe->space.h, spe->space.x, spe->space.y);
+
+        // Rescale from sub-space
+        if (sys->subplanes[i])
+        {
+            if ((ret = drmu_atomic_plane_add_fb(da, sys->subplanes[i], spe->fb,
+                                  drmu_rect_rescale(spe->pos, r, spe->space))) != 0) {
+                 msg_Err(vd, "drmModeSetPlane for subplane %d failed: %s", i, strerror(-ret));
+            }
+            drmu_atomic_plane_add_alpha(da, sys->subplanes[i], (spe->alpha * DRMU_PLANE_ALPHA_OPAQUE) / (0xff * 0xff));
+        }
+    }
+
+    sys->display_set = da;
+
+#if TRACE_ALL
+    msg_Dbg(vd, "<<< %s", __func__);
+#endif
+    return;
+
+fail:
+    drmu_fb_unref(&dfb);
+    drmu_atomic_unref(&da);
+}
+
+static void vd_drm_display(vout_display_t *vd, picture_t *p_pic,
+                subpicture_t *subpicture)
+{
+    vout_display_sys_t *const sys = vd->sys;
+
+#if TRACE_ALL
+    msg_Dbg(vd, "<<< %s", __func__);
+#endif
+
+    if (sys->wde) {
+        // Pick the smallest of display and source as writeback buffer size
+        drmu_rect_t wb_rect = drmu_rect_shr16(drmu_fb_crop_frac(sys->wb_fb));
+        if (sys->wde->display_rect.w < wb_rect.w)
+            wb_rect.w = sys->wde->display_rect.w;
+        if (sys->wde->display_rect.h < wb_rect.h)
+            wb_rect.h = sys->wde->display_rect.h;
+
+        drmu_atomic_unref(&sys->display_set);
+        drmu_writeback_fb_queue(sys->pic_wbq, wb_rect, sys->display_orientation, DRM_FORMAT_XRGB8888, wb_display_done_cb, sys->wde, sys->wb_fb);
+        sys->wde = NULL;
+        drmu_fb_unref(&sys->wb_fb);
+    }
+    else {
+        drmu_atomic_queue(&sys->display_set);
+    }
+
+    if (subpicture)
+        subpicture_Delete(subpicture);
+    picture_Release(p_pic);
+    return;
+}
+
+static void
+destroy_drmu_pic(picture_t * pic)
+{
+    drmu_fb_unref(&pic->p_sys->fb);
+    free(pic->p_sys);
+    free(pic);
+}
+
+static picture_t *
+alloc_drmu_pic(vout_display_t * const vd, drmu_pool_t *const pool)
+{
+    const video_format_t * const fmt = &vd->fmt;
+    uint64_t mod;
+    const uint32_t drm_fmt = drmu_format_vlc_to_drm(fmt, &mod);
+    const drmu_fmt_info_t * fmti;
+    drmu_fb_t * fb;
+    unsigned int layers;
+    unsigned int i;
+    picture_t * pic;
+    picture_resource_t res = {
+        .p_sys = NULL,
+        .pf_destroy = destroy_drmu_pic,
+    };
+
+    if (drm_fmt == 0 || mod != DRM_FORMAT_MOD_LINEAR) {
+        msg_Warn(vd, "Failed vlc->drm format for copy_pic: %s", drmu_log_fourcc(fmt->i_chroma));
+        return NULL;
+    }
+
+    fb = drmu_pool_fb_new(pool, fmt->i_width, fmt->i_height, drm_fmt, mod);
+    if (fb == NULL) {
+        msg_Warn(vd, "Failed alloc for copy_pic: %dx%d", fmt->i_width, fmt->i_height);
+        return NULL;
+    }
+
+    if ((res.p_sys = calloc(1, sizeof(*res.p_sys))) == NULL)
+        goto fail;
+
+    res.p_sys->sig = PIC_SYS_SIG;
+    res.p_sys->fb = fb;
+
+    fmti = drmu_fb_format_info_get(fb);
+    layers = drmu_fmt_info_plane_count(fmti);
+
+    for (i = 0; i != layers; ++i) {
+        res.p[i].p_pixels = drmu_fb_data(fb, i);
+        res.p[i].i_lines = drmu_fb_height(fb) / drmu_fmt_info_hdiv(fmti, i);
+        res.p[i].i_pitch = drmu_fb_pitch(fb, i);
+    }
+
+    if ((pic = picture_NewFromResource(fmt, &res)) == NULL)
+        goto fail;
+
+    return pic;
+
+fail:
+    drmu_fb_unref(&fb);
+    free(res.p_sys);
+    return NULL;
+}
+
+static void subpic_cache_flush(vout_display_sys_t * const sys)
+{
+    for (unsigned int i = 0; i != SUBPICS_MAX; ++i) {
+        if (sys->subpics[i].pic != NULL) {
+            picture_Release(sys->subpics[i].pic);
+            sys->subpics[i].pic = NULL;
+        }
+        drmu_fb_unref(&sys->subpics[i].fb);
+    }
+}
+
+static void kill_pool(vout_display_sys_t * const sys)
+{
+    // Drop all cached subpics
+    subpic_cache_flush(sys);
+
+    if (sys->vlc_pic_pool != NULL) {
+        picture_pool_Release(sys->vlc_pic_pool);
+        sys->vlc_pic_pool = NULL;
+    }
+}
+
+static picture_pool_t *
+make_fb_pool(vout_display_t * const vd, vout_display_sys_t * const sys, const unsigned int count)
+{
+    picture_t * pics[40];
+    unsigned int pics_alloc;
+    picture_pool_t * pool;
+
+    if (count > ARRAY_SIZE(pics))
+        return NULL;
+
+    for (pics_alloc = 0; pics_alloc != count; ++pics_alloc) {
+        if ((pics[pics_alloc] = alloc_drmu_pic(vd, sys->pic_pool)) == NULL) {
+            msg_Err(vd, "Failed to alloc pic pool entry %u", pics_alloc);
+            goto fail;
+        }
+    }
+
+    if ((pool = picture_pool_New(pics_alloc, pics)) == NULL) {
+        msg_Err(vd, "Failed to alloc picture pool");
+        goto fail;
+    }
+
+    return pool;
+
+fail:
+    while (pics_alloc != 0)
+        picture_Release(pics[--pics_alloc]);
+    return NULL;
+}
+
+// Actual picture pool for MMAL opaques is just a set of trivial containers
+static picture_pool_t *vd_drm_pool(vout_display_t *vd, unsigned count)
+{
+    vout_display_sys_t * const sys = vd->sys;
+
+    msg_Dbg(vd, "%s: fmt:%dx%d,sar:%d/%d; source:%dx%d, count=%d", __func__,
+            vd->fmt.i_width, vd->fmt.i_height, vd->fmt.i_sar_num, vd->fmt.i_sar_den,
+            vd->source.i_width, vd->source.i_height, count);
+
+    if (sys->vlc_pic_pool != NULL) {
+        msg_Dbg(vd, "Pool exists");
+        return sys->vlc_pic_pool;
+    }
+
+    if (sys->pool_try_fb && drmu_format_vlc_to_drm_prime(&vd->fmt, NULL) == 0) {
+        if ((sys->vlc_pic_pool = make_fb_pool(vd, sys, count)) != NULL) {
+            msg_Dbg(vd, "Pool allocated using dmabufs");
+            return sys->vlc_pic_pool;
+        }
+        msg_Warn(vd, "Pool failed dmabuf allocation");
+    }
+
+    msg_Dbg(vd, "Pool allocation from main memory");
+    sys->vlc_pic_pool = picture_pool_NewFromFormat(&vd->fmt, count);
+    return sys->vlc_pic_pool;
+}
+
+static const drmu_vlc_fmt_info_t *
+find_fmt_fallback(const vout_display_t * const vd, const vout_display_sys_t * const sys, const vlc_fourcc_t * fallback)
+{
+    VLC_UNUSED(vd);
+
+    for (; *fallback; ++fallback) {
+        const video_frame_format_t vf = {.i_chroma = *fallback};
+        const drmu_vlc_fmt_info_t * fi;
+
+        for (fi = drmu_vlc_fmt_info_find_vlc(&vf);
+             fi != NULL;
+             fi = drmu_vlc_fmt_info_find_vlc_next(&vf, fi))
+        {
+            if (drmu_plane_format_check(sys->dp, drmu_vlc_fmt_info_drm_pixelformat(fi), drmu_vlc_fmt_info_drm_modifier(fi)))
+                return fi;
+        }
+    }
+    return NULL;
+}
+
+
+// Adjust *fmtp to fix format for display (tweak chroma)
+static int
+set_format(const vout_display_t * const vd, vout_display_sys_t * const sys, video_format_t *const fmtp)
+{
+    const drmu_vlc_fmt_info_t * fi = drmu_vlc_fmt_info_find_vlc(fmtp);
+    const uint64_t drm_mod = drmu_vlc_fmt_info_drm_modifier(fi);
+    const uint32_t drm_fmt = drmu_vlc_fmt_info_drm_pixelformat(fi);
+
+    msg_Dbg(vd, "%s: %s -> %s (%#"PRIx64"): prime: %d", __func__,
+            drmu_log_fourcc(fmtp->i_chroma), drmu_log_fourcc(drm_fmt), drm_mod,
+            drmu_vlc_fmt_info_is_drmprime(fi));
+
+#if HAS_ZC_CMA
+    if (fmtp->i_chroma == VLC_CODEC_MMAL_OPAQUE) {
+        // Can't deal directly with opaque - but we can always convert it to ZC I420
+        fmtp->i_chroma = VLC_CODEC_MMAL_ZC_I420;
+    }
+    else
+#endif
+    if (drmu_plane_format_check(sys->dp, drm_fmt, drm_mod)) {
+        // DRMP or it is a format where simple byte copying works
+    }
+    else {
+        const vlc_fourcc_t *fallback = vlc_fourcc_IsYUV(fmtp->i_chroma) ?
+            vlc_fourcc_GetYUVFallback(fmtp->i_chroma) :
+            vlc_fourcc_GetRGBFallback(fmtp->i_chroma);
+        static const vlc_fourcc_t fallback2[] = {
+            VLC_CODEC_I420,
+            VLC_CODEC_RGB32,
+            0
+        };
+
+        if ((fi = find_fmt_fallback(vd, sys, fallback)) == NULL &&
+            (fi = find_fmt_fallback(vd, sys, fallback2)) == NULL)
+            return VLC_EGENERIC;
+
+        fmtp->i_chroma = drmu_vlc_fmt_info_vlc_chroma(fi);
+        drmu_vlc_fmt_info_vlc_rgb_masks(fi, &fmtp->i_rmask, &fmtp->i_gmask, &fmtp->i_bmask);
+
+        msg_Dbg(vd, "%s: Fallback %s/%x/%x/%x -> %s %"PRIx64, __func__,
+                drmu_log_fourcc(fmtp->i_chroma),
+                fmtp->i_rmask, fmtp->i_gmask, fmtp->i_bmask,
+                drmu_log_fourcc(drmu_vlc_fmt_info_drm_pixelformat(fi)),
+                drmu_vlc_fmt_info_drm_modifier(fi));
+    }
+    return 0;
+}
+
+static void
+set_simple_format_size(video_format_t * const dst_fmt, const video_format_t * const src_fmt, const drmu_rect_t dst_rect)
+{
+#if 0
+    // Create a full pic with a centre cropping region
+    const drmu_rect_t fmt_crop = drmu_rect_vlc_format_crop(src_fmt);
+    const drmu_rect_t src_rect = drmu_rect_resize(drmu_rect_wh(src_fmt->i_width, src_fmt->i_height), dst_rect, fmt_crop);
+    const drmu_rect_t crop_rect = drmu_rect_resize(fmt_crop, dst_rect, fmt_crop);
+
+    dst_fmt->i_width = src_rect.w;
+    dst_fmt->i_height = src_rect.h;
+    dst_fmt->i_visible_width = crop_rect.w;
+    dst_fmt->i_visible_height = crop_rect.h;
+    dst_fmt->i_x_offset = crop_rect.x;
+    dst_fmt->i_y_offset = crop_rect.y;
+#else
+    // Just give us the cropped bit
+    VLC_UNUSED(src_fmt);
+    dst_fmt->i_width = dst_rect.w;
+    dst_fmt->i_height = dst_rect.h;
+    dst_fmt->i_visible_width = dst_rect.w;
+    dst_fmt->i_visible_height = dst_rect.h;
+    dst_fmt->i_x_offset = 0;
+    dst_fmt->i_y_offset = 0;
+#endif
+}
+
+// Updates sys but shouldn't touch vd
+// Sets fmt
+static int
+reconfigure_display(const vout_display_t * const vd, vout_display_sys_t * const sys,
+                    const vout_display_cfg_t * const cfg, video_format_t * const fmt)
+{
+    int ret;
+    *fmt = vd->source;
+    if ((ret = set_format(vd, sys, fmt)) != 0)
+        return ret;
+    configure_display(vd, sys, cfg, fmt);
+    if (sys->output_simple)
+        set_simple_format_size(fmt, &vd->source, drmu_rect_vlc_place(&sys->dest_rect));
+    return 0;
+}
+
+static int vd_drm_control(vout_display_t *vd, int query, va_list args)
+{
+    vout_display_sys_t * const sys = vd->sys;
+    video_format_t fmt;
+    int ret = VLC_EGENERIC;
+#if TRACE_ALL
+    msg_Dbg(vd, "<<< %s: query=%d", __func__, query);
+#endif
+
+    switch (query) {
+        case VOUT_DISPLAY_CHANGE_SOURCE_ASPECT:
+        case VOUT_DISPLAY_CHANGE_SOURCE_CROP:
+            if ((ret = reconfigure_display(vd, sys, NULL, &fmt)) != 0)
+                break;
+            if (!video_format_IsSimilar(&vd->fmt, &fmt)) {
+                if (vd->info.has_pictures_invalid)
+                    vout_display_SendEventPicturesInvalid(vd);
+                else
+                    msg_Err(vd, "Wanted Pic Invalid but not allowed");
+            }
+            break;
+
+        case VOUT_DISPLAY_CHANGE_ZOOM:
+        case VOUT_DISPLAY_CHANGE_DISPLAY_SIZE:
+        case VOUT_DISPLAY_CHANGE_DISPLAY_FILLED:
+            if ((ret = reconfigure_display(vd, sys, va_arg(args, const vout_display_cfg_t *), &fmt)) != 0)
+                break;
+            if (!video_format_IsSimilar(&vd->fmt, &fmt)) {
+                if (vd->info.has_pictures_invalid)
+                    vout_display_SendEventPicturesInvalid(vd);
+                else
+                    msg_Err(vd, "Wanted Pic Invalid but not allowed");
+            }
+            break;
+
+        case VOUT_DISPLAY_RESET_PICTURES:
+            kill_pool(sys);
+
+            if ((ret = reconfigure_display(vd, sys, NULL, &fmt)) != 0)
+                break;
+            vd->fmt = fmt;
+            break;
+
+        default:
+            msg_Warn(vd, "Unknown control query %d", query);
+            break;
+    }
+
+    return ret;
+}
+
+static void CloseDrmVout(vout_display_t *vd)
+{
+    vout_display_sys_t *const sys = vd->sys;
+    unsigned int i;
+
+    msg_Dbg(vd, "<<< %s", __func__);
+
+    if (sys->wde != NULL)
+        wb_display_done_cb(sys->wde, NULL);
+    drmu_fb_unref(&sys->wb_fb);
+
+    drmu_writeback_fb_unref(&sys->pic_wbq);
+    drmu_writeback_env_finish(&sys->wbe);
+
+    drmu_pool_kill(&sys->sub_fb_pool);
+    drmu_pool_kill(&sys->pic_pool);
+
+    for (i = 0; i != SUBPICS_MAX; ++i)
+        drmu_plane_unref(sys->subplanes + i);
+
+    kill_pool(sys);
+
+    drmu_plane_unref(&sys->dp);
+    drmu_output_unref(&sys->dout);
+    drmu_env_kill(&sys->du);
+
+    free(sys->subpic_chromas);
+    vd->info.subpicture_chromas = NULL;
+
+    vd->sys = NULL;
+    free(sys);
+#if TRACE_ALL
+    msg_Dbg(vd, ">>> %s", __func__);
+#endif
+}
+
+// VLC will take a list of subpic formats but it then ignores the fact it is a
+// list and picks the 1st one whether it is 'best' or indeed whether or not it
+// can use it.  So we have to sort ourselves & have checked usablity.
+// Higher number, higher priority. 0 == Do not use.
+static int subpic_fourcc_usability(const vlc_fourcc_t fcc)
+{
+    switch (fcc) {
+        case VLC_CODEC_ARGB:
+            return 20;
+        case VLC_CODEC_RGBA:
+            return 22;
+        case VLC_CODEC_BGRA:
+            return 21;
+        case VLC_CODEC_YUVA:
+            return 40;
+        default:
+            break;
+    }
+    return 0;
+}
+
+// Sort in descending priority number
+static int subpic_fourcc_sort_cb(const void * a, const void * b)
+{
+    return subpic_fourcc_usability(*(vlc_fourcc_t *)b) - subpic_fourcc_usability(*(vlc_fourcc_t *)a);
+}
+
+static vlc_fourcc_t *
+subpic_make_chromas_from_drm(const uint32_t * const drm_chromas, const unsigned int n)
+{
+    vlc_fourcc_t * const c = (n == 0) ? NULL : calloc(n + 1, sizeof(*c));
+    vlc_fourcc_t * p = c;
+
+    if (c == NULL)
+        return NULL;
+
+    for (unsigned int j = 0; j != n; ++j) {
+        if ((*p = drmu_vlc_fmt_info_vlc_chroma(drmu_vlc_fmt_info_find_drm(drm_chromas[j], 0))) != 0)
+            ++p;
+    }
+
+    // Sort for our preferred order & remove any that would confuse VLC
+    qsort(c, p - c, sizeof(*c), subpic_fourcc_sort_cb);
+    while (p != c) {
+        if (subpic_fourcc_usability(p[-1]) != 0)
+            break;
+        *--p = 0;
+    }
+
+    if (p == c) {
+        free(c);
+        return NULL;
+    }
+
+    return c;
+}
+
+static int
+test_simple_plane_set(vout_display_t * const vd, vout_display_sys_t * const sys,
+                      const video_format_t * const fmt,
+                      unsigned int w, unsigned int h,
+                      const drmu_rect_t dst_rect)
+{
+    drmu_atomic_t *da = drmu_atomic_new(sys->du);
+    drmu_fb_t *fb;
+    int rv = -ENOMEM;
+    const drmu_vlc_fmt_info_t * const fi = drmu_vlc_fmt_info_find_vlc(fmt);
+
+    if (fi == NULL) {
+        msg_Err(vd, "Can't find chroma format");
+        goto fail;
+    }
+
+    if (da == NULL) {
+        msg_Warn(vd, "Failed to alloc test atomic");
+        goto fail;
+    }
+
+    if ((fb = drmu_pool_fb_new(sys->sub_fb_pool, w, h,
+                               drmu_vlc_fmt_info_drm_pixelformat(fi),
+                               drmu_vlc_fmt_info_drm_modifier(fi))) == NULL) {
+        msg_Warn(vd, "Failed to alloc test FB");
+        goto fail;
+    }
+
+    if ((rv = drmu_atomic_plane_add_fb(da, sys->dp, fb, dst_rect)) != 0) {
+        msg_Warn(vd, "Failed to add test FB to atomic");
+        goto fail;
+    }
+
+    if ((rv = drmu_atomic_commit(da, DRM_MODE_ATOMIC_TEST_ONLY)) != 0) {
+        msg_Warn(vd, "Failed to commit test FB");
+        goto fail;
+    }
+
+fail:
+    drmu_atomic_unref(&da);
+    drmu_fb_unref(&fb);
+    return rv;
+}
+
+static int OpenDrmVout(vlc_object_t *object)
+{
+    vout_display_t * const vd = (vout_display_t *)object;
+//    video_format_t * const fmtp = &vd->fmt;
+    video_format_t out_fmt = vd->source;
+    const video_format_t *const src_fmt = &vd->source;
+    const uint32_t src_chroma = src_fmt->i_chroma;
+    vout_display_sys_t *sys;
+    char * display_name = NULL;
+    int ret = VLC_EGENERIC;
+    int rv;
+
+    msg_Info(vd, "<<< %s: %s %dx%d(%dx%d @ %d,%d %d/%d) or %d, cfg.display: %dx%d, source: %dx%d(%dx%d @ %d,%d %d/%d) or %d", __func__,
+             drmu_log_fourcc(vd->fmt.i_chroma), vd->fmt.i_width, vd->fmt.i_height,
+             vd->fmt.i_visible_width, vd->fmt.i_visible_height, vd->fmt.i_x_offset, vd->fmt.i_y_offset,
+             vd->fmt.i_sar_num, vd->fmt.i_sar_den, vd->fmt.orientation,
+             vd->cfg->display.width, vd->cfg->display.height,
+             vd->source.i_width, vd->source.i_height,
+             vd->source.i_visible_width, vd->source.i_visible_height, vd->source.i_x_offset, vd->source.i_y_offset,
+             vd->source.i_sar_num, vd->source.i_sar_den, vd->source.orientation);
+
+//    if (!var_InheritBool(vd, "fullscreen")) {
+//        msg_Dbg(vd, ">>> %s: Not fullscreen", __func__);
+//        return ret;
+//    }
+
+    sys = calloc(1, sizeof(*sys));
+    if (!sys)
+        return VLC_ENOMEM;
+    vd->sys = sys;
+
+    sys->mode_id = -1;
+
+    display_name = var_InheritString(vd, DRM_VOUT_DISPLAY_NAME);
+
+    {
+        int qt_num = var_InheritInteger(vd, "qt-fullscreen-screennumber");
+        const char * conn_name = qt_num == 0 ? "HDMI-A-1" :  qt_num == 1 ? "HDMI-A-2" : NULL;
+        const char * dname;
+        const drmu_log_env_t log = {
+            .fn = drmu_log_vlc_cb,
+            .v = vd,
+            .max_level = DRMU_LOG_LEVEL_ALL
+        };
+
+        if (display_name && strcasecmp(display_name, "auto") != 0) {
+            if (strcasecmp(display_name, "hdmi-1") == 0)
+                conn_name = "HDMI-A-1";
+            else if (strcasecmp(display_name, "hdmi-2") == 0)
+                conn_name = "HDMI-A-2";
+            else
+                conn_name = display_name;
+        }
+
+        dname = conn_name != NULL ? conn_name : "<auto>";
+
+        sys->du = drmu_env_new_xlease(&log);
+
+        if (sys->du == NULL) {
+            if (drmu_scan_output(conn_name, &log, &sys->du, &sys->dout) == 0)
+                msg_Dbg(vd, "Using conn %s", dname);
+        }
+
+        if (sys->du == NULL) {
+            char * module_name = var_InheritString(vd, DRM_VOUT_MODULE_NAME);
+            if (module_name != NULL) {
+                sys->du = drmu_env_new_open(module_name, &log);
+                free(module_name);
+                if (sys->du == NULL)
+                    goto fail;
+            }
+        }
+
+        if (sys->dout == NULL) {
+            if ((sys->dout = drmu_output_new(sys->du)) == NULL) {
+                msg_Err(vd, "Failed to allocate new drmu output");
+                goto fail;
+            }
+
+            if ((rv = drmu_output_add_output(sys->dout, conn_name)) != 0)
+                msg_Err(vd, "Failed to find output %s: %s", dname, strerror(-rv));
+            else
+                msg_Dbg(vd, "Using conn %s", dname);
+
+            if (rv != 0)
+                goto fail;
+        }
+    }
+
+    drmu_env_restore_enable(sys->du);
+
+    drmu_output_modeset_allow(sys->dout, !var_InheritBool(vd, DRM_VOUT_NO_MODESET_NAME));
+    drmu_output_max_bpc_allow(sys->dout, !var_InheritBool(vd, DRM_VOUT_NO_MAX_BPC));
+
+    // Get frame buffer pools - try generic dmabufs first for cached
+    // buffers that are faster than uncached BOs
+    if ((sys->sub_fb_pool = drmu_pool_new_dmabuf_video(sys->du, 10)) == NULL &&
+        (sys->sub_fb_pool = drmu_pool_new_dumb(sys->du, 10)) == NULL)
+        goto fail;
+    if ((sys->pic_pool = drmu_pool_new_dmabuf_video(sys->du, 40)) == NULL &&
+        (sys->pic_pool = drmu_pool_new_dumb(sys->du, 40)) == NULL)
+        goto fail;
+
+    // This wants to be the primary
+    if ((sys->dp = drmu_output_plane_ref_primary(sys->dout)) == NULL)
+        goto fail;
+
+    for (unsigned int i = 0; i != SUBPICS_MAX; ++i) {
+        if ((sys->subplanes[i] = drmu_output_plane_ref_other(sys->dout)) == NULL) {
+            msg_Warn(vd, "Cannot allocate subplane %d", i);
+            break;
+        }
+        if (sys->subpic_chromas == NULL) {
+            unsigned int n;
+            const uint32_t * const drm_chromas = drmu_plane_formats(sys->subplanes[i], &n);
+            sys->subpic_chromas = subpic_make_chromas_from_drm(drm_chromas, n);
+        }
+    }
+
+    if (set_format(vd, sys, &out_fmt)) {
+        msg_Warn(vd, "Failed to find compatible output format");
+        goto fail;
+    }
+
+    sys->mode_id = -1;
+
+    char * mode_name = NULL;
+    const char * modestr;
+
+    if (var_InheritBool(vd, DRM_VOUT_SOURCE_MODESET_NAME))
+        modestr = "source";
+    else {
+        mode_name = var_InheritString(vd, DRM_VOUT_MODE_NAME);
+        modestr = mode_name;
+    }
+
+    if (modestr != NULL && strcmp(modestr, "none") != 0) {
+        drmu_mode_simple_params_t pick = {
+            .width = src_fmt->i_visible_width,
+            .height = src_fmt->i_visible_height,
+            .hz_x_1000 = src_fmt->i_frame_rate_base == 0 ? 0 :
+                (unsigned int)(((uint64_t)src_fmt->i_frame_rate * 1000) / src_fmt->i_frame_rate_base),
+        };
+
+        if (strcmp(modestr, "source") != 0) {
+            unsigned int w, h, hz;
+            if (*drmu_util_parse_mode(modestr, &w, &h, &hz) != 0) {
+                msg_Err(vd, "Bad mode string: '%s'", modestr);
+                free(mode_name);
+                ret = VLC_EGENERIC;
+                goto fail;
+            }
+            if (w && h) {
+                pick.width = w;
+                pick.height = h;
+            }
+            if (hz)
+                pick.hz_x_1000 = hz;
+        }
+
+        sys->mode_id = drmu_output_mode_pick_simple(sys->dout, drmu_mode_pick_simple_cb, &pick);
+
+        msg_Dbg(vd, "Mode id=%d", sys->mode_id);
+
+        // This will set the mode on the crtc var but won't actually change the output
+        if (sys->mode_id >= 0) {
+            const drmu_mode_simple_params_t * mode;
+
+            drmu_output_mode_id_set(sys->dout, sys->mode_id);
+            mode = drmu_output_mode_simple_params(sys->dout);
+                msg_Info(vd, "Mode %d: %dx%d@%d.%03d %d/%d - req %dx%d@%d.%d", sys->mode_id,
+                        mode->width, mode->height, mode->hz_x_1000 / 1000, mode->hz_x_1000 % 1000,
+                        mode->sar.num, mode->sar.den, pick.width, pick.height, pick.hz_x_1000 / 1000, pick.hz_x_1000 % 1000);
+        }
+    }
+    free(mode_name);
+
+    {
+        char * const window_str = var_InheritString(vd, DRM_VOUT_WINDOW_NAME);
+        if (strcmp(window_str, "fullscreen") == 0) {
+            /* Leave req_win null */
+            msg_Dbg(vd, "Window: fullscreen");
+        }
+        else {
+            sys->req_win = str_to_rect(window_str);
+            if (sys->req_win.width != 0)
+                msg_Dbg(vd, "Window: %dx%d @ %d,%d",
+                        sys->req_win.width, sys->req_win.height,
+                        sys->req_win.x, sys->req_win.y);
+            else
+                msg_Warn(vd, "Window: '%s': cannot parse (usage: <w>x<h>+<x>+<y>) - using fullscreen", window_str);
+        }
+        free(window_str);
+    }
+
+    if (src_chroma != out_fmt.i_chroma)
+        msg_Warn(vd, "Cannot display %s directly trying %s", drmu_log_fourcc(src_chroma), drmu_log_fourcc(out_fmt.i_chroma));
+
+    set_display_windows(vd, sys);
+
+    {
+        const unsigned int w = sys->display_rect.width;
+        const unsigned int h = sys->display_rect.height;
+        const drmu_rect_t sr = {.x = w / 5, .y = h / 5, .w = w / 3, .h = h / 3};
+        if (test_simple_plane_set(vd, sys, &out_fmt, w, h, drmu_rect_wh(w, h)) != 0) {
+            msg_Warn(vd, "Failed simple pic test for mode %dx%d", w, h);
+            goto fail;
+        }
+        else {
+            msg_Dbg(vd, "OK simple pic test for mode %dx%d", w, h);
+        }
+
+        // Test for full scale & position capability - the incoming stream
+        // might not need it but if anything changes it is better to be sure we
+        // can cope with it
+        if (test_simple_plane_set(vd, sys, &out_fmt, vd->source.i_visible_width, vd->source.i_visible_height, sr) != 0) {
+            msg_Warn(vd, "Failed scale pic test for %dx%d->%dx%d", vd->source.i_visible_width, vd->source.i_visible_height, sr.w, sr.h);
+            sys->output_simple = true;
+        }
+        else {
+            msg_Dbg(vd, "OK source pic test for %dx%d->%dx%d", vd->source.i_visible_width, vd->source.i_visible_height, sr.w, sr.h);
+        }
+    }
+
+    configure_display(vd, sys, vd->cfg, &vd->source);
+
+    if (sys->output_simple)
+        set_simple_format_size(&out_fmt, src_fmt, drmu_rect_vlc_place(&sys->dest_rect));
+
+    // Simple does not work usefully with dmabuf input
+    sys->pool_try_fb = !sys->output_simple && var_InheritBool(vd, DRM_VOUT_POOL_DMABUF_NAME);
+
+    // All setup done - no possibility of error from here on
+    // Do final config setup & cleanup
+
+    free(display_name);
+
+    vd->fmt = out_fmt;
+
+    vd->info = (vout_display_info_t){
+        .is_slow = false,
+        .has_double_click = false,
+        .needs_hide_mouse = false,
+        .has_pictures_invalid = sys->output_simple,
+        .subpicture_chromas = sys->subpic_chromas
+    };
+
+    vd->pool = vd_drm_pool;
+    vd->prepare = vd_drm_prepare;
+    vd->display = vd_drm_display;
+    vd->control = vd_drm_control;
+
+    {
+        const drmu_mode_simple_params_t * const mode = drmu_output_mode_simple_params(sys->dout);
+        if (vd->cfg->display.width != mode->width || vd->cfg->display.height != mode->height) {
+            msg_Dbg(vd, "Set display size to %ux%u", mode->width, mode->height);
+            vout_display_SendEventDisplaySize(vd, mode->width, mode->height);
+        }
+    }
+
+    msg_Dbg(vd, ">>> %s", __func__);
+    return VLC_SUCCESS;
+
+fail:
+    CloseDrmVout(vd);
+    free(display_name);
+    return ret;
+}
+
+vlc_module_begin()
+    set_shortname(N_("DRM vout"))
+    set_description(N_("DRM vout plugin"))
+    set_capability("vout display", 32)  // 2 points better than fb(30), ascii(15)
+    add_shortcut("drm-vout")
+    set_category(CAT_VIDEO)
+    set_subcategory(SUBCAT_VIDEO_VOUT)
+
+    add_bool(DRM_VOUT_SOURCE_MODESET_NAME, false, DRM_VOUT_SOURCE_MODESET_TEXT, DRM_VOUT_SOURCE_MODESET_LONGTEXT, false)
+    add_bool(DRM_VOUT_NO_MODESET_NAME,     false, DRM_VOUT_NO_MODESET_TEXT, DRM_VOUT_NO_MODESET_LONGTEXT, false)
+    add_bool(DRM_VOUT_NO_MAX_BPC,          false, DRM_VOUT_NO_MAX_BPC_TEXT, DRM_VOUT_NO_MAX_BPC_LONGTEXT, false)
+    add_bool(DRM_VOUT_POOL_DMABUF_NAME,    false, DRM_VOUT_POOL_DMABUF_TEXT, DRM_VOUT_POOL_DMABUF_LONGTEXT, false)
+    add_string(DRM_VOUT_MODE_NAME,         "none", DRM_VOUT_MODE_TEXT, DRM_VOUT_MODE_LONGTEXT, false)
+    add_string(DRM_VOUT_WINDOW_NAME,       "fullscreen", DRM_VOUT_WINDOW_TEXT, DRM_VOUT_WINDOW_LONGTEXT, false)
+    add_string(DRM_VOUT_DISPLAY_NAME,      "auto", DRM_VOUT_DISPLAY_TEXT, DRM_VOUT_DISPLAY_LONGTEXT, false)
+    add_string(DRM_VOUT_MODULE_NAME,       DRM_MODULE, DRM_VOUT_MODULE_TEXT, DRM_VOUT_MODULE_LONGTEXT, false)
+
+    set_callbacks(OpenDrmVout, CloseDrmVout)
+vlc_module_end()
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu.c
@@ -0,0 +1,3922 @@
+// Needed to ensure we get a 64-bit offset to mmap when mapping BOs
+#undef _FILE_OFFSET_BITS
+#define _FILE_OFFSET_BITS 64
+
+#include "drmu.h"
+#include "drmu_fmts.h"
+#include "drmu_log.h"
+
+#include <pthread.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <poll.h>
+#include <stdatomic.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+
+#include <libdrm/drm.h>
+#include <libdrm/drm_mode.h>
+#include <libdrm/drm_fourcc.h>
+#include <xf86drm.h>
+
+#include <linux/dma-buf.h>
+
+#define TRACE_PROP_NEW 0
+
+#ifndef OPT_IO_CALLOC
+#define OPT_IO_CALLOC 0
+#endif
+
+#ifndef DRM_FORMAT_P030
+#define DRM_FORMAT_P030 fourcc_code('P', '0', '3', '0')
+#endif
+
+struct drmu_bo_env_s;
+static struct drmu_bo_env_s * env_boe(drmu_env_t * const du);
+static int env_object_state_save(drmu_env_t * const du, const uint32_t obj_id, const uint32_t obj_type);
+
+// Update return value with a new one for cases where we don't stop on error
+static inline int rvup(int rv1, int rv2)
+{
+    return rv2 ? rv2 : rv1;
+}
+
+// Use io_alloc when allocating arrays to pass into ioctls.
+//
+// When debugging with valgrind use calloc rather than malloc otherwise arrays
+// set by ioctls that valgrind doesn't know about (e.g. all drm ioctls) will
+// still be full of 'undefined'.
+// For normal use malloc should be fine
+#if OPT_IO_CALLOC
+#define io_alloc(p, n) (uintptr_t)((p) = calloc((n), sizeof(*(p))))
+#else
+#define io_alloc(p, n) (uintptr_t)((p) = malloc((n) * sizeof(*(p))))
+#endif
+
+// Alloc retry helper
+static inline int
+retry_alloc_u32(uint32_t ** const pp, uint32_t * const palloc_count, uint32_t const new_count)
+{
+    if (new_count <= *palloc_count)
+        return 0;
+    free(*pp);
+    *palloc_count = 0;
+    if (io_alloc(*pp, new_count) == 0)
+        return -ENOMEM;
+    *palloc_count = new_count;
+    return 1;
+}
+
+//----------------------------------------------------------------------------
+//
+// propinfo
+
+typedef struct drmu_propinfo_s {
+    uint64_t val;
+    struct drm_mode_get_property prop;
+} drmu_propinfo_t;
+
+static uint64_t
+propinfo_val(const drmu_propinfo_t * const pi)
+{
+    return pi == NULL ? 0 : pi->val;
+}
+
+static uint32_t
+propinfo_prop_id(const drmu_propinfo_t * const pi)
+{
+    return pi == NULL ? 0 : pi->prop.prop_id;
+}
+
+
+//----------------------------------------------------------------------------
+//
+// Blob fns
+
+typedef struct drmu_blob_s {
+    atomic_int ref_count;  // 0 == 1 ref for ease of init
+    struct drmu_env_s * du;
+    uint32_t blob_id;
+    // Copy of blob data as we nearly always want to keep a copy to compare
+    size_t len;
+    void * data;
+} drmu_blob_t;
+
+static void
+blob_free(drmu_blob_t * const blob)
+{
+    drmu_env_t * const du = blob->du;
+
+    if (blob->blob_id != 0) {
+        struct drm_mode_destroy_blob dblob = {
+            .blob_id = blob->blob_id
+        };
+        if (drmu_ioctl(du, DRM_IOCTL_MODE_DESTROYPROPBLOB, &dblob) != 0)
+            drmu_err(du, "%s: Failed to destroy blob: %s", __func__, strerror(errno));
+    }
+    free(blob->data);
+    free(blob);
+}
+
+void
+drmu_blob_unref(drmu_blob_t ** const ppBlob)
+{
+    drmu_blob_t * const blob = *ppBlob;
+
+    if (blob == NULL)
+        return;
+    *ppBlob = NULL;
+
+    if (atomic_fetch_sub(&blob->ref_count, 1) != 0)
+        return;
+
+    blob_free(blob);
+}
+
+uint32_t
+drmu_blob_id(const drmu_blob_t * const blob)
+{
+    return blob == NULL ? 0 : blob->blob_id;
+}
+
+drmu_blob_t *
+drmu_blob_ref(drmu_blob_t * const blob)
+{
+    if (blob != NULL)
+        atomic_fetch_add(&blob->ref_count, 1);
+    return blob;
+}
+
+const void *
+drmu_blob_data(const drmu_blob_t * const blob)
+{
+    return blob->data;
+}
+
+size_t
+drmu_blob_len(const drmu_blob_t * const blob)
+{
+    return blob->len;
+}
+
+drmu_blob_t *
+drmu_blob_new(drmu_env_t * const du, const void * const data, const size_t len)
+{
+    int rv;
+    drmu_blob_t * blob = calloc(1, sizeof(*blob));
+    struct drm_mode_create_blob cblob = {
+        .data = (uintptr_t)data,
+        .length = (uint32_t)len,
+        .blob_id = 0
+    };
+
+    if (blob == NULL) {
+        drmu_err(du, "%s: Unable to alloc blob", __func__);
+        return NULL;
+    }
+    blob->du = du;
+
+    if ((blob->data = malloc(len)) == NULL) {
+        drmu_err(du, "%s: Unable to alloc blob data", __func__);
+        goto fail;
+    }
+    blob->len = len;
+    memcpy(blob->data, data, len);
+
+    if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_CREATEPROPBLOB, &cblob)) != 0) {
+        drmu_err(du, "%s: Unable to create blob: data=%p, len=%zu: %s", __func__,
+                 data, len, strerror(-rv));
+        goto fail;
+    }
+
+    atomic_init(&blob->ref_count, 0);
+    blob->blob_id = cblob.blob_id;
+    return blob;
+
+fail:
+    blob_free(blob);
+    return NULL;
+}
+
+int
+drmu_blob_update(drmu_env_t * const du, drmu_blob_t ** const ppblob, const void * const data, const size_t len)
+{
+    drmu_blob_t * blob = *ppblob;
+
+    if (data == NULL || len == 0) {
+        drmu_blob_unref(ppblob);
+        return 0;
+    }
+
+    if (blob && len == blob->len && memcmp(data, blob->data, len) == 0)
+        return 0;
+
+    if ((blob = drmu_blob_new(du, data, len)) == NULL)
+        return -ENOMEM;
+    drmu_blob_unref(ppblob);
+    *ppblob = blob;
+    return 0;
+}
+
+// Data alloced here needs freeing later
+static int
+blob_data_read(drmu_env_t * const du, uint32_t blob_id, void ** const ppdata, size_t * plen)
+{
+    uint8_t * data;
+    struct drm_mode_get_blob gblob = {.blob_id = blob_id};
+    int rv;
+
+    *ppdata = NULL;
+    *plen = 0;
+
+    if (blob_id == 0)
+        return 0;
+
+    if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_GETPROPBLOB, &gblob)) != 0)
+        return rv;
+
+    if (gblob.length == 0)
+        return 0;
+
+    if ((gblob.data = io_alloc(data, gblob.length)) == 0)
+        return -ENOMEM;
+
+    if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_GETPROPBLOB, &gblob)) != 0) {
+        free(data);
+        return rv;
+    }
+
+    *ppdata = data;
+    *plen = gblob.length;
+    return 0;
+}
+
+// Copy existing blob into a new one
+// Useful when saving preexisiting values
+drmu_blob_t *
+drmu_blob_copy_id(drmu_env_t * const du, uint32_t blob_id)
+{
+    void * data;
+    size_t len;
+    drmu_blob_t * blob = NULL;
+
+    if (blob_data_read(du, blob_id, &data, &len) == 0)
+        blob = drmu_blob_new(du, data, len);  // * This copies data - could just get it to take the malloc
+
+    free(data);
+    return blob;
+}
+
+static void
+atomic_prop_blob_unref(void * v)
+{
+    drmu_blob_t * blob = v;
+    drmu_blob_unref(&blob);
+}
+
+static void
+atomic_prop_blob_ref(void * v)
+{
+    drmu_blob_ref(v);
+}
+
+int
+drmu_atomic_add_prop_blob(drmu_atomic_t * const da, const uint32_t obj_id, const uint32_t prop_id, drmu_blob_t * const blob)
+{
+    int rv;
+    static const drmu_atomic_prop_fns_t fns = {
+        .ref = atomic_prop_blob_ref,
+        .unref = atomic_prop_blob_unref,
+        .commit = drmu_prop_fn_null_commit
+    };
+
+    if (blob == NULL)
+        return drmu_atomic_add_prop_value(da, obj_id, prop_id, 0);
+
+    rv = drmu_atomic_add_prop_generic(da, obj_id, prop_id, drmu_blob_id(blob), &fns, blob);
+    if (rv != 0)
+        drmu_warn(drmu_atomic_env(da), "%s: Failed to add blob obj_id=%#x, prop_id=%#x: %s", __func__, obj_id, prop_id, strerror(-rv));
+
+    return rv;
+}
+
+//----------------------------------------------------------------------------
+//
+// Enum fns
+
+typedef struct drmu_prop_enum_s {
+    uint32_t id;
+    uint32_t flags;
+    unsigned int n;
+    const struct drm_mode_property_enum * enums;
+    char name[DRM_PROP_NAME_LEN];
+} drmu_prop_enum_t;
+
+static void
+prop_enum_free(drmu_prop_enum_t * const pen)
+{
+    free((void*)pen->enums);  // Cast away const
+    free(pen);
+}
+
+static int
+prop_enum_qsort_cb(const void * va, const void * vb)
+{
+    const struct drm_mode_property_enum * a = va;
+    const struct drm_mode_property_enum * b = vb;
+    return strcmp(a->name, b->name);
+}
+
+// NULL if not found
+const uint64_t *
+drmu_prop_enum_value(const drmu_prop_enum_t * const pen, const char * const name)
+{
+    if (pen != NULL && name != NULL) {
+        unsigned int i = pen->n / 2;
+        unsigned int a = 0;
+        unsigned int b = pen->n;
+
+        if (name == NULL)
+            return NULL;
+
+        while (a < b) {
+            const int r = strcmp(name, pen->enums[i].name);
+
+            if (r == 0)
+                return (const uint64_t *)&pen->enums[i].value;  // __u64 defn != uint64_t defn always :-(
+
+            if (r < 0) {
+                b = i;
+                i = (i + a) / 2;
+            } else {
+                a = i + 1;
+                i = (i + b) / 2;
+            }
+        }
+    }
+    return NULL;
+}
+
+uint64_t
+drmu_prop_bitmask_value(const drmu_prop_enum_t * const pen, const char * const name)
+{
+    const uint64_t *const p = drmu_prop_enum_value(pen, name);
+    return p == NULL || *p >= 64 || (pen->flags & DRM_MODE_PROP_BITMASK) == 0 ?
+        (uint64_t)0 : (uint64_t)1 << *p;
+}
+
+uint32_t
+drmu_prop_enum_id(const drmu_prop_enum_t * const pen)
+{
+    return pen == NULL ? 0 : pen->id;
+}
+
+void
+drmu_prop_enum_delete(drmu_prop_enum_t ** const pppen)
+{
+    drmu_prop_enum_t * const pen = *pppen;
+    if (pen == NULL)
+        return;
+    *pppen = NULL;
+
+    prop_enum_free(pen);
+}
+
+drmu_prop_enum_t *
+drmu_prop_enum_new(drmu_env_t * const du, const uint32_t id)
+{
+    drmu_prop_enum_t * pen;
+    struct drm_mode_property_enum * enums = NULL;
+    unsigned int retries;
+    int rv;
+
+    // If id 0 return without warning for ease of getting props on init
+    if (id == 0 || (pen = calloc(1, sizeof(*pen))) == NULL)
+        return NULL;
+    pen->id = id;
+
+    // Docn says we must loop till stable as there may be hotplug races
+    for (retries = 0; retries < 8; ++retries) {
+        struct drm_mode_get_property prop = {
+            .prop_id = id,
+            .count_enum_blobs = pen->n,
+            .enum_blob_ptr = (uintptr_t)enums
+        };
+
+        if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_GETPROPERTY, &prop)) != 0) {
+            drmu_err(du, "%s: get property failed: %s", __func__, strerror(-rv));
+            goto fail;
+        }
+
+        if (prop.count_enum_blobs == 0 ||
+            (prop.flags & (DRM_MODE_PROP_ENUM | DRM_MODE_PROP_BITMASK)) == 0) {
+            drmu_err(du, "%s: not an enum: flags=%#x, enums=%d", __func__, prop.flags, prop.count_enum_blobs);
+            goto fail;
+        }
+
+        if (pen->n >= prop.count_enum_blobs) {
+            pen->flags = prop.flags;
+            pen->n = prop.count_enum_blobs;
+            memcpy(pen->name, prop.name, sizeof(pen->name));
+            break;
+        }
+
+        free(enums);
+
+        pen->n = prop.count_enum_blobs;
+        if (io_alloc(enums, pen->n) == 0)
+            goto fail;
+    }
+    if (retries >= 8) {
+        drmu_err(du, "%s: Too many retries", __func__);
+        goto fail;
+    }
+
+    qsort(enums, pen->n, sizeof(*enums), prop_enum_qsort_cb);
+    pen->enums = enums;
+
+#if TRACE_PROP_NEW
+    if (!pen->n) {
+        drmu_info(du, "%32s %2d: no properties");
+    }
+    else {
+        unsigned int i;
+        for (i = 0; i != pen->n; ++i) {
+            drmu_info(du, "%32s %2d:%02d: %32s %#"PRIx64, pen->name, pen->id, i, pen->enums[i].name, pen->enums[i].value);
+        }
+    }
+#endif
+
+    return pen;
+
+fail:
+    free(enums);
+    prop_enum_free(pen);
+    return NULL;
+}
+
+int
+drmu_atomic_add_prop_enum(drmu_atomic_t * const da, const uint32_t obj_id, const drmu_prop_enum_t * const pen, const char * const name)
+{
+    const uint64_t * const pval = drmu_prop_enum_value(pen, name);
+    int rv;
+
+    rv = (pval == NULL) ? -EINVAL :
+        drmu_atomic_add_prop_generic(da, obj_id, drmu_prop_enum_id(pen), *pval, NULL, NULL);
+
+    if (rv != 0 && name != NULL)
+        drmu_warn(drmu_atomic_env(da), "%s: Failed to add enum obj_id=%#x, prop_id=%#x, name='%s': %s", __func__,
+                  obj_id, drmu_prop_enum_id(pen), name, strerror(-rv));
+
+    return rv;
+}
+
+int
+drmu_atomic_add_prop_bitmask(struct drmu_atomic_s * const da, const uint32_t obj_id, const drmu_prop_enum_t * const pen, const uint64_t val)
+{
+    int rv;
+
+    rv = !pen ? -ENOENT :
+        ((pen->flags & DRM_MODE_PROP_BITMASK) == 0) ? -EINVAL :
+            drmu_atomic_add_prop_generic(da, obj_id, drmu_prop_enum_id(pen), val, NULL, NULL);
+
+    if (rv != 0)
+        drmu_warn(drmu_atomic_env(da), "%s: Failed to add bitmask obj_id=%#x, prop_id=%#x, val=%#"PRIx64": %s", __func__,
+                  obj_id, drmu_prop_enum_id(pen), val, strerror(-rv));
+
+    return rv;
+}
+
+//----------------------------------------------------------------------------
+//
+// Range
+
+typedef struct drmu_prop_range_s {
+    uint32_t id;
+    uint32_t flags;
+    uint64_t range[2];
+    char name[DRM_PROP_NAME_LEN];
+} drmu_prop_range_t;
+
+static void
+prop_range_free(drmu_prop_range_t * const pra)
+{
+    free(pra);
+}
+
+void
+drmu_prop_range_delete(drmu_prop_range_t ** pppra)
+{
+    drmu_prop_range_t * const pra = *pppra;
+
+    if (pra == NULL)
+        return;
+    *pppra = NULL;
+
+    prop_range_free(pra);
+}
+
+bool
+drmu_prop_range_validate(const drmu_prop_range_t * const pra, const uint64_t x)
+{
+    if (pra == NULL)
+        return false;
+    if ((pra->flags & DRM_MODE_PROP_EXTENDED_TYPE) == DRM_MODE_PROP_SIGNED_RANGE) {
+        return (int64_t)pra->range[0] <= (int64_t)x && (int64_t)pra->range[1] >= (int64_t)x;
+    }
+    return pra->range[0] <= x && pra->range[1] >= x;
+}
+
+bool
+drmu_prop_range_immutable(const drmu_prop_range_t * const pra)
+{
+    return !pra || (pra->flags & DRM_MODE_PROP_IMMUTABLE) != 0;
+}
+
+uint64_t
+drmu_prop_range_max(const drmu_prop_range_t * const pra)
+{
+    return pra == NULL ? 0 : pra->range[1];
+}
+
+uint64_t
+drmu_prop_range_min(const drmu_prop_range_t * const pra)
+{
+    return pra == NULL ? 0 : pra->range[0];
+}
+
+uint32_t
+drmu_prop_range_id(const drmu_prop_range_t * const pra)
+{
+    return pra == NULL ? 0 : pra->id;
+}
+
+const char *
+drmu_prop_range_name(const drmu_prop_range_t * const pra)
+{
+    return pra == NULL ? "{norange}" : pra->name;
+}
+
+drmu_prop_range_t *
+drmu_prop_range_new(drmu_env_t * const du, const uint32_t id)
+{
+    drmu_prop_range_t * pra;
+    int rv;
+
+    // If id 0 return without warning for ease of getting props on init
+    if (id == 0 || (pra = calloc(1, sizeof(*pra))) == NULL)
+        return NULL;
+    pra->id = id;
+
+    // We are expecting exactly 2 values so no need to loop
+    {
+        struct drm_mode_get_property prop = {
+            .prop_id = id,
+            .count_values = 2,
+            .values_ptr = (uintptr_t)pra->range
+        };
+
+        if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_GETPROPERTY, &prop)) != 0) {
+            drmu_err(du, "%s: get property failed: %s", __func__, strerror(-rv));
+            goto fail;
+        }
+
+        if ((prop.flags & DRM_MODE_PROP_RANGE) == 0 &&
+            (prop.flags & DRM_MODE_PROP_EXTENDED_TYPE) != DRM_MODE_PROP_SIGNED_RANGE) {
+            drmu_err(du, "%s: not an signed range: flags=%#x", __func__, prop.flags);
+            goto fail;
+        }
+        if ((prop.count_values != 2)) {
+            drmu_err(du, "%s: unexpected count values: %d", __func__, prop.count_values);
+            goto fail;
+        }
+
+        pra->flags = prop.flags;
+        memcpy(pra->name, prop.name, sizeof(pra->name));
+    }
+
+#if TRACE_PROP_NEW
+    drmu_info(du, "%32s %2d: %"PRId64"->%"PRId64, pra->name, pra->id, pra->range[0], pra->range[1]);
+#endif
+
+    return pra;
+
+fail:
+    prop_range_free(pra);
+    return NULL;
+}
+
+int
+drmu_atomic_add_prop_range(drmu_atomic_t * const da, const uint32_t obj_id, const drmu_prop_range_t * const pra, const uint64_t x)
+{
+    int rv;
+
+    rv = !pra ? -ENOENT :
+        !drmu_prop_range_validate(pra, x) ? -EINVAL :
+        drmu_prop_range_immutable(pra) ? -EPERM :
+        drmu_atomic_add_prop_generic(da, obj_id, drmu_prop_range_id(pra), x, NULL, NULL);
+
+    if (rv != 0) {
+        if (rv == -EPERM && x == drmu_prop_range_min(pra) && x == drmu_prop_range_max(pra))
+            return 0;
+        drmu_warn(drmu_atomic_env(da),
+                  "%s: Failed to add range %s obj_id=%#x, prop_id=%#x, val=%"PRId64", range=%"PRId64"->%"PRId64": %s",
+                  __func__, drmu_prop_range_name(pra),
+                  obj_id, drmu_prop_range_id(pra), x, drmu_prop_range_min(pra), drmu_prop_range_max(pra), strerror(-rv));
+    }
+
+    return rv;
+}
+
+//----------------------------------------------------------------------------
+//
+// Object ID (tracked)
+
+typedef struct drmu_prop_object_s {
+    atomic_int ref_count;
+    uint32_t obj_id;
+    uint32_t prop_id;
+    uint32_t value;
+} drmu_prop_object_t;
+
+uint32_t
+drmu_prop_object_value(const drmu_prop_object_t * const obj)
+{
+    return !obj ? 0 : obj->value;
+}
+
+void
+drmu_prop_object_unref(drmu_prop_object_t ** ppobj)
+{
+    drmu_prop_object_t * const obj = *ppobj;
+
+    if (!obj)
+        return;
+    *ppobj = NULL;
+
+    if (atomic_fetch_sub(&obj->ref_count, 1) != 0)
+        return;
+
+    free(obj);
+}
+
+drmu_prop_object_t *
+drmu_prop_object_new_propinfo(drmu_env_t * const du, const uint32_t obj_id, const drmu_propinfo_t * const pi)
+{
+    const uint64_t val = propinfo_val(pi);
+    const uint32_t prop_id = propinfo_prop_id(pi);
+
+    if (obj_id == 0 || prop_id == 0)
+        return NULL;
+
+    if ((val >> 32) != 0) {  // We expect 32-bit values
+        drmu_err(du, "Bad object id value: %#"PRIx64, val);
+        return NULL;
+    }
+    else {
+        drmu_prop_object_t *const obj = calloc(1, sizeof(*obj));
+
+        if (obj == NULL)
+            return obj;
+
+        obj->obj_id = obj_id;
+        obj->prop_id = prop_id;
+        obj->value = (uint32_t)val;
+        return obj;
+    }
+}
+
+static void
+atomic_prop_object_unref(void * v)
+{
+    drmu_prop_object_t * obj = v;
+    drmu_prop_object_unref(&obj);
+}
+static void
+atomic_prop_object_ref(void * v)
+{
+    drmu_prop_object_t * obj = v;
+    atomic_fetch_add(&obj->ref_count, 1);
+}
+static void
+atomic_prop_object_commit(void * v, uint64_t val)
+{
+    drmu_prop_object_t * obj = v;
+    obj->value = (uint32_t)val;
+}
+
+int
+drmu_atomic_add_prop_object(drmu_atomic_t * const da, drmu_prop_object_t * obj, uint32_t val)
+{
+    static const drmu_atomic_prop_fns_t fns = {
+        .ref = atomic_prop_object_ref,
+        .unref = atomic_prop_object_unref,
+        .commit = atomic_prop_object_commit,
+    };
+
+    return drmu_atomic_add_prop_generic(da, obj->obj_id, obj->prop_id, val, &fns, obj);
+}
+
+//----------------------------------------------------------------------------
+//
+// BO fns
+//
+// Beware that when importing from FD we need to check that we don't already
+// have the BO as multiple FDs can map to the same BO and a single close will
+// close it irrespective of how many imports have occured.
+
+enum drmu_bo_type_e {
+    BO_TYPE_NONE = 0,
+    BO_TYPE_FD,         // Created from FD import
+    BO_TYPE_DUMB,       // Locally allocated
+    BO_TYPE_EXTERNAL,   // Externally allocated and closed
+};
+
+// BO handles come in 2 very distinct types: DUMB and FD
+// They need very different alloc & free but BO usage is the same for both
+// so it is better to have a single type.
+typedef struct drmu_bo_s {
+    // Arguably could be non-atomic for FD as then it is always protected by mutex
+    atomic_int ref_count;
+    struct drmu_env_s * du;
+    enum drmu_bo_type_e bo_type;
+    uint32_t handle;
+
+    // FD only els - FD BOs need to be tracked globally
+    struct drmu_bo_s * next;
+    struct drmu_bo_s * prev;
+} drmu_bo_t;
+
+typedef struct drmu_bo_env_s {
+    pthread_mutex_t lock;
+    drmu_bo_t * fd_head;
+} drmu_bo_env_t;
+
+static int
+bo_close(drmu_env_t * const du, uint32_t * const ph)
+{
+    struct drm_gem_close gem_close = {.handle = *ph};
+
+    if (gem_close.handle == 0)
+        return 0;
+    *ph = 0;
+
+    return drmu_ioctl(du, DRM_IOCTL_GEM_CLOSE, &gem_close);
+}
+
+// BOE lock expected
+static void
+bo_free_dumb(drmu_bo_t * const bo)
+{
+    if (bo->handle != 0) {
+        drmu_env_t * const du = bo->du;
+        struct drm_mode_destroy_dumb destroy_env = {.handle = bo->handle};
+
+        if (drmu_ioctl(du, DRM_IOCTL_MODE_DESTROY_DUMB, &destroy_env) != 0)
+            drmu_warn(du, "%s: Failed to destroy dumb handle %d", __func__, bo->handle);
+    }
+    free(bo);
+}
+
+static void
+bo_free_fd(drmu_bo_t * const bo)
+{
+    if (bo->handle != 0) {
+        drmu_env_t * const du = bo->du;
+        drmu_bo_env_t *const boe = env_boe(du);
+        const uint32_t h = bo->handle;
+
+        if (bo_close(du, &bo->handle) != 0)
+            drmu_warn(du, "%s: Failed to close BO handle %d", __func__, h);
+        if (bo->next != NULL)
+            bo->next->prev = bo->prev;
+        if (bo->prev != NULL)
+            bo->prev->next = bo->next;
+        else
+            boe->fd_head = bo->next;
+    }
+    free(bo);
+}
+
+void *
+drmu_bo_mmap(const drmu_bo_t * const bo, const size_t length, const int prot, const int flags)
+{
+    void * map_ptr = NULL;
+
+    if (bo != NULL) {
+        struct drm_mode_map_dumb map_dumb = { .handle = bo->handle };
+        drmu_env_t * const du = bo->du;
+        int rv;
+
+        if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_MAP_DUMB, &map_dumb)) != 0)
+        {
+            drmu_err(du, "%s: map dumb failed: %s", __func__, strerror(-rv));
+            return NULL;
+        }
+
+        // Avoid having to test for MAP_FAILED when testing for mapped/unmapped
+        if ((map_ptr = mmap(NULL, length, prot, flags,
+                            drmu_fd(du), map_dumb.offset)) == MAP_FAILED) {
+            drmu_err(du, "%s: mmap failed (size=%#zx, fd=%d, off=%#"PRIx64"): %s", __func__,
+                     length, drmu_fd(du), map_dumb.offset, strerror(errno));
+            return NULL;
+        }
+    }
+
+    return map_ptr;
+}
+
+uint32_t
+drmu_bo_handle(const drmu_bo_t * const bo)
+{
+    return bo == NULL ? 0 : bo->handle;
+}
+
+void
+drmu_bo_unref(drmu_bo_t ** const ppbo)
+{
+    drmu_bo_t * const bo = *ppbo;
+
+    if (bo == NULL)
+        return;
+    *ppbo = NULL;
+
+    switch (bo->bo_type) {
+        case BO_TYPE_FD:
+        {
+            drmu_bo_env_t * const boe = env_boe(bo->du);
+
+            pthread_mutex_lock(&boe->lock);
+            if (atomic_fetch_sub(&bo->ref_count, 1) == 0)
+                bo_free_fd(bo);
+            pthread_mutex_unlock(&boe->lock);
+            break;
+        }
+        case BO_TYPE_DUMB:
+            if (atomic_fetch_sub(&bo->ref_count, 1) == 0)
+                bo_free_dumb(bo);
+            break;
+        case BO_TYPE_EXTERNAL:
+            // Simple imported BO - close dealt with elsewhere
+            if (atomic_fetch_sub(&bo->ref_count, 1) == 0)
+                free(bo);
+            break;
+        case BO_TYPE_NONE:
+        default:
+            free(bo);
+            break;
+    }
+}
+
+
+drmu_bo_t *
+drmu_bo_ref(drmu_bo_t * const bo)
+{
+    if (bo != NULL)
+        atomic_fetch_add(&bo->ref_count, 1);
+    return bo;
+}
+
+int
+drmu_bo_export_fd(drmu_bo_t * bo, uint32_t flags)
+{
+    struct drm_prime_handle prime_handle = {
+        .handle = bo->handle,
+        .flags = flags == 0 ? DRM_RDWR | DRM_CLOEXEC : flags,
+        .fd = 0
+    };
+
+   if (drmu_ioctl(bo->du, DRM_IOCTL_PRIME_HANDLE_TO_FD, &prime_handle) != 0)
+       return -1;
+
+   return prime_handle.fd;
+}
+
+static drmu_bo_t *
+bo_alloc(drmu_env_t *const du, enum drmu_bo_type_e bo_type)
+{
+    drmu_bo_t * const bo = calloc(1, sizeof(*bo));
+    if (bo == NULL) {
+        drmu_err(du, "Failed to alloc BO");
+        return NULL;
+    }
+
+    bo->du = du;
+    bo->bo_type = bo_type;
+    atomic_init(&bo->ref_count, 0);
+    return bo;
+}
+
+drmu_bo_t *
+drmu_bo_new_external(drmu_env_t *const du, const uint32_t bo_handle)
+{
+    drmu_bo_t *const bo = bo_alloc(du, BO_TYPE_EXTERNAL);
+
+    if (bo == NULL) {
+        drmu_err(du, "%s: Failed to alloc BO", __func__);
+        return NULL;
+    }
+
+    bo->handle = bo_handle;
+    return bo;
+}
+
+drmu_bo_t *
+drmu_bo_new_fd(drmu_env_t *const du, const int fd)
+{
+    drmu_bo_env_t * const boe = env_boe(du);
+    drmu_bo_t * bo = NULL;
+    struct drm_prime_handle ph = { .fd = fd };
+    int rv;
+
+    pthread_mutex_lock(&boe->lock);
+
+    if ((rv = drmu_ioctl(du, DRM_IOCTL_PRIME_FD_TO_HANDLE, &ph)) != 0) {
+        drmu_err(du, "Failed to convert fd %d to BO: %s", __func__, fd, strerror(-rv));
+        goto unlock;
+    }
+
+    bo = boe->fd_head;
+    while (bo != NULL && bo->handle != ph.handle)
+        bo = bo->next;
+
+    if (bo != NULL) {
+        drmu_bo_ref(bo);
+    }
+    else {
+        if ((bo = bo_alloc(du, BO_TYPE_FD)) == NULL) {
+            bo_close(du, &ph.handle);
+        }
+        else {
+            bo->handle = ph.handle;
+
+            if ((bo->next = boe->fd_head) != NULL)
+                bo->next->prev = bo;
+            boe->fd_head = bo;
+        }
+    }
+
+unlock:
+    pthread_mutex_unlock(&boe->lock);
+    return bo;
+}
+
+// Updates the passed dumb structure with the results of creation
+drmu_bo_t *
+drmu_bo_new_dumb(drmu_env_t *const du, struct drm_mode_create_dumb * const d)
+{
+    drmu_bo_t *bo = bo_alloc(du, BO_TYPE_DUMB);
+    int rv;
+
+    if (bo == NULL)
+        return NULL;
+
+    if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_CREATE_DUMB, d)) != 0)
+    {
+        drmu_err(du, "%s: Create dumb %dx%dx%d failed: %s", __func__,
+                 d->width, d->height, d->bpp, strerror(-rv));
+        drmu_bo_unref(&bo);  // After this point aux is bound to dfb and gets freed with it
+        return NULL;
+    }
+
+    bo->handle = d->handle;
+    return bo;
+}
+
+void
+drmu_bo_env_uninit(drmu_bo_env_t * const boe)
+{
+    if (boe->fd_head != NULL)
+        drmu_warn(boe->fd_head->du, "%s: fd chain not null", __func__);
+    boe->fd_head = NULL;
+    pthread_mutex_destroy(&boe->lock);
+}
+
+void
+drmu_bo_env_init(drmu_bo_env_t * boe)
+{
+    boe->fd_head = NULL;
+    pthread_mutex_init(&boe->lock, NULL);
+}
+
+//----------------------------------------------------------------------------
+//
+// FB fns
+
+typedef struct drmu_fb_s {
+    atomic_int ref_count;  // 0 == 1 ref for ease of init
+
+    struct drmu_env_s * du;
+
+    const struct drmu_fmt_info_s * fmt_info;
+
+    struct drm_mode_fb_cmd2 fb;
+
+    drmu_rect_t active;     // Area that was asked for inside the buffer; pixels
+    drmu_rect_t crop;       // Cropping inside that; fractional pels (16.16, 16.16)
+
+    struct {
+        int fd;
+
+        drmu_bo_t * bo;
+
+        void * map_ptr;
+        size_t map_size;
+        size_t map_pitch;
+    } objects[4];
+
+    int8_t layer_obj[4];
+
+    unsigned int orientation;  // Orientation of FB i.e. inverse of rot to 0
+    drmu_color_encoding_t color_encoding; // Assumed to be constant strings that don't need freeing
+    drmu_color_range_t    color_range;
+    drmu_colorspace_t     colorspace;
+    const char * pixel_blend_mode;
+    drmu_chroma_siting_t chroma_siting;
+    drmu_isset_t hdr_metadata_isset;
+    struct hdr_output_metadata hdr_metadata;
+
+    void * pre_delete_v;
+    drmu_fb_pre_delete_fn pre_delete_fn;
+
+    void * on_delete_v;
+    drmu_fb_on_delete_fn on_delete_fn;
+
+    // We pass a pointer to this to DRM which defines it as s32 so do not use
+    // int that might be s64.
+    int32_t fence_fd;
+} drmu_fb_t;
+
+int
+drmu_fb_out_fence_wait(drmu_fb_t * const fb, const int timeout_ms)
+{
+    struct pollfd pf;
+    int rv;
+
+    if (fb->fence_fd == -1)
+        return -EINVAL;
+
+    do {
+        pf.fd = fb->fence_fd;
+        pf.events = POLLIN;
+        pf.revents = 0;
+
+        rv = poll(&pf, 1, timeout_ms);
+        if (rv >= 0)
+            break;
+
+        rv = -errno;
+    } while (rv == -EINTR);
+
+    if (rv == 0)
+        return 0;
+
+    // Both on error & success close the fd
+    close(fb->fence_fd);
+    fb->fence_fd = -1;
+    return rv;
+}
+
+int
+drmu_fb_out_fence_take_fd(drmu_fb_t * const fb)
+{
+    int fd = fb->fence_fd;
+    fb->fence_fd = -1;
+    return fd;
+}
+
+void
+drmu_fb_int_free(drmu_fb_t * const dfb)
+{
+    drmu_env_t * const du = dfb->du;
+    unsigned int i;
+
+    // Assume pre_delete is used for pool - kill stuff we don't want in pool
+    if (dfb->fence_fd != -1) {
+        drmu_warn(du, "Out fence still set on FB on delete");
+        if (drmu_fb_out_fence_wait(dfb, 500) == 0) {
+            drmu_err(du, "Out fence stuck in FB free");
+            close(dfb->fence_fd);
+        }
+    }
+
+    // Pre delete
+    if (dfb->pre_delete_fn && dfb->pre_delete_fn(dfb, dfb->pre_delete_v) != 0)
+        return;
+
+    if (dfb->fb.fb_id != 0)
+        drmu_ioctl(du, DRM_IOCTL_MODE_RMFB, &dfb->fb.fb_id);
+
+    for (i = 0; i != 4; ++i) {
+        if (dfb->objects[i].map_ptr != NULL)
+            munmap(dfb->objects[i].map_ptr, dfb->objects[i].map_size);
+        drmu_bo_unref(&dfb->objects[i].bo);
+        if (dfb->objects[i].fd != -1)
+            close(dfb->objects[i].fd);
+    }
+
+
+    // Call on_delete last so we have stopped using anything that might be
+    // freed by it
+    {
+        void * const v = dfb->on_delete_v;
+        const drmu_fb_on_delete_fn fn = dfb->on_delete_fn;
+
+        free(dfb);
+
+        if (fn)
+            fn(v);
+    }
+}
+
+void
+drmu_fb_unref(drmu_fb_t ** const ppdfb)
+{
+    drmu_fb_t * const dfb = *ppdfb;
+
+    if (dfb == NULL)
+        return;
+    *ppdfb = NULL;
+
+    if (atomic_fetch_sub(&dfb->ref_count, 1) > 0)
+        return;
+
+    drmu_fb_int_free(dfb);
+}
+
+drmu_fb_t *
+drmu_fb_ref(drmu_fb_t * const dfb)
+{
+    if (dfb != NULL)
+        atomic_fetch_add(&dfb->ref_count, 1);
+    return dfb;
+}
+
+// Beware: used by pool fns
+void
+drmu_fb_pre_delete_set(drmu_fb_t *const dfb, drmu_fb_pre_delete_fn fn, void * v)
+{
+    dfb->pre_delete_fn = fn;
+    dfb->pre_delete_v  = v;
+}
+
+void
+drmu_fb_pre_delete_unset(drmu_fb_t *const dfb)
+{
+    dfb->pre_delete_fn = (drmu_fb_pre_delete_fn)0;
+    dfb->pre_delete_v  = NULL;
+}
+
+int
+drmu_fb_pixel_blend_mode_set(drmu_fb_t *const dfb, const char * const mode)
+{
+    dfb->pixel_blend_mode = mode;
+    return 0;
+}
+
+uint32_t
+drmu_fb_pitch(const drmu_fb_t *const dfb, const unsigned int layer)
+{
+    return layer >= 4 ? 0 : dfb->fb.pitches[layer];
+}
+
+uint32_t
+drmu_fb_pitch2(const drmu_fb_t *const dfb, const unsigned int layer)
+{
+    if (layer < 4){
+        const uint64_t m = dfb->fb.modifier[layer];
+        const uint64_t s2 = fourcc_mod_broadcom_param(m);
+
+        if (m == DRM_FORMAT_MOD_BROADCOM_SAND128_COL_HEIGHT(0))
+            return layer == 0 ? dfb->fb.height : dfb->fb.height / 2;
+
+        // No good masks to check modifier so check if we convert back it matches
+        if (m != 0 && m != DRM_FORMAT_MOD_INVALID &&
+            DRM_FORMAT_MOD_BROADCOM_SAND128_COL_HEIGHT(s2) == m)
+            return (uint32_t)s2;
+    }
+    return 0;
+}
+
+void *
+drmu_fb_data(const drmu_fb_t *const dfb, const unsigned int layer)
+{
+    int obj_idx;
+    if (layer >= 4)
+        return NULL;
+    obj_idx = dfb->layer_obj[layer];
+    if (obj_idx < 0)
+        return NULL;
+    return (dfb->objects[obj_idx].map_ptr == NULL) ? NULL :
+        (uint8_t * )dfb->objects[obj_idx].map_ptr + dfb->fb.offsets[layer];
+}
+
+drmu_bo_t *
+drmu_fb_bo(const drmu_fb_t * const dfb, const unsigned int layer)
+{
+    int obj_idx;
+    if (layer >= 4)
+        return NULL;
+    obj_idx = dfb->layer_obj[layer];
+    if (obj_idx < 0)
+        return NULL;
+    return dfb->objects[obj_idx].bo;
+}
+
+uint32_t
+drmu_fb_width(const drmu_fb_t *const dfb)
+{
+    return dfb->fb.width;
+}
+
+uint32_t
+drmu_fb_height(const drmu_fb_t *const dfb)
+{
+    return dfb->fb.height;
+}
+
+// Set cropping (fractional) - x, y, relative to active x, y (and must be +ve)
+int
+drmu_fb_crop_frac_set(drmu_fb_t *const dfb, drmu_rect_t crop_frac)
+{
+    // Sanity check
+    if (crop_frac.x + crop_frac.w > (dfb->active.w << 16) ||
+        crop_frac.y + crop_frac.h > (dfb->active.h << 16))
+        return -EINVAL;
+
+    dfb->crop = (drmu_rect_t){
+        .x = crop_frac.x,
+        .y = crop_frac.y,
+        .w = crop_frac.w,
+        .h = crop_frac.h
+    };
+    return 0;
+}
+
+drmu_rect_t
+drmu_fb_crop_frac(const drmu_fb_t *const dfb)
+{
+    return dfb->crop;
+}
+
+drmu_rect_t
+drmu_fb_active(const drmu_fb_t *const dfb)
+{
+    return dfb->active;
+}
+
+
+// active is in pixels
+void
+drmu_fb_int_fmt_size_set(drmu_fb_t *const dfb, uint32_t fmt, uint32_t w, uint32_t h, const drmu_rect_t active)
+{
+    dfb->fmt_info        = drmu_fmt_info_find_fmt(fmt);
+    dfb->fb.pixel_format = fmt;
+    dfb->fb.width        = w;
+    dfb->fb.height       = h;
+    dfb->active          = active;
+    dfb->crop            = drmu_rect_shl16(active);
+    dfb->chroma_siting   = drmu_fmt_info_chroma_siting(dfb->fmt_info);
+}
+
+void
+drmu_fb_color_set(drmu_fb_t *const dfb, const drmu_color_encoding_t enc, const drmu_color_range_t range, const drmu_colorspace_t space)
+{
+    dfb->color_encoding = enc;
+    dfb->color_range    = range;
+    dfb->colorspace     = space;
+}
+
+void
+drmu_fb_chroma_siting_set(drmu_fb_t *const dfb, const drmu_chroma_siting_t siting)
+{
+    dfb->chroma_siting   = siting;
+}
+
+int
+drmu_fb_orientation_set(drmu_fb_t *const dfb, const unsigned int orientation)
+{
+    if (!drmu_rotation_is_valid(orientation))
+        return -EINVAL;
+    dfb->orientation = orientation;
+    return 0;
+}
+
+unsigned int
+drmu_fb_orientation_get(const drmu_fb_t *const dfb)
+{
+    return dfb->orientation;
+}
+
+unsigned int
+drmu_fb_rotation(const drmu_fb_t *const dfb, const unsigned int dest_rot)
+{
+    return drmu_rotation_subb(dest_rot, dfb->orientation);
+}
+
+void
+drmu_fb_int_on_delete_set(drmu_fb_t *const dfb, drmu_fb_on_delete_fn fn, void * v)
+{
+    dfb->on_delete_fn = fn;
+    dfb->on_delete_v  = v;
+}
+
+void
+drmu_fb_int_bo_set(drmu_fb_t *const dfb, const unsigned int obj_idx, drmu_bo_t * const bo)
+{
+    dfb->objects[obj_idx].bo = bo;
+}
+
+void
+drmu_fb_int_fd_set(drmu_fb_t *const dfb, const unsigned int obj_idx, const int fd)
+{
+    dfb->objects[obj_idx].fd = fd;
+}
+
+void
+drmu_fb_int_mmap_set(drmu_fb_t *const dfb, const unsigned int obj_idx, void * const buf, const size_t size, const size_t pitch)
+{
+    dfb->objects[obj_idx].map_ptr = buf;
+    dfb->objects[obj_idx].map_size = size;
+    dfb->objects[obj_idx].map_pitch = pitch;
+}
+
+void
+drmu_fb_int_layer_mod_set(drmu_fb_t *const dfb, unsigned int i, unsigned int obj_idx, uint32_t pitch, uint32_t offset, uint64_t modifier)
+{
+    dfb->layer_obj[i] = obj_idx;
+    dfb->fb.handles[i] = drmu_bo_handle(dfb->objects[obj_idx].bo);
+    dfb->fb.pitches[i] = pitch;
+    dfb->fb.offsets[i] = offset;
+    // We should be able to have "invalid" modifiers and not set the flag
+    // but that produces EINVAL - so don't do that
+    dfb->fb.modifier[i] = (modifier == DRM_FORMAT_MOD_INVALID) ? 0 : modifier;
+}
+
+void
+drmu_fb_int_layer_set(drmu_fb_t *const dfb, unsigned int i, unsigned int obj_idx, uint32_t pitch, uint32_t offset)
+{
+    drmu_fb_int_layer_mod_set(dfb, i, obj_idx, pitch, offset, DRM_FORMAT_MOD_INVALID);
+}
+
+int
+drmu_fb_int_make(drmu_fb_t *const dfb)
+{
+    drmu_env_t * du = dfb->du;
+    int rv;
+
+    dfb->fb.flags = (dfb->fb.modifier[0] == DRM_FORMAT_MOD_INVALID ||
+                     dfb->fb.modifier[0] == DRM_FORMAT_MOD_LINEAR) ? 0 : DRM_MODE_FB_MODIFIERS;
+
+    if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_ADDFB2, &dfb->fb)) != 0)
+        drmu_err(du, "AddFB2 failed: %s", strerror(-rv));
+    return rv;
+}
+
+void
+drmu_fb_hdr_metadata_set(drmu_fb_t *const dfb, const struct hdr_output_metadata * meta)
+{
+    if (meta == NULL) {
+        dfb->hdr_metadata_isset = DRMU_ISSET_NULL;
+    }
+    else {
+        dfb->hdr_metadata_isset = DRMU_ISSET_SET;
+        dfb->hdr_metadata = *meta;
+    }
+}
+
+drmu_isset_t
+drmu_fb_hdr_metadata_isset(const drmu_fb_t *const dfb)
+{
+    return dfb->hdr_metadata_isset;
+}
+
+const struct hdr_output_metadata *
+drmu_fb_hdr_metadata_get(const drmu_fb_t *const dfb)
+{
+    return dfb->hdr_metadata_isset == DRMU_ISSET_SET ? &dfb->hdr_metadata : NULL;
+}
+
+drmu_colorspace_t
+drmu_fb_colorspace_get(const drmu_fb_t * const dfb)
+{
+    return dfb->colorspace;
+}
+
+const char *
+drmu_color_range_to_broadcast_rgb(const drmu_color_range_t range)
+{
+    if (!drmu_color_range_is_set(range))
+        return DRMU_BROADCAST_RGB_UNSET;
+    else if (strcmp(range, DRMU_COLOR_RANGE_YCBCR_FULL_RANGE) == 0)
+        return DRMU_BROADCAST_RGB_FULL;
+    else if (strcmp(range, DRMU_COLOR_RANGE_YCBCR_LIMITED_RANGE) == 0)
+        return DRMU_BROADCAST_RGB_LIMITED_16_235;
+    return NULL;
+}
+
+drmu_color_range_t
+drmu_fb_color_range_get(const drmu_fb_t * const dfb)
+{
+    return dfb->color_range;
+}
+
+const struct drmu_fmt_info_s *
+drmu_fb_format_info_get(const drmu_fb_t * const dfb)
+{
+    return dfb->fmt_info;
+}
+
+drmu_fb_t *
+drmu_fb_int_alloc(drmu_env_t * const du)
+{
+    drmu_fb_t * const dfb = calloc(1, sizeof(*dfb));
+    if (dfb == NULL)
+        return NULL;
+
+    dfb->du = du;
+    dfb->chroma_siting = DRMU_CHROMA_SITING_UNSPECIFIED;
+    for (unsigned int i = 0; i != 4; ++i)
+        dfb->objects[i].fd = -1;
+    for (unsigned int i = 0; i != 4; ++i)
+        dfb->layer_obj[i] = -1;
+    dfb->fence_fd = -1;
+    return dfb;
+}
+
+// Bits per pixel on plane 0
+unsigned int
+drmu_fb_pixel_bits(const drmu_fb_t * const dfb)
+{
+    return drmu_fmt_info_pixel_bits(dfb->fmt_info);
+}
+
+uint32_t
+drmu_fb_pixel_format(const drmu_fb_t * const dfb)
+{
+    return dfb->fb.pixel_format;
+}
+
+uint64_t
+drmu_fb_modifier(const drmu_fb_t * const dfb, const unsigned int plane)
+{
+    return plane >= 4 ? DRM_FORMAT_MOD_INVALID : dfb->fb.modifier[plane];
+}
+
+static int
+fb_sync(drmu_fb_t * const dfb, unsigned int flags)
+{
+    unsigned int i;
+    for (i = 0; i != 4; ++i) {
+        if (dfb->objects[i].fd != -1 && dfb->objects[i].map_ptr != NULL) {
+            struct dma_buf_sync sync = {
+                .flags = flags
+            };
+            while (ioctl(dfb->objects[i].fd, DMA_BUF_IOCTL_SYNC, &sync) == -1) {
+                const int err = errno;
+                if (errno == EINTR)
+                    continue;
+                drmu_debug(dfb->du, "%s: ioctl failed: flags=%#x\n", __func__, flags);
+                return -err;
+            }
+        }
+    }
+    return 0;
+}
+
+int drmu_fb_write_start(drmu_fb_t * const dfb)
+{
+    return fb_sync(dfb, DMA_BUF_SYNC_START | DMA_BUF_SYNC_WRITE);
+}
+
+int drmu_fb_write_end(drmu_fb_t * const dfb)
+{
+    return fb_sync(dfb, DMA_BUF_SYNC_END | DMA_BUF_SYNC_WRITE);
+}
+
+int drmu_fb_read_start(drmu_fb_t * const dfb)
+{
+    return fb_sync(dfb, DMA_BUF_SYNC_START | DMA_BUF_SYNC_READ);
+}
+
+int drmu_fb_read_end(drmu_fb_t * const dfb)
+{
+    return fb_sync(dfb, DMA_BUF_SYNC_END | DMA_BUF_SYNC_READ);
+}
+
+typedef struct fb_fence_cb_env_s {
+    atomic_int ref_count;
+    drmu_fb_t * dfb;
+    drmu_fb_fence_fd_fn * fn;
+    void * v;
+} fb_fence_cb_env_t;
+
+static void
+fb_fence_cb_env_free(fb_fence_cb_env_t * const ffce)
+{
+    ffce->fn(ffce->v, -1, NULL);
+    drmu_fb_unref(&ffce->dfb);
+    free(ffce);
+}
+
+static fb_fence_cb_env_t *
+fb_fence_cb_env_new(drmu_fb_t * dfb, drmu_fb_fence_fd_fn * fn, void * v)
+{
+    fb_fence_cb_env_t * const ffce = malloc(sizeof(*ffce));
+    if (ffce == NULL)
+        return NULL;
+    atomic_init(&ffce->ref_count, 0);
+    ffce->dfb = drmu_fb_ref(dfb);
+    ffce->fn = fn;
+    ffce->v = v;
+    return ffce;
+}
+
+static void
+atomic_prop_fb_out_fence_unref_cb(void * v)
+{
+    fb_fence_cb_env_t * const ffce = v;
+    if (atomic_fetch_sub(&ffce->ref_count, 1) != 0)
+        return;
+    fb_fence_cb_env_free(ffce);
+}
+
+static void
+atomic_prop_fb_out_fence_ref_cb(void * v)
+{
+    fb_fence_cb_env_t * const ffce = v;
+    atomic_fetch_add(&ffce->ref_count, 1);
+}
+
+static void
+atomic_prop_fb_out_fence_commit_cb(void * v, uint64_t value)
+{
+    fb_fence_cb_env_t * const ffce = v;
+    assert(*(int*)(intptr_t)(value) != -1);
+    assert(*(int*)(intptr_t)(value) == ffce->dfb->fence_fd);
+    ffce->fn(ffce->v, *(int*)(intptr_t)(value), ffce->dfb);
+}
+
+// Writeback fence
+// Must be unset before set again
+// (This is as a handy hint that you must wait for the previous fence
+// to go ready before you set a new one)
+static int
+atomic_fb_add_out_fence(drmu_atomic_t * const da, const uint32_t obj_id, const uint32_t prop_id, drmu_fb_t * const dfb,
+                        drmu_fb_fence_fd_fn * fn, void * v)
+{
+    int rv;
+    fb_fence_cb_env_t * const ffce = fb_fence_cb_env_new(dfb, fn, v);
+
+    static const drmu_atomic_prop_fns_t fence_fns = {
+        .ref    = atomic_prop_fb_out_fence_ref_cb,
+        .unref  = atomic_prop_fb_out_fence_unref_cb,
+        .commit = atomic_prop_fb_out_fence_commit_cb
+    };
+
+    if (ffce == NULL) {
+        fn(v, -1, NULL);
+        return -ENOMEM;
+    }
+
+    if (!dfb)
+        rv = -EINVAL;
+    else if (dfb->fence_fd != -1)
+        rv = -EBUSY;
+    else
+        rv = drmu_atomic_add_prop_generic(da, obj_id, prop_id, (uintptr_t)&dfb->fence_fd, &fence_fns, ffce);
+
+    // ref will be taken by add_prop_generic if it succeeds
+    atomic_prop_fb_out_fence_unref_cb(ffce);
+    return rv;
+}
+
+// For allocation purposes given fb_pixel bits how tall
+// does the frame have to be to fit all planes if constant width
+static unsigned int
+fb_total_height(const drmu_fb_t * const dfb, const unsigned int h)
+{
+    unsigned int i;
+    const drmu_fmt_info_t *const f = dfb->fmt_info;
+    unsigned int t = 0;
+    unsigned int h0 = h * drmu_fmt_info_wdiv(f, 0);
+    const unsigned int c = drmu_fmt_info_plane_count(f);
+
+    for (i = 0; i != c; ++i)
+        t += h0 / (drmu_fmt_info_hdiv(f, i) * drmu_fmt_info_wdiv(f, i));
+
+    return t;
+}
+
+drmu_fb_t *
+drmu_fb_new_dumb_multi(drmu_env_t * const du, uint32_t w, uint32_t h,
+                     const uint32_t format, const uint64_t mod, const bool multi)
+{
+    drmu_fb_t * const dfb = drmu_fb_int_alloc(du);
+    uint32_t bpp;
+    uint32_t w2;
+    const uint32_t s30_cw = 128 / 4 * 3;
+    unsigned int plane_count;
+    const drmu_fmt_info_t * f;
+
+    if (dfb == NULL) {
+        drmu_err(du, "%s: Alloc failure", __func__);
+        return NULL;
+    }
+
+    if (mod != DRM_FORMAT_MOD_BROADCOM_SAND128_COL_HEIGHT(0))
+        w2 = w;
+    else if (format == DRM_FORMAT_NV12)
+        w2 = (w + 127) & ~127;
+    else if (format == DRM_FORMAT_P030)
+        w2 = ((w + s30_cw - 1) / s30_cw) * s30_cw;
+    else {
+        // Unknown form of sand128
+        drmu_err(du, "Sand modifier on unexpected format");
+        goto fail;
+    }
+
+    drmu_fb_int_fmt_size_set(dfb, format, w2, h, drmu_rect_wh(w, h));
+
+    if ((bpp = drmu_fb_pixel_bits(dfb)) == 0) {
+        drmu_err(du, "%s: Unexpected format %#x", __func__, format);
+        goto fail;
+    }
+
+    f = drmu_fb_format_info_get(dfb);
+    plane_count = !multi ? 1 : drmu_fmt_info_plane_count(f);
+
+    for (unsigned int i = 0; i != plane_count; ++i) {
+        const unsigned int wdiv = drmu_fmt_info_wdiv(f, i);
+        const unsigned int hdiv = drmu_fmt_info_hdiv(f, i);
+        drmu_bo_t * bo;
+        void * map_ptr;
+
+        struct drm_mode_create_dumb dumb = {
+            .bpp = bpp,
+        };
+
+        if (!multi) {
+            dumb.height = fb_total_height(dfb, (h + 1) & ~1);
+            dumb.width = ((w2 + 31) & ~31) / wdiv;
+        }
+        else {
+            dumb.height = (h + hdiv - 1) / hdiv;
+            dumb.width = (w + wdiv - 1) / wdiv;
+        }
+
+        if ((bo = drmu_bo_new_dumb(du, &dumb)) == NULL)
+            goto fail;
+        drmu_fb_int_bo_set(dfb, i, bo);
+
+        if ((map_ptr = drmu_bo_mmap(bo, (size_t)dumb.size,
+                               PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE)) == NULL)
+            goto fail;
+        drmu_fb_int_mmap_set(dfb, i, map_ptr, (size_t)dumb.size, dumb.pitch);
+
+        if (multi) {
+            drmu_fb_int_layer_mod_set(dfb, i, i, dumb.pitch, 0, mod);
+        }
+        else if (mod == DRM_FORMAT_MOD_BROADCOM_SAND128_COL_HEIGHT(0)) {
+            // Cope with the joy that is legacy sand
+            const uint64_t sand1_mod = DRM_FORMAT_MOD_BROADCOM_SAND128_COL_HEIGHT(h * 3/2);
+            drmu_fb_int_layer_mod_set(dfb, 0, 0, dumb.pitch, 0, sand1_mod);
+            drmu_fb_int_layer_mod_set(dfb, 1, 0, dumb.pitch, h * 128, sand1_mod);
+        }
+        else {
+            const uint32_t pitch0 = dumb.pitch * wdiv;
+            const unsigned int c = drmu_fmt_info_plane_count(f);
+            uint32_t t = 0;
+
+            // This should be true for anything we've allocated
+            for (unsigned int layer = 0; layer != c; ++layer) {
+                const unsigned int wdiv2 = drmu_fmt_info_wdiv(f, layer);
+                drmu_fb_int_layer_mod_set(dfb, layer, 0, pitch0 / wdiv2, t, mod);
+                t += (pitch0 * h) / (drmu_fmt_info_hdiv(f, layer) * wdiv2);
+            }
+        }
+    }
+
+    if (drmu_fb_int_make(dfb))
+        goto fail;
+
+//    drmu_debug(du, "Create dumb %p %s %dx%d / %dx%d size: %zd", dfb,
+//               drmu_log_fourcc(format), dfb->fb.width, dfb->fb.height, dfb->active.w, dfb->active.h, dfb->map_size);
+    return dfb;
+
+fail:
+    drmu_fb_int_free(dfb);
+    return NULL;
+}
+
+drmu_fb_t *
+drmu_fb_new_dumb_mod(drmu_env_t * const du, uint32_t w, uint32_t h,
+                     const uint32_t format, const uint64_t mod)
+{
+    return drmu_fb_new_dumb_multi(du, w, h, format, mod, false);
+}
+
+drmu_fb_t *
+drmu_fb_new_dumb(drmu_env_t * const du, uint32_t w, uint32_t h, const uint32_t format)
+{
+    return drmu_fb_new_dumb_multi(du, w, h, format, DRM_FORMAT_MOD_LINEAR, false);
+}
+
+bool
+drmu_fb_try_reuse(drmu_fb_t * dfb, uint32_t w, uint32_t h, const uint32_t format, const uint64_t mod)
+{
+    if (w > dfb->fb.width || h > dfb->fb.height || format != dfb->fb.pixel_format || mod != dfb->fb.modifier[0])
+        return false;
+
+    dfb->active = drmu_rect_wh(w, h);
+    dfb->crop   = drmu_rect_shl16(dfb->active);
+    return true;
+}
+
+drmu_fb_t *
+drmu_fb_realloc_dumb_mod(drmu_env_t * const du, drmu_fb_t * dfb, uint32_t w, uint32_t h, const uint32_t format, const uint64_t mod)
+{
+    if (dfb == NULL)
+        return drmu_fb_new_dumb_mod(du, w, h, format, mod);
+
+    if (drmu_fb_try_reuse(dfb, w, h, format, mod))
+        return dfb;
+
+    drmu_fb_unref(&dfb);
+    return drmu_fb_new_dumb_mod(du, w, h, format, mod);
+}
+
+drmu_fb_t *
+drmu_fb_realloc_dumb(drmu_env_t * const du, drmu_fb_t * dfb, uint32_t w, uint32_t h, const uint32_t format)
+{
+    return drmu_fb_realloc_dumb_mod(du, dfb, w, h, format, DRM_FORMAT_MOD_LINEAR);
+}
+
+static void
+atomic_prop_fb_unref(void * v)
+{
+    drmu_fb_t * fb = v;
+    drmu_fb_unref(&fb);
+}
+
+static void
+atomic_prop_fb_ref(void * v)
+{
+    drmu_fb_ref(v);
+}
+
+int
+drmu_atomic_add_prop_fb(drmu_atomic_t * const da, const uint32_t obj_id, const uint32_t prop_id, drmu_fb_t * const dfb)
+{
+    int rv;
+    static const drmu_atomic_prop_fns_t fns = {
+        .ref    = atomic_prop_fb_ref,
+        .unref  = atomic_prop_fb_unref,
+        .commit = drmu_prop_fn_null_commit,
+    };
+
+    if (dfb == NULL)
+        return drmu_atomic_add_prop_value(da, obj_id, prop_id, 0);
+
+    rv = drmu_atomic_add_prop_generic(da, obj_id, prop_id, dfb->fb.fb_id, &fns, dfb);
+    if (rv != 0)
+        drmu_warn(drmu_atomic_env(da), "%s: Failed to add fb obj_id=%#x, prop_id=%#x: %s", __func__, obj_id, prop_id, strerror(-rv));
+
+    return rv;
+}
+
+//----------------------------------------------------------------------------
+//
+// props fns (internal)
+
+typedef struct drmu_props_s {
+    struct drmu_env_s * du;
+    unsigned int n;
+    drmu_propinfo_t * info;
+    const drmu_propinfo_t ** by_name;
+} drmu_props_t;
+
+static void
+props_free(drmu_props_t * const props)
+{
+    free(props->info);  // As yet nothing else is allocated off this
+    free(props->by_name);
+    free(props);
+}
+
+static const drmu_propinfo_t *
+props_name_to_propinfo(const drmu_props_t * const props, const char * const name)
+{
+    unsigned int i = props->n / 2;
+    unsigned int a = 0;
+    unsigned int b = props->n;
+
+    while (a < b) {
+        const int r = strcmp(name, props->by_name[i]->prop.name);
+
+        if (r == 0)
+            return props->by_name[i];
+
+        if (r < 0) {
+            b = i;
+            i = (i + a) / 2;
+        } else {
+            a = i + 1;
+            i = (i + b) / 2;
+        }
+    }
+    return NULL;
+}
+
+static uint32_t
+props_name_to_id(const drmu_props_t * const props, const char * const name)
+{
+    return propinfo_prop_id(props_name_to_propinfo(props, name));
+}
+
+// Data must be freed later
+static int
+props_name_get_blob(const drmu_props_t * const props, const char * const name, void ** const ppdata, size_t * const plen)
+{
+    const drmu_propinfo_t * const pinfo = props_name_to_propinfo(props, name);
+
+    *ppdata = 0;
+    *plen = 0;
+
+    if (!pinfo)
+        return -ENOENT;
+    if ((pinfo->prop.flags & DRM_MODE_PROP_BLOB) == 0)
+        return -EINVAL;
+
+    return blob_data_read(props->du, (uint32_t)pinfo->val, ppdata, plen);
+}
+
+#if TRACE_PROP_NEW
+static void
+props_dump(const drmu_props_t * const props)
+{
+    if (props != NULL) {
+        unsigned int i;
+        drmu_env_t * const du = props->du;
+
+        for (i = 0; i != props->n; ++i) {
+            const drmu_propinfo_t * const inf = props->info + i;
+            const struct drm_mode_get_property * const p = &inf->prop;
+            char flagbuf[256];
+
+            flagbuf[0] = 0;
+            if (p->flags & DRM_MODE_PROP_PENDING)
+                strcat(flagbuf, ":pending");
+            if (p->flags & DRM_MODE_PROP_RANGE)
+                strcat(flagbuf, ":urange");
+            if (p->flags & DRM_MODE_PROP_IMMUTABLE)
+                strcat(flagbuf, ":immutable");
+            if (p->flags & DRM_MODE_PROP_ENUM)
+                strcat(flagbuf, ":enum");
+            if (p->flags & DRM_MODE_PROP_BLOB)
+                strcat(flagbuf, ":blob");
+            if (p->flags & DRM_MODE_PROP_BITMASK)
+                strcat(flagbuf, ":bitmask");
+            if ((p->flags & DRM_MODE_PROP_EXTENDED_TYPE) == DRM_MODE_PROP_OBJECT)
+                strcat(flagbuf, ":object");
+            else if ((p->flags & DRM_MODE_PROP_EXTENDED_TYPE) == DRM_MODE_PROP_SIGNED_RANGE)
+                strcat(flagbuf, ":srange");
+            else if ((p->flags & DRM_MODE_PROP_EXTENDED_TYPE) != 0)
+                strcat(flagbuf, ":?xtype?");
+            if (p->flags & ~(DRM_MODE_PROP_LEGACY_TYPE |
+                             DRM_MODE_PROP_EXTENDED_TYPE |
+                             DRM_MODE_PROP_PENDING |
+                             DRM_MODE_PROP_IMMUTABLE |
+                             DRM_MODE_PROP_ATOMIC))
+                strcat(flagbuf, ":?other?");
+            if (p->flags & DRM_MODE_PROP_ATOMIC)
+                strcat(flagbuf, ":atomic");
+
+
+            drmu_info(du, "Prop%02d/%02d: %#-4x %-16s val=%#-4"PRIx64" flags=%#x%s, values=%d, blobs=%d",
+                      i, props->n, p->prop_id,
+                      p->name, inf->val,
+                      p->flags, flagbuf,
+                      p->count_values,
+                      p->count_enum_blobs);
+        }
+    }
+}
+#endif
+
+static int
+props_qsort_by_name_cb(const void * va, const void * vb)
+{
+    const drmu_propinfo_t * const a = *(drmu_propinfo_t **)va;
+    const drmu_propinfo_t * const b = *(drmu_propinfo_t **)vb;
+    return strcmp(a->prop.name, b->prop.name);
+}
+
+// At the moment we don't need / want to fill in the values / blob arrays
+// we just want the name - will get the extra info if we need it
+static int
+propinfo_fill(drmu_env_t * const du, drmu_propinfo_t * const inf, uint32_t propid, uint64_t val)
+{
+    int rv;
+
+    inf->val = val;
+    inf->prop.prop_id = propid;
+    if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_GETPROPERTY, &inf->prop)) != 0)
+        drmu_err(du, "Failed to get property %d: %s", propid, strerror(-rv));
+    return rv;
+}
+
+static int
+props_get_properties(drmu_env_t * const du, const uint32_t objid, const uint32_t objtype,
+                     uint32_t ** const ppPropids, uint64_t ** const ppValues)
+{
+    struct drm_mode_obj_get_properties obj_props = {
+        .obj_id = objid,
+        .obj_type = objtype,
+    };
+    uint64_t * values = NULL;
+    uint32_t * propids = NULL;
+    unsigned int n = 0;
+    int rv;
+
+    for (;;) {
+        if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_OBJ_GETPROPERTIES, &obj_props)) < 0) {
+            drmu_err(du, "drmModeObjectGetProperties failed: %s", strerror(-rv));
+            goto fail;
+        }
+
+        if (obj_props.count_props <= n)
+            break;
+
+        free(values);
+        values = NULL;
+        free(propids);
+        propids = NULL;
+        n = obj_props.count_props;
+        if ((obj_props.prop_values_ptr = io_alloc(values, n)) == 0 ||
+            (obj_props.props_ptr =       io_alloc(propids, n)) == 0) {
+            drmu_err(du, "obj/value array alloc failed");
+            rv = -ENOMEM;
+            goto fail;
+        }
+    }
+
+    *ppValues = values;
+    *ppPropids = propids;
+    return (int)n;
+
+fail:
+    free(values);
+    free(propids);
+    *ppPropids = NULL;
+    *ppValues = NULL;
+    return rv;
+}
+
+static drmu_props_t *
+props_new(drmu_env_t * const du, const uint32_t objid, const uint32_t objtype)
+{
+    drmu_props_t * const props = calloc(1, sizeof(*props));
+    int rv;
+    uint64_t * values;
+    uint32_t * propids;
+
+    if (props == NULL) {
+        drmu_err(du, "%s: Failed struct alloc", __func__);
+        return NULL;
+    }
+    props->du = du;
+
+    if ((rv = props_get_properties(du, objid, objtype, &propids, &values)) < 0)
+        goto fail;
+
+    props->n = rv;
+    if ((props->info = calloc(props->n, sizeof(*props->info))) == NULL ||
+        (props->by_name = malloc(props->n * sizeof(*props->by_name))) == NULL) {
+        drmu_err(du, "info/name array alloc failed");
+        goto fail;
+    }
+
+    for (unsigned int i = 0; i < props->n; ++i) {
+        drmu_propinfo_t * const inf = props->info + i;
+
+        props->by_name[i] = inf;
+        if (propinfo_fill(du, inf, propids[i], values[i]) != 0)
+            goto fail;
+    }
+
+    // Sort into name order for faster lookup
+    qsort(props->by_name, props->n, sizeof(*props->by_name), props_qsort_by_name_cb);
+
+    free(values);
+    free(propids);
+    return props;
+
+fail:
+    props_free(props);
+    free(values);
+    free(propids);
+    return NULL;
+}
+
+int
+drmu_atomic_obj_add_snapshot(drmu_atomic_t * const da, const uint32_t objid, const uint32_t objtype)
+{
+#if 0
+    drmu_env_t * const du = drmu_atomic_env(da);
+    drmu_props_t * props = NULL;
+    unsigned int i;
+    int rv;
+
+    if (!du)
+        return -EINVAL;
+
+    if ((props = props_new(du, objid, objtype)) == NULL)
+        return -ENOENT;
+
+    for (i = 0; i != props->n; ++i) {
+        if ((props->info[i].prop.flags & (DRM_MODE_PROP_IMMUTABLE | DRM_MODE_PROP_ATOMIC)) != 0 || props->info[i].prop.prop_id == 2)
+            continue;
+        if ((rv = drmu_atomic_add_prop_generic(da, objid, props->info[i].prop.prop_id, props->info[i].val, 0, 0, NULL)) != 0)
+            goto fail;
+    }
+    rv = 0;
+
+fail:
+    props_free(props);
+    return rv;
+#else
+    uint64_t * values;
+    uint32_t * propids;
+    int rv;
+    unsigned int i, n;
+    drmu_env_t * const du = drmu_atomic_env(da);
+
+    if (!du)
+        return -EINVAL;
+
+    if ((rv = props_get_properties(du, objid, objtype, &propids, &values)) < 0)
+        goto fail;
+    n = rv;
+
+    for (i = 0; i != n; ++i) {
+        if ((rv = drmu_atomic_add_prop_value(da, objid, propids[i], values[i])) != 0)
+            goto fail;
+    }
+
+fail:
+    free(values);
+    free(propids);
+    return rv;
+#endif
+}
+
+static int
+drmu_atomic_props_add_save(drmu_atomic_t * const da, const uint32_t objid, const drmu_props_t * props)
+{
+    unsigned int i;
+    int rv;
+    drmu_env_t * const du = drmu_atomic_env(da);
+
+    if (props == NULL)
+        return 0;
+    if (du == NULL)
+        return -EINVAL;
+
+    for (i = 0; i != props->n; ++i) {
+        if ((props->info[i].prop.flags & DRM_MODE_PROP_IMMUTABLE) != 0)
+            continue;
+
+        // Blobs, if set, are prone to running out of refs and vanishing, so we
+        // must copy. If we fail to copy the blob for any reason drop through
+        // to the generic add and hope that that will do
+        if ((props->info[i].prop.flags & DRM_MODE_PROP_BLOB) != 0 && props->info[i].val != 0) {
+            drmu_blob_t * b = drmu_blob_copy_id(du, (uint32_t)props->info[i].val);
+            if (b != NULL) {
+                rv = drmu_atomic_add_prop_blob(da, objid, props->info[i].prop.prop_id, b);
+                drmu_blob_unref(&b);
+                if (rv == 0)
+                    continue;
+            }
+        }
+
+        // Generic value
+        if ((rv = drmu_atomic_add_prop_value(da, objid, props->info[i].prop.prop_id, props->info[i].val)) != 0)
+            return rv;
+    }
+    return 0;
+}
+
+//----------------------------------------------------------------------------
+//
+// Rotation util
+
+static unsigned int
+rotation_make_array(drmu_prop_bitmask_t * const pid, uint64_t values[8])
+{
+    uint64_t r0;
+    unsigned int i;
+    unsigned int mask = 0;
+
+    memset(values, 0, sizeof(values[0]) * 8);
+    if (pid == NULL)
+        return (1 << DRMU_ROTATION_0);
+
+    r0 = drmu_prop_bitmask_value(pid, "rotate-0");
+    if (r0 != 0) {
+        values[DRMU_ROTATION_0] = r0;
+        // Flips MUST be combined with a rotate
+        if ((values[DRMU_ROTATION_H_FLIP] = drmu_prop_bitmask_value(pid, "reflect-x")) != 0)
+            values[DRMU_ROTATION_H_FLIP] |= r0;
+        if ((values[DRMU_ROTATION_V_FLIP] = drmu_prop_bitmask_value(pid, "reflect-y")) != 0)
+            values[DRMU_ROTATION_V_FLIP] |= r0;
+        // Transpose counts as a Flip
+        if ((values[DRMU_ROTATION_TRANSPOSE] = drmu_prop_bitmask_value(pid, "transpose")) != 0)
+            values[DRMU_ROTATION_TRANSPOSE] |= r0;
+    }
+    values[DRMU_ROTATION_180] = drmu_prop_bitmask_value(pid, "rotate-180");
+    if (!values[DRMU_ROTATION_180] && values[DRMU_ROTATION_H_FLIP] && values[DRMU_ROTATION_V_FLIP])
+        values[DRMU_ROTATION_180] = values[DRMU_ROTATION_H_FLIP] | values[DRMU_ROTATION_V_FLIP];
+    values[DRMU_ROTATION_90] = drmu_prop_bitmask_value(pid, "rotate-90");
+    values[DRMU_ROTATION_270] = drmu_prop_bitmask_value(pid, "rotate-270");
+
+    for (i = 0; i != 8; ++i)
+        if (values[i] != 0)
+            mask |= (1 << i);
+    return mask;
+}
+
+//----------------------------------------------------------------------------
+//
+// CRTC fns
+
+typedef struct drmu_crtc_s {
+    struct drmu_env_s * du;
+    int crtc_idx;
+
+    atomic_int ref_count;
+    bool saved;
+
+    struct drm_mode_crtc crtc;
+
+    struct {
+        drmu_prop_range_t * active;
+        uint32_t mode_id;
+    } pid;
+
+    drmu_blob_t * mode_id_blob;
+
+} drmu_crtc_t;
+
+static void
+crtc_uninit(drmu_crtc_t * const dc)
+{
+    drmu_prop_range_delete(&dc->pid.active);
+    drmu_blob_unref(&dc->mode_id_blob);
+}
+
+static void
+crtc_free(drmu_crtc_t * const dc)
+{
+    crtc_uninit(dc);
+    free(dc);
+}
+
+
+#if 0
+// Set misc derived vars from mode
+static void
+crtc_mode_set_vars(drmu_crtc_t * const dc)
+{
+    switch (dc->crtc.mode.flags & DRM_MODE_FLAG_PIC_AR_MASK) {
+        case DRM_MODE_FLAG_PIC_AR_4_3:
+            dc->par = (drmu_ufrac_t){4,3};
+            break;
+        case DRM_MODE_FLAG_PIC_AR_16_9:
+            dc->par = (drmu_ufrac_t){16,9};
+            break;
+        case DRM_MODE_FLAG_PIC_AR_64_27:
+            dc->par = (drmu_ufrac_t){64,27};
+            break;
+        case DRM_MODE_FLAG_PIC_AR_256_135:
+            dc->par = (drmu_ufrac_t){256,135};
+            break;
+        default:
+        case DRM_MODE_FLAG_PIC_AR_NONE:
+            dc->par = (drmu_ufrac_t){0,0};
+            break;
+    }
+
+    if (dc->par.den == 0) {
+        // Assume 1:1
+        dc->sar = (drmu_ufrac_t){1,1};
+    }
+    else {
+        dc->sar = drmu_ufrac_reduce((drmu_ufrac_t) {dc->par.num * dc->crtc.mode.vdisplay, dc->par.den * dc->crtc.mode.hdisplay});
+    }
+}
+
+static int
+atomic_crtc_bpc_set(drmu_atomic_t * const da, drmu_crtc_t * const dc,
+                    const char * const colorspace,
+                    const unsigned int max_bpc)
+{
+    const uint32_t con_id = dc->con->connector_id;
+    int rv = 0;
+
+    if (!dc->du->modeset_allow)
+        return 0;
+
+    if ((dc->pid.colorspace &&
+         (rv = drmu_atomic_add_prop_enum(da, con_id, dc->pid.colorspace, colorspace)) != 0) ||
+        (dc->pid.max_bpc &&
+         (rv = drmu_atomic_add_prop_range(da, con_id, dc->pid.max_bpc, max_bpc)) != 0))
+        return rv;
+    return 0;
+}
+
+
+static int
+atomic_crtc_hi_bpc_set(drmu_atomic_t * const da, drmu_crtc_t * const dc)
+{
+    return atomic_crtc_bpc_set(da, dc, "BT2020_YCC", 12);
+}
+#endif
+
+void
+drmu_crtc_delete(drmu_crtc_t ** ppdc)
+{
+    drmu_crtc_t * const dc = * ppdc;
+
+    if (dc == NULL)
+        return;
+    *ppdc = NULL;
+
+    crtc_free(dc);
+}
+
+drmu_env_t *
+drmu_crtc_env(const drmu_crtc_t * const dc)
+{
+    return dc == NULL ? NULL : dc->du;
+}
+
+uint32_t
+drmu_crtc_id(const drmu_crtc_t * const dc)
+{
+    return dc->crtc.crtc_id;
+}
+
+int
+drmu_crtc_idx(const drmu_crtc_t * const dc)
+{
+    return dc->crtc_idx;
+}
+
+static int
+crtc_init(drmu_env_t * const du, drmu_crtc_t * const dc, const unsigned int idx, const uint32_t crtc_id)
+{
+    int rv;
+    drmu_props_t * props;
+
+    memset(dc, 0, sizeof(*dc));
+    dc->du = du;
+    dc->crtc_idx = idx;
+    dc->crtc.crtc_id = crtc_id;
+
+    if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_GETCRTC, &dc->crtc)) != 0) {
+        drmu_err(du, "Failed to get crtc id %d: %s", crtc_id, strerror(-rv));
+        return rv;
+    }
+
+    props = props_new(du, dc->crtc.crtc_id, DRM_MODE_OBJECT_CRTC);
+
+    if (props != NULL) {
+#if TRACE_PROP_NEW
+        drmu_info(du, "CRTC id=%#x, idx=%d:", dc->crtc.crtc_id, dc->crtc_idx);
+        props_dump(props);
+#endif
+        dc->pid.mode_id = props_name_to_id(props, "MODE_ID");
+        dc->pid.active = drmu_prop_range_new(du, props_name_to_id(props, "ACTIVE"));
+
+        props_free(props);
+    }
+
+    return 0;
+}
+
+static drmu_ufrac_t
+modeinfo_par(const struct drm_mode_modeinfo * const mode)
+{
+    switch (mode->flags & DRM_MODE_FLAG_PIC_AR_MASK) {
+        case DRM_MODE_FLAG_PIC_AR_4_3:
+            return (drmu_ufrac_t){4,3};
+        case DRM_MODE_FLAG_PIC_AR_16_9:
+            return (drmu_ufrac_t){16,9};
+        case DRM_MODE_FLAG_PIC_AR_64_27:
+            return (drmu_ufrac_t){64,27};
+        case DRM_MODE_FLAG_PIC_AR_256_135:
+            return (drmu_ufrac_t){256,135};
+        default:
+        case DRM_MODE_FLAG_PIC_AR_NONE:
+            break;
+    }
+    return (drmu_ufrac_t){0,0};
+}
+
+static drmu_mode_simple_params_t
+modeinfo_simple_params(const struct drm_mode_modeinfo * const mode)
+{
+    if (!mode)
+        return (drmu_mode_simple_params_t){ 0 };
+    else {
+        drmu_mode_simple_params_t rv = {
+            .width = mode->hdisplay,
+            .height = mode->vdisplay,
+            .hz_x_1000 = (uint32_t)(((uint64_t)mode->clock * 1000000) / (mode->htotal * mode->vtotal)),
+            .par = modeinfo_par(mode),
+            .sar = {1, 1},
+            .type = mode->type,
+            .flags = mode->flags,
+        };
+
+        if (rv.par.den != 0)
+            rv.sar = drmu_ufrac_reduce((drmu_ufrac_t) {rv.par.num * rv.height, rv.par.den * rv.width});
+
+        return rv;
+    }
+}
+
+drmu_crtc_t *
+drmu_env_crtc_find_id(drmu_env_t * const du, const uint32_t crtc_id)
+{
+    unsigned int i;
+    drmu_crtc_t * dc;
+
+    for (i = 0; (dc = drmu_env_crtc_find_n(du, i)) != NULL; ++i) {
+        if (dc->crtc.crtc_id == crtc_id)
+            return dc;
+    }
+    return NULL;
+}
+
+const struct drm_mode_modeinfo *
+drmu_crtc_modeinfo(const drmu_crtc_t * const dc)
+{
+    if (!dc || !dc->crtc.mode_valid)
+        return NULL;
+    return &dc->crtc.mode;
+}
+
+drmu_mode_simple_params_t
+drmu_crtc_mode_simple_params(const drmu_crtc_t * const dc)
+{
+    return modeinfo_simple_params(drmu_crtc_modeinfo(dc));
+}
+
+int
+drmu_atomic_crtc_add_modeinfo(struct drmu_atomic_s * const da, drmu_crtc_t * const dc, const struct drm_mode_modeinfo * const modeinfo)
+{
+    drmu_env_t * const du = drmu_atomic_env(da);
+    int rv;
+
+    if (!modeinfo || dc->pid.mode_id == 0)
+        return 0;
+
+    if ((rv = drmu_blob_update(du, &dc->mode_id_blob, modeinfo, sizeof(*modeinfo))) != 0)
+        return rv;
+
+    return drmu_atomic_add_prop_blob(da, dc->crtc.crtc_id, dc->pid.mode_id, dc->mode_id_blob);
+}
+
+int
+drmu_atomic_crtc_add_active(struct drmu_atomic_s * const da, drmu_crtc_t * const dc, unsigned int val)
+{
+    return drmu_atomic_add_prop_range(da, dc->crtc.crtc_id, dc->pid.active, val);
+}
+
+// Use the same claim logic as we do for planes
+// As it stands we don't do anything much on final unref so the logic
+// isn't really needed but it doesn't cost us much so do this way against
+// future need
+
+bool
+drmu_crtc_is_claimed(const drmu_crtc_t * const dc)
+{
+    return atomic_load(&dc->ref_count) != 0;
+}
+
+void
+drmu_crtc_unref(drmu_crtc_t ** const ppdc)
+{
+    drmu_crtc_t * const dc = *ppdc;
+
+    if (dc == NULL)
+        return;
+    *ppdc = NULL;
+
+    if (atomic_fetch_sub(&dc->ref_count, 1) != 2)
+        return;
+    atomic_store(&dc->ref_count, 0);
+}
+
+drmu_crtc_t *
+drmu_crtc_ref(drmu_crtc_t * const dc)
+{
+    if (!dc)
+        return NULL;
+    atomic_fetch_add(&dc->ref_count, 1);
+    return dc;
+}
+
+static int
+crtc_state_save(drmu_env_t * const du, drmu_crtc_t * const dc)
+{
+    int rv = 0;
+    // 1st time through save state
+    if (!dc->saved &&
+        (rv = env_object_state_save(du, dc->crtc.crtc_id, DRM_MODE_OBJECT_CRTC)) == 0)
+        dc->saved = true;
+    return rv;
+}
+
+// A Conn should be claimed before any op that might change its state
+int
+drmu_crtc_claim_ref(drmu_crtc_t * const dc)
+{
+    drmu_env_t * const du = dc->du;
+    int ref0 = 0;
+    if (!atomic_compare_exchange_strong(&dc->ref_count, &ref0, 2))
+        return -EBUSY;
+
+    // 1st time through save state
+    crtc_state_save(du, dc);
+
+    return 0;
+}
+
+//----------------------------------------------------------------------------
+//
+// CONN functions
+
+static const char * conn_type_names[32] = {
+    [DRM_MODE_CONNECTOR_Unknown]     = "Unknown",
+    [DRM_MODE_CONNECTOR_VGA]         = "VGA",
+    [DRM_MODE_CONNECTOR_DVII]        = "DVI-I",
+    [DRM_MODE_CONNECTOR_DVID]        = "DVI-D",
+    [DRM_MODE_CONNECTOR_DVIA]        = "DVI-A",
+    [DRM_MODE_CONNECTOR_Composite]   = "Composite",
+    [DRM_MODE_CONNECTOR_SVIDEO]      = "SVIDEO",
+    [DRM_MODE_CONNECTOR_LVDS]        = "LVDS",
+    [DRM_MODE_CONNECTOR_Component]   = "Component",
+    [DRM_MODE_CONNECTOR_9PinDIN]     = "9PinDIN",
+    [DRM_MODE_CONNECTOR_DisplayPort] = "DisplayPort",
+    [DRM_MODE_CONNECTOR_HDMIA]       = "HDMI-A",
+    [DRM_MODE_CONNECTOR_HDMIB]       = "HDMI-B",
+    [DRM_MODE_CONNECTOR_TV]          = "TV",
+    [DRM_MODE_CONNECTOR_eDP]         = "eDP",
+    [DRM_MODE_CONNECTOR_VIRTUAL]     = "VIRTUAL",
+    [DRM_MODE_CONNECTOR_DSI]         = "DSI",
+    [DRM_MODE_CONNECTOR_DPI]         = "DPI",
+    [DRM_MODE_CONNECTOR_WRITEBACK]   = "WRITEBACK",
+    [DRM_MODE_CONNECTOR_SPI]         = "SPI",
+#ifdef DRM_MODE_CONNECTOR_USB
+    [DRM_MODE_CONNECTOR_USB]         = "USB",
+#endif
+};
+
+struct drmu_conn_s {
+    drmu_env_t * du;
+    unsigned int conn_idx;
+
+    atomic_int ref_count;
+    bool saved;
+
+    struct drm_mode_get_connector conn;
+    bool probed;
+    unsigned int modes_size;
+    unsigned int enc_ids_size;
+    struct drm_mode_modeinfo * modes;
+    uint32_t * enc_ids;
+
+    uint32_t avail_crtc_mask;
+
+    struct {
+        drmu_prop_object_t * crtc_id;
+        drmu_prop_range_t * max_bpc;
+        drmu_prop_enum_t * colorspace;
+        drmu_prop_enum_t * broadcast_rgb;
+        drmu_prop_bitmask_t * rotation;
+        uint32_t hdr_output_metadata;
+        uint32_t writeback_out_fence_ptr;
+        uint32_t writeback_fb_id;
+    } pid;
+
+    unsigned int rot_mask;
+    uint64_t rot_vals[8];
+    drmu_blob_t * hdr_metadata_blob;
+
+    uint32_t * writeback_fmts;
+    size_t writeback_fmts_count;
+
+    char name[32];
+};
+
+
+int
+drmu_atomic_conn_add_hdr_metadata(drmu_atomic_t * const da, drmu_conn_t * const dn, const struct hdr_output_metadata * const m)
+{
+    drmu_env_t * const du = drmu_atomic_env(da);
+    int rv;
+
+    if (!du || !dn)  // du will be null if da is null
+        return -ENOENT;
+
+    if (dn->pid.hdr_output_metadata == 0)
+        return 0;
+
+    if ((rv = drmu_blob_update(du, &dn->hdr_metadata_blob, m, sizeof(*m))) != 0)
+        return rv;
+
+    rv = drmu_atomic_add_prop_blob(da, dn->conn.connector_id, dn->pid.hdr_output_metadata, dn->hdr_metadata_blob);
+    if (rv != 0)
+        drmu_err(du, "Set property fail: %s", strerror(errno));
+
+    return rv;
+}
+
+bool
+drmu_conn_has_hi_bpc(const drmu_conn_t * const dn)
+{
+    return drmu_prop_range_max(dn->pid.max_bpc) > 8;
+}
+
+int
+drmu_atomic_conn_add_hi_bpc(drmu_atomic_t * const da, drmu_conn_t * const dn, bool hi_bpc)
+{
+    return !hi_bpc && dn->pid.max_bpc == NULL ? 0 :
+        drmu_atomic_add_prop_range(da, dn->conn.connector_id, dn->pid.max_bpc, !hi_bpc ? 8 :
+                                      drmu_prop_range_max(dn->pid.max_bpc));
+}
+
+int
+drmu_atomic_conn_add_colorspace(drmu_atomic_t * const da, drmu_conn_t * const dn, const drmu_colorspace_t colorspace)
+{
+    if (!dn->pid.colorspace)
+        return 0;
+
+    return drmu_atomic_add_prop_enum(da, dn->conn.connector_id, dn->pid.colorspace, colorspace);
+}
+
+int
+drmu_atomic_conn_add_broadcast_rgb(drmu_atomic_t * const da, drmu_conn_t * const dn, const drmu_broadcast_rgb_t bcrgb)
+{
+    if (!dn->pid.broadcast_rgb)
+        return 0;
+
+    return drmu_atomic_add_prop_enum(da, dn->conn.connector_id, dn->pid.broadcast_rgb, bcrgb);
+}
+
+int
+drmu_atomic_conn_add_crtc(drmu_atomic_t * const da, drmu_conn_t * const dn, drmu_crtc_t * const dc)
+{
+    return drmu_atomic_add_prop_object(da, dn->pid.crtc_id, drmu_crtc_id(dc));
+}
+
+bool
+drmu_conn_has_rotation(const drmu_conn_t * const dn, const unsigned int rotation)
+{
+    return rotation < 8 && dn != NULL &&
+        (dn->rot_vals[rotation] != 0 ||
+            (!dn->pid.rotation && rotation == DRMU_ROTATION_0));
+}
+
+unsigned int
+drmu_conn_rotation_mask(const drmu_conn_t * const dn)
+{
+    return dn->rot_mask;
+}
+
+int
+drmu_atomic_conn_add_rotation(drmu_atomic_t * const da, drmu_conn_t * const dn, const unsigned int rotation)
+{
+    return !drmu_conn_has_rotation(dn, rotation) ? -EINVAL :
+        !dn->pid.rotation ? 0 : // Must be rotation_0 here
+            drmu_atomic_add_prop_bitmask(da, dn->conn.connector_id, dn->pid.rotation, dn->rot_vals[rotation]);
+}
+
+static void
+fb_fence_cb_null_cb(void * v, int fd, drmu_fb_t * dfb)
+{
+    (void)v;
+    (void)fd;
+    (void)dfb;
+}
+
+int
+drmu_atomic_conn_add_writeback_fb(drmu_atomic_t * const da_out, drmu_conn_t * const dn,
+                                  drmu_fb_t * const dfb,
+                                  drmu_fb_fence_fd_fn * const fn_req, void * const v)
+{
+    drmu_fb_fence_fd_fn * const fn = (fn_req != NULL) ? fn_req : fb_fence_cb_null_cb;
+
+    // Add both or neither, so build a temp atomic to store the intermediate result
+    drmu_atomic_t * da = drmu_atomic_new(drmu_atomic_env(da_out));
+    int rv;
+
+    if (!da) {
+        fn(v, -1, NULL);
+        return -ENOMEM;
+    }
+
+    if ((rv = atomic_fb_add_out_fence(da, dn->conn.connector_id, dn->pid.writeback_out_fence_ptr, dfb, fn, v)) != 0)
+        goto fail;
+
+    if ((rv = drmu_atomic_add_prop_fb(da, dn->conn.connector_id, dn->pid.writeback_fb_id, dfb)) != 0)
+        goto fail;
+
+    return drmu_atomic_merge(da_out, &da);
+
+fail:
+    drmu_atomic_unref(&da);
+    return rv;
+}
+
+const uint32_t *
+drmu_conn_writeback_formats(drmu_conn_t * const dn, size_t * const ppcount)
+{
+    *ppcount = dn->writeback_fmts_count;
+    return dn->writeback_fmts;
+}
+
+const struct drm_mode_modeinfo *
+drmu_conn_modeinfo(const drmu_conn_t * const dn, const int mode_id)
+{
+    return !dn || mode_id < 0 || (unsigned int)mode_id >= dn->conn.count_modes ? NULL :
+        dn->modes + mode_id;
+}
+
+drmu_mode_simple_params_t
+drmu_conn_mode_simple_params(const drmu_conn_t * const dn, const int mode_id)
+{
+    return modeinfo_simple_params(drmu_conn_modeinfo(dn, mode_id));
+}
+
+bool
+drmu_conn_is_output(const drmu_conn_t * const dn)
+{
+    return dn->conn.connector_type != DRM_MODE_CONNECTOR_WRITEBACK;
+}
+
+bool
+drmu_conn_is_writeback(const drmu_conn_t * const dn)
+{
+    return dn->conn.connector_type == DRM_MODE_CONNECTOR_WRITEBACK;
+}
+
+const char *
+drmu_conn_name(const drmu_conn_t * const dn)
+{
+    return dn->name;
+}
+
+uint32_t
+drmu_conn_crtc_id_get(const drmu_conn_t * const dn)
+{
+    return drmu_prop_object_value(dn->pid.crtc_id);
+}
+
+uint32_t
+drmu_conn_possible_crtcs(const drmu_conn_t * const dn)
+{
+    return dn->avail_crtc_mask;
+}
+
+unsigned int
+drmu_conn_idx_get(const drmu_conn_t * const dn)
+{
+    return dn->conn_idx;
+}
+
+static void
+conn_uninit(drmu_conn_t * const dn)
+{
+    drmu_prop_object_unref(&dn->pid.crtc_id);
+    drmu_prop_range_delete(&dn->pid.max_bpc);
+    drmu_prop_enum_delete(&dn->pid.colorspace);
+    drmu_prop_enum_delete(&dn->pid.broadcast_rgb);
+    drmu_prop_bitmask_delete(&dn->pid.rotation);
+
+    drmu_blob_unref(&dn->hdr_metadata_blob);
+
+    free(dn->modes);
+    free(dn->enc_ids);
+    free(dn->writeback_fmts);
+    dn->modes = NULL;
+    dn->enc_ids = NULL;
+    dn->writeback_fmts = NULL;
+    dn->modes_size = 0;
+    dn->enc_ids_size = 0;
+    dn->writeback_fmts_count = 0;
+}
+
+// Assumes zeroed before entry
+static int
+conn_init(drmu_env_t * const du, drmu_conn_t * const dn, unsigned int conn_idx, const uint32_t conn_id)
+{
+    int rv;
+    drmu_props_t * props;
+    uint32_t modes_req = 0;
+    uint32_t encs_req = 0;
+
+    dn->du = du;
+    dn->conn_idx = conn_idx;
+    // * As count_modes == 0 this probes - do we really want this?
+
+    do {
+        memset(&dn->conn, 0, sizeof(dn->conn));
+        dn->conn.connector_id = conn_id;
+
+        if (modes_req > dn->modes_size) {
+            free(dn->modes);
+            if (io_alloc(dn->modes, modes_req) == 0) {
+                drmu_err(du, "Failed to alloc modes array");
+                goto fail;
+            }
+            dn->modes_size = modes_req;
+        }
+        dn->conn.modes_ptr = (uintptr_t)dn->modes;
+        dn->conn.count_modes = modes_req;
+
+        if (encs_req > dn->enc_ids_size) {
+            free(dn->enc_ids);
+            if (io_alloc(dn->enc_ids, encs_req) == 0) {
+                drmu_err(du, "Failed to alloc encs array");
+                goto fail;
+            }
+            dn->enc_ids_size = encs_req;
+        }
+        dn->conn.encoders_ptr = (uintptr_t)dn->enc_ids;
+        dn->conn.count_encoders = encs_req;
+
+        if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_GETCONNECTOR, &dn->conn)) != 0) {
+            drmu_err(du, "Get connector id %d failed: %s", dn->conn.connector_id, strerror(-rv));
+            goto fail;
+        }
+        modes_req = dn->conn.count_modes;
+        encs_req = dn->conn.count_encoders;
+
+    } while (dn->modes_size < modes_req || dn->enc_ids_size < encs_req);
+
+    dn->probed = true;
+
+    if (dn->conn.connector_type >= sizeof(conn_type_names) / sizeof(conn_type_names[0]))
+        snprintf(dn->name, sizeof(dn->name)-1, "CT%"PRIu32"-%"PRIu32,
+                 dn->conn.connector_type, dn->conn.connector_type_id);
+    else
+        snprintf(dn->name, sizeof(dn->name)-1, "%s-%"PRIu32,
+                 conn_type_names[dn->conn.connector_type], dn->conn.connector_type_id);
+
+    props = props_new(du, dn->conn.connector_id, DRM_MODE_OBJECT_CONNECTOR);
+
+    // Spin over encoders to create a crtc mask
+    dn->avail_crtc_mask = 0;
+    for (unsigned int i = 0; i != dn->conn.count_encoders; ++i) {
+        struct drm_mode_get_encoder enc = {.encoder_id = dn->enc_ids[i]};
+        if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_GETENCODER, &enc)) != 0) {
+            drmu_warn(du, "Failed to get encoder: id: %#x", enc.encoder_id);
+            continue;
+        }
+        dn->avail_crtc_mask |= enc.possible_crtcs;
+    }
+
+    if (props != NULL) {
+        void * wb_blob_data;
+        size_t wb_blob_len;
+
+#if TRACE_PROP_NEW
+        drmu_info(du, "Connector id=%d, type=%d.%d (%s), crtc_mask=%#x:",
+                  dn->conn.connector_id, dn->conn.connector_type, dn->conn.connector_type_id, drmu_conn_name(dn),
+                  dn->avail_crtc_mask);
+        props_dump(props);
+#endif
+        dn->pid.crtc_id             = drmu_prop_object_new_propinfo(du, dn->conn.connector_id, props_name_to_propinfo(props, "CRTC_ID"));
+        dn->pid.max_bpc             = drmu_prop_range_new(du, props_name_to_id(props, "max bpc"));
+        dn->pid.colorspace          = drmu_prop_enum_new(du, props_name_to_id(props, "Colorspace"));
+        dn->pid.broadcast_rgb       = drmu_prop_enum_new(du, props_name_to_id(props, "Broadcast RGB"));
+        dn->pid.rotation            = drmu_prop_bitmask_new(du, props_name_to_id(props, "rotation"));
+        dn->pid.hdr_output_metadata = props_name_to_id(props, "HDR_OUTPUT_METADATA");
+        dn->pid.writeback_fb_id     = props_name_to_id(props, "WRITEBACK_FB_ID");
+        dn->pid.writeback_out_fence_ptr = props_name_to_id(props, "WRITEBACK_OUT_FENCE_PTR");
+
+        props_name_get_blob(props, "WRITEBACK_PIXEL_FORMATS", &wb_blob_data, &wb_blob_len);
+        props_free(props);
+        dn->writeback_fmts = wb_blob_data;
+        dn->writeback_fmts_count = wb_blob_len / sizeof(*dn->writeback_fmts);
+
+        dn->rot_mask = rotation_make_array(dn->pid.rotation, dn->rot_vals);
+    }
+
+    return 0;
+
+fail:
+    conn_uninit(dn);
+    return rv;
+}
+
+// Use the same claim logic as we do for planes
+// As it stands we don't do anything much on final unref so the logic
+// isn't really needed but it doesn't cost us much so do this way against
+// future need
+
+bool
+drmu_conn_is_claimed(const drmu_conn_t * const dn)
+{
+    return atomic_load(&dn->ref_count) != 0;
+}
+
+void
+drmu_conn_unref(drmu_conn_t ** const ppdn)
+{
+    drmu_conn_t * const dn = *ppdn;
+
+    if (dn == NULL)
+        return;
+    *ppdn = NULL;
+
+    if (atomic_fetch_sub(&dn->ref_count, 1) != 2)
+        return;
+    atomic_store(&dn->ref_count, 0);
+}
+
+drmu_conn_t *
+drmu_conn_ref(drmu_conn_t * const dn)
+{
+    if (!dn)
+        return NULL;
+    atomic_fetch_add(&dn->ref_count, 1);
+    return dn;
+}
+
+static int
+conn_state_save(drmu_env_t * const du, drmu_conn_t * const dn)
+{
+    int rv = 0;
+    // 1st time through save state
+    if (!dn->saved &&
+        (rv = env_object_state_save(du, dn->conn.connector_id, DRM_MODE_OBJECT_CONNECTOR)) == 0)
+        dn->saved = true;
+    return rv;
+}
+
+// A Conn should be claimed before any op that might change its state
+int
+drmu_conn_claim_ref(drmu_conn_t * const dn)
+{
+    drmu_env_t * const du = dn->du;
+    int ref0 = 0;
+    if (!atomic_compare_exchange_strong(&dn->ref_count, &ref0, 2))
+        return -EBUSY;
+
+    // 1st time through save state
+    conn_state_save(du, dn);
+
+    return 0;
+}
+
+//----------------------------------------------------------------------------
+//
+// Rotation functions
+
+unsigned int
+drmu_rotation_find(const unsigned int req_rot, const unsigned int mask_a, const unsigned int mask_b)
+{
+    unsigned int i;
+    unsigned int b;
+
+    for (i = 0, b = mask_b & 0xff; b != 0; ++i, b >>= 1) {
+        unsigned int r;
+
+        if ((b & 1) == 0)
+            continue;
+
+        r = drmu_rotation_suba(req_rot, i);
+        if (((mask_a >> r) & 1) != 0)
+            return r;
+    }
+    return DRMU_ROTATION_INVALID;
+}
+
+
+//----------------------------------------------------------------------------
+//
+// Plane fns
+
+typedef struct drmu_plane_s {
+    struct drmu_env_s * du;
+
+    // Unlike most ref counts in drmu this is 0 for unrefed, 2 for single ref
+    // and 1 for whilst unref cleanup is in progress. Guards dc
+    atomic_int ref_count;
+    struct drmu_crtc_s * dc;    // NULL if not in use
+    bool saved;
+
+    int plane_type;
+    struct drm_mode_get_plane plane;
+
+    void * formats_in;
+    size_t formats_in_len;
+    const struct drm_format_modifier_blob * fmts_hdr;
+
+    struct {
+        uint32_t crtc_id;
+        uint32_t fb_id;
+        drmu_prop_range_t * crtc_h;
+        drmu_prop_range_t * crtc_w;
+        uint32_t crtc_x;
+        uint32_t crtc_y;
+        drmu_prop_range_t * src_h;
+        drmu_prop_range_t * src_w;
+        uint32_t src_x;
+        uint32_t src_y;
+        drmu_prop_range_t * alpha;
+        drmu_prop_enum_t * color_encoding;
+        drmu_prop_enum_t * color_range;
+        drmu_prop_enum_t * pixel_blend_mode;
+        drmu_prop_bitmask_t * rotation;
+        drmu_prop_range_t * chroma_siting_h;
+        drmu_prop_range_t * chroma_siting_v;
+        drmu_prop_range_t * zpos;
+    } pid;
+
+    unsigned int rot_mask;
+    uint64_t rot_vals[8];
+} drmu_plane_t;
+
+static int
+plane_set_atomic(drmu_atomic_t * const da,
+                 drmu_plane_t * const dp,
+                 drmu_fb_t * const dfb,
+                int32_t crtc_x, int32_t crtc_y,
+                uint32_t crtc_w, uint32_t crtc_h,
+                uint32_t src_x, uint32_t src_y,
+                uint32_t src_w, uint32_t src_h)
+{
+    const uint32_t plid = dp->plane.plane_id;
+    drmu_atomic_add_prop_value(da, plid, dp->pid.crtc_id, dfb == NULL ? 0 : drmu_crtc_id(dp->dc));
+    drmu_atomic_add_prop_fb(da, plid, dp->pid.fb_id, dfb);
+    drmu_atomic_add_prop_value(da, plid, dp->pid.crtc_x, crtc_x);
+    drmu_atomic_add_prop_value(da, plid, dp->pid.crtc_y, crtc_y);
+    drmu_atomic_add_prop_range(da, plid, dp->pid.crtc_w, crtc_w);
+    drmu_atomic_add_prop_range(da, plid, dp->pid.crtc_h, crtc_h);
+    drmu_atomic_add_prop_value(da, plid, dp->pid.src_x,  src_x);
+    drmu_atomic_add_prop_value(da, plid, dp->pid.src_y,  src_y);
+    drmu_atomic_add_prop_range(da, plid, dp->pid.src_w,  src_w);
+    drmu_atomic_add_prop_range(da, plid, dp->pid.src_h,  src_h);
+    return 0;
+}
+
+int
+drmu_atomic_plane_add_alpha(struct drmu_atomic_s * const da, const drmu_plane_t * const dp, const int alpha)
+{
+    if (alpha == DRMU_PLANE_ALPHA_UNSET)
+        return 0;
+    return drmu_atomic_add_prop_range(da, dp->plane.plane_id, dp->pid.alpha, alpha);
+}
+
+int
+drmu_atomic_plane_add_zpos(struct drmu_atomic_s * const da, const drmu_plane_t * const dp, const int zpos)
+{
+    return drmu_atomic_add_prop_range(da, dp->plane.plane_id, dp->pid.zpos, zpos);
+}
+
+int
+drmu_atomic_plane_add_rotation(struct drmu_atomic_s * const da, const drmu_plane_t * const dp, const int rot)
+{
+    if (!dp->pid.rotation)
+        return rot == DRMU_ROTATION_0 ? 0 : -EINVAL;
+    if (rot < 0 || rot >= 8 || !dp->rot_vals[rot])
+        return -EINVAL;
+    return drmu_atomic_add_prop_bitmask(da, dp->plane.plane_id, dp->pid.rotation, dp->rot_vals[rot]);
+}
+
+int
+drmu_atomic_plane_add_chroma_siting(struct drmu_atomic_s * const da, const drmu_plane_t * const dp, const drmu_chroma_siting_t siting)
+{
+    int rv = 0;
+
+    if (!dp->pid.chroma_siting_h || !dp->pid.chroma_siting_v)
+        return -ENOENT;
+
+    if (!drmu_chroma_siting_eq(siting, DRMU_CHROMA_SITING_UNSPECIFIED)) {
+        const uint32_t plid = dp->plane.plane_id;
+        rv = drmu_atomic_add_prop_range(da, plid, dp->pid.chroma_siting_h, siting.x);
+        rv = rvup(rv, drmu_atomic_add_prop_range(da, plid, dp->pid.chroma_siting_v, siting.y));
+    }
+    return rv;
+}
+
+int
+drmu_atomic_plane_clear_add(drmu_atomic_t * const da, drmu_plane_t * const dp)
+{
+    return plane_set_atomic(da, dp, NULL,
+                            0, 0, 0, 0,
+                            0, 0, 0, 0);
+}
+
+int
+drmu_atomic_plane_add_fb(drmu_atomic_t * const da, drmu_plane_t * const dp,
+    drmu_fb_t * const dfb, const drmu_rect_t pos)
+{
+    int rv;
+    const uint32_t plid = dp->plane.plane_id;
+
+    if (dfb == NULL)
+        return drmu_atomic_plane_clear_add(da, dp);
+
+    if ((rv = plane_set_atomic(da, dp, dfb,
+                              pos.x, pos.y,
+                              pos.w, pos.h,
+                              dfb->crop.x + (dfb->active.x << 16), dfb->crop.y + (dfb->active.y << 16),
+                              dfb->crop.w, dfb->crop.h)) != 0)
+        return rv;
+
+    drmu_atomic_add_prop_enum(da, plid, dp->pid.pixel_blend_mode, dfb->pixel_blend_mode);
+    drmu_atomic_add_prop_enum(da, plid, dp->pid.color_encoding,   dfb->color_encoding);
+    drmu_atomic_add_prop_enum(da, plid, dp->pid.color_range,      dfb->color_range);
+    drmu_atomic_plane_add_chroma_siting(da, dp, dfb->chroma_siting);
+    return 0;
+}
+
+uint32_t
+drmu_plane_id(const drmu_plane_t * const dp)
+{
+    return dp->plane.plane_id;
+}
+
+unsigned int
+drmu_plane_type(const drmu_plane_t * const dp)
+{
+    return dp->plane_type;
+}
+
+const uint32_t *
+drmu_plane_formats(const drmu_plane_t * const dp, unsigned int * const pCount)
+{
+    *pCount = dp->fmts_hdr->count_formats;
+    return (const uint32_t *)((const uint8_t *)dp->formats_in + dp->fmts_hdr->formats_offset);
+}
+
+unsigned int
+drmu_plane_rotation_mask(const drmu_plane_t * const dp)
+{
+    return dp->rot_mask;
+}
+
+bool
+drmu_plane_rotation_valid(const drmu_plane_t * const dp, const unsigned int rot)
+{
+    return drmu_rotation_is_valid(rot) && ((dp->rot_mask >> rot) & 1) != 0;
+}
+
+bool
+drmu_plane_format_check(const drmu_plane_t * const dp, const uint32_t format, const uint64_t modifier)
+{
+    const struct drm_format_modifier * const mods = (const struct drm_format_modifier *)((const uint8_t *)dp->formats_in + dp->fmts_hdr->modifiers_offset);
+    const uint32_t * const fmts = (const uint32_t *)((const uint8_t *)dp->formats_in + dp->fmts_hdr->formats_offset);
+    uint64_t modbase = modifier;
+    unsigned int i;
+
+    if (!format)
+        return false;
+
+    // If broadcom then remove parameters before checking
+    if ((modbase >> 56) == DRM_FORMAT_MOD_VENDOR_BROADCOM)
+        modbase = fourcc_mod_broadcom_mod(modbase);
+
+    // * Simplistic lookup; Could be made much faster
+
+    for (i = 0; i != dp->fmts_hdr->count_modifiers; ++i) {
+        const struct drm_format_modifier * const mod = mods + i;
+        uint64_t fbits;
+        unsigned int j;
+
+        if (mod->modifier != modbase)
+            continue;
+
+        for (fbits = mod->formats, j = mod->offset; fbits; fbits >>= 1, ++j) {
+            if ((fbits & 1) != 0 && fmts[j] == format)
+                return true;
+        }
+    }
+    return false;
+}
+
+bool
+drmu_plane_is_claimed(drmu_plane_t * const dp)
+{
+    return atomic_load(&dp->ref_count) != 0;
+}
+
+void
+drmu_plane_unref(drmu_plane_t ** const ppdp)
+{
+    drmu_plane_t * const dp = *ppdp;
+
+    if (dp == NULL)
+        return;
+    *ppdp = NULL;
+
+    if (atomic_fetch_sub(&dp->ref_count, 1) != 2)
+        return;
+    dp->dc = NULL;
+    atomic_store(&dp->ref_count, 0);
+}
+
+drmu_plane_t *
+drmu_plane_ref(drmu_plane_t * const dp)
+{
+    if (dp)
+        atomic_fetch_add(&dp->ref_count, 1);
+    return dp;
+}
+
+static int
+plane_state_save(drmu_env_t * const du, drmu_plane_t * const dp)
+{
+    int rv = 0;
+
+    // 1st time through save state
+    if (!dp->saved &&
+        (rv = env_object_state_save(du, drmu_plane_id(dp), DRM_MODE_OBJECT_PLANE)) == 0)
+        dp->saved = true;
+    return rv;
+}
+
+// Associate a plane with a crtc and ref it
+// Returns -EBUSY if plane already associated
+int
+drmu_plane_ref_crtc(drmu_plane_t * const dp, drmu_crtc_t * const dc)
+{
+    drmu_env_t * const du = dp->du;
+
+    int ref0 = 0;
+    if (!atomic_compare_exchange_strong(&dp->ref_count, &ref0, 2))
+        return -EBUSY;
+    dp->dc = dc;
+
+    // 1st time through save state if required - ignore fail
+    plane_state_save(du, dp);
+
+    return 0;
+}
+
+drmu_plane_t *
+drmu_plane_new_find_ref(drmu_crtc_t * const dc, const drmu_plane_new_find_ok_fn cb, void * const v)
+{
+    uint32_t i;
+    drmu_env_t * const du = drmu_crtc_env(dc);
+    drmu_plane_t * dp = NULL;
+    drmu_plane_t * dp_t;
+    const uint32_t crtc_mask = (uint32_t)1 << drmu_crtc_idx(dc);
+
+    for (i = 0; (dp_t = drmu_env_plane_find_n(du, i)) != NULL; ++i) {
+        // Is unused?
+        // Availible for this crtc?
+        if (dp_t->dc != NULL ||
+            (dp_t->plane.possible_crtcs & crtc_mask) == 0)
+            continue;
+
+        if (cb(dp_t, v) && drmu_plane_ref_crtc(dp_t, dc) == 0) {
+            dp = dp_t;
+            break;
+        }
+    }
+    return dp;
+}
+
+static bool plane_find_type_cb(const drmu_plane_t * dp, void * v)
+{
+    const unsigned int * const pReq = v;
+    return (*pReq & drmu_plane_type(dp)) != 0;
+}
+
+drmu_plane_t *
+drmu_plane_new_find_ref_type(drmu_crtc_t * const dc, const unsigned int req_type)
+{
+    drmu_env_t * const du = drmu_crtc_env(dc);
+    drmu_plane_t * const dp = drmu_plane_new_find_ref(dc, plane_find_type_cb, (void*)&req_type);
+    if (dp == NULL) {
+        drmu_err(du, "%s: No plane found for types %#x", __func__, req_type);
+        return NULL;
+    }
+    return dp;
+}
+
+static void
+plane_uninit(drmu_plane_t * const dp)
+{
+    drmu_prop_range_delete(&dp->pid.crtc_h);
+    drmu_prop_range_delete(&dp->pid.crtc_w);
+    drmu_prop_range_delete(&dp->pid.src_h);
+    drmu_prop_range_delete(&dp->pid.src_w);
+    drmu_prop_range_delete(&dp->pid.alpha);
+    drmu_prop_range_delete(&dp->pid.chroma_siting_h);
+    drmu_prop_range_delete(&dp->pid.chroma_siting_v);
+    drmu_prop_enum_delete(&dp->pid.color_encoding);
+    drmu_prop_enum_delete(&dp->pid.color_range);
+    drmu_prop_enum_delete(&dp->pid.pixel_blend_mode);
+    drmu_prop_enum_delete(&dp->pid.rotation);
+    drmu_prop_range_delete(&dp->pid.zpos);
+    free(dp->formats_in);
+    dp->formats_in = NULL;
+}
+
+
+static int
+plane_init(drmu_env_t * const du, drmu_plane_t * const dp, const uint32_t plane_id)
+{
+    drmu_props_t *props;
+    int rv;
+
+    memset(dp, 0, sizeof(*dp));
+    dp->du = du;
+
+    dp->plane.plane_id = plane_id;
+    if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_GETPLANE, &dp->plane)) != 0) {
+        drmu_err(du, "%s: drmModeGetPlane failed: %s", __func__, strerror(-rv));
+        return rv;
+    }
+
+    if ((props = props_new(du, dp->plane.plane_id, DRM_MODE_OBJECT_PLANE)) == NULL)
+        return -EINVAL;
+
+#if TRACE_PROP_NEW
+    drmu_info(du, "Plane id %d: (CRTC %#x, FB %#x, Possible CRTCs %#x)",
+              plane_id, dp->plane.crtc_id, dp->plane.fb_id, dp->plane.possible_crtcs);
+    props_dump(props);
+#endif
+
+    if ((dp->pid.crtc_id = props_name_to_id(props, "CRTC_ID")) == 0 ||
+        (dp->pid.fb_id  = props_name_to_id(props, "FB_ID")) == 0 ||
+        (dp->pid.crtc_h = drmu_prop_range_new(du, props_name_to_id(props, "CRTC_H"))) == NULL ||
+        (dp->pid.crtc_w = drmu_prop_range_new(du, props_name_to_id(props, "CRTC_W"))) == NULL ||
+        (dp->pid.crtc_x = props_name_to_id(props, "CRTC_X")) == 0 ||
+        (dp->pid.crtc_y = props_name_to_id(props, "CRTC_Y")) == 0 ||
+        (dp->pid.src_h  = drmu_prop_range_new(du, props_name_to_id(props, "SRC_H"))) == NULL ||
+        (dp->pid.src_w  = drmu_prop_range_new(du, props_name_to_id(props, "SRC_W"))) == NULL ||
+        (dp->pid.src_x  = props_name_to_id(props, "SRC_X")) == 0 ||
+        (dp->pid.src_y  = props_name_to_id(props, "SRC_Y")) == 0 ||
+        props_name_get_blob(props, "IN_FORMATS", &dp->formats_in, &dp->formats_in_len) != 0)
+    {
+        drmu_err(du, "%s: failed to find required id", __func__);
+        props_free(props);
+        return -EINVAL;
+    }
+    dp->fmts_hdr = dp->formats_in;
+
+    dp->pid.alpha            = drmu_prop_range_new(du, props_name_to_id(props, "alpha"));
+    dp->pid.color_encoding   = drmu_prop_enum_new(du, props_name_to_id(props, "COLOR_ENCODING"));
+    dp->pid.color_range      = drmu_prop_enum_new(du, props_name_to_id(props, "COLOR_RANGE"));
+    dp->pid.pixel_blend_mode = drmu_prop_enum_new(du, props_name_to_id(props, "pixel blend mode"));
+    dp->pid.rotation         = drmu_prop_enum_new(du, props_name_to_id(props, "rotation"));
+    dp->pid.chroma_siting_h  = drmu_prop_range_new(du, props_name_to_id(props, "CHROMA_SITING_H"));
+    dp->pid.chroma_siting_v  = drmu_prop_range_new(du, props_name_to_id(props, "CHROMA_SITING_V"));
+    dp->pid.zpos             = drmu_prop_range_new(du, props_name_to_id(props, "zpos"));
+
+    dp->rot_mask = rotation_make_array(dp->pid.rotation, dp->rot_vals);
+
+    {
+        const drmu_propinfo_t * const pinfo = props_name_to_propinfo(props, "type");
+        drmu_prop_enum_t * etype = drmu_prop_enum_new(du, props_name_to_id(props, "type"));
+        const uint64_t * p;
+
+        if ((p = drmu_prop_enum_value(etype, "Primary")) && *p == pinfo->val)
+            dp->plane_type = DRMU_PLANE_TYPE_PRIMARY;
+        else if ((p = drmu_prop_enum_value(etype, "Cursor")) && *p == pinfo->val)
+            dp->plane_type = DRMU_PLANE_TYPE_CURSOR;
+        else if ((p = drmu_prop_enum_value(etype, "Overlay")) && *p == pinfo->val)
+            dp->plane_type = DRMU_PLANE_TYPE_OVERLAY;
+        else {
+            drmu_debug(du, "Unexpected plane type: %"PRId64, pinfo->val);
+            dp->plane_type = DRMU_PLANE_TYPE_UNKNOWN;
+        }
+        drmu_prop_enum_delete(&etype);
+    }
+
+    props_free(props);
+    return 0;
+}
+
+//----------------------------------------------------------------------------
+//
+// Env fns
+
+typedef struct drmu_env_s {
+    atomic_int ref_count;  // 0 == 1 ref for ease of init
+    bool kill;
+    int fd;
+    uint32_t plane_count;
+    uint32_t conn_count;
+    uint32_t crtc_count;
+    drmu_plane_t * planes;
+    drmu_conn_t * conns;
+    drmu_crtc_t * crtcs;
+
+    drmu_log_env_t log;
+
+    pthread_mutex_t lock;
+
+    // global env for bo tracking
+    drmu_bo_env_t boe;
+    // global atomic for restore op
+    drmu_atomic_t * da_restore;
+
+    struct drmu_queue_s * poll_env;
+    drmu_poll_destroy_fn poll_destroy;
+
+    drmu_env_post_delete_fn post_delete_fn;
+    void * post_delete_v;
+} drmu_env_t;
+
+// Retrieve the the n-th conn
+// Use for iteration
+// Returns NULL when none left
+drmu_crtc_t *
+drmu_env_crtc_find_n(drmu_env_t * const du, const unsigned int n)
+{
+    return n >= du->crtc_count ? NULL : du->crtcs + n;
+}
+
+// Retrieve the the n-th conn
+// Use for iteration
+// Returns NULL when none left
+drmu_conn_t *
+drmu_env_conn_find_n(drmu_env_t * const du, const unsigned int n)
+{
+    return n >= du->conn_count ? NULL : du->conns + n;
+}
+
+drmu_plane_t *
+drmu_env_plane_find_n(drmu_env_t * const du, const unsigned int n)
+{
+    return n >= du->plane_count ? NULL : du->planes + n;
+}
+
+int
+drmu_ioctl(const drmu_env_t * const du, unsigned long req, void * arg)
+{
+    while (ioctl(du->fd, req, arg)) {
+        const int err = errno;
+        // DRM docn suggests we should try again on EAGAIN as well as EINTR
+        // and drm userspace does this.
+        if (err != EINTR && err != EAGAIN)
+            return -err;
+    }
+    return 0;
+}
+
+static void
+env_free_planes(drmu_env_t * const du)
+{
+    uint32_t i;
+    for (i = 0; i != du->plane_count; ++i)
+        plane_uninit(du->planes + i);
+    free(du->planes);
+    du->plane_count = 0;
+    du->planes = NULL;
+}
+
+static void
+env_free_conns(drmu_env_t * const du)
+{
+    uint32_t i;
+    for (i = 0; i != du->conn_count; ++i)
+        conn_uninit(du->conns + i);
+    free(du->conns);
+    du->conn_count = 0;
+    du->conns = NULL;
+}
+
+static void
+env_free_crtcs(drmu_env_t * const du)
+{
+    uint32_t i;
+    for (i = 0; i != du->crtc_count; ++i)
+        crtc_uninit(du->crtcs + i);
+    free(du->crtcs);
+    du->crtc_count = 0;
+    du->crtcs = NULL;
+}
+
+
+static int
+env_planes_populate(drmu_env_t * const du, unsigned int n, const uint32_t * const ids)
+{
+    uint32_t i;
+    int rv;
+
+    if ((du->planes = calloc(n, sizeof(*du->planes))) == NULL) {
+        drmu_err(du, "Plane array alloc failed");
+        return -ENOMEM;
+    }
+
+    for (i = 0; i != n; ++i) {
+        if ((rv = plane_init(du, du->planes + i, ids[i])) != 0)
+            goto fail2;
+        du->plane_count = i + 1;
+    }
+    return 0;
+
+fail2:
+    env_free_planes(du);
+    return rv;
+}
+
+// Doesn't clean up on error - assumes that env construction will abort and
+// that will tidy up for us
+static int
+env_conn_populate(drmu_env_t * const du, unsigned int n, const uint32_t * const ids)
+{
+    unsigned int i;
+    int rv;
+
+    if (n == 0) {
+        drmu_err(du, "No connectors");
+        return -EINVAL;
+    }
+
+    if ((du->conns = calloc(n, sizeof(*du->conns))) == NULL) {
+        drmu_err(du, "Failed to malloc conns");
+        return -ENOMEM;
+    }
+
+    for (i = 0; i != n; ++i) {
+        if ((rv = conn_init(du, du->conns + i, i, ids[i])) != 0)
+            return rv;
+        du->conn_count = i + 1;
+    }
+
+    return 0;
+}
+
+static int
+env_crtc_populate(drmu_env_t * const du, unsigned int n, const uint32_t * const ids)
+{
+    unsigned int i;
+    int rv;
+
+    if (n == 0) {
+        drmu_err(du, "No crtcs");
+        return -EINVAL;
+    }
+
+    if ((du->crtcs = malloc(n * sizeof(*du->crtcs))) == NULL) {
+        drmu_err(du, "Failed to malloc conns");
+        return -ENOMEM;
+    }
+
+    for (i = 0; i != n; ++i) {
+        if ((rv = crtc_init(du, du->crtcs + i, i, ids[i])) != 0)
+            return rv;
+        du->crtc_count = i + 1;
+    }
+
+    return 0;
+}
+
+
+
+int
+drmu_fd(const drmu_env_t * const du)
+{
+    return du->fd;
+}
+
+const struct drmu_log_env_s *
+drmu_env_log(const drmu_env_t * const du)
+{
+    return &du->log;
+}
+
+static struct drmu_bo_env_s *
+env_boe(drmu_env_t * const du)
+{
+    return &du->boe;
+}
+
+static void
+env_restore(drmu_env_t * const du)
+{
+    int rv;
+    drmu_atomic_t * bad = drmu_atomic_new(du);
+    if (drmu_atomic_commit_test(du->da_restore, DRM_MODE_ATOMIC_ALLOW_MODESET, bad) != 0) {
+        drmu_atomic_sub(du->da_restore, bad);
+        if ((rv = drmu_atomic_commit(du->da_restore, DRM_MODE_ATOMIC_ALLOW_MODESET)) != 0)
+            drmu_err(du, "Failed to restore old mode on exit: %s", strerror(-rv));
+        else
+            drmu_err(du, "Failed to completely restore old mode on exit");
+
+        if (drmu_env_log(du)->max_level >= DRMU_LOG_LEVEL_DEBUG)
+            drmu_atomic_dump(bad);
+    }
+    drmu_atomic_unref(&bad);
+    drmu_atomic_unref(&du->da_restore);
+}
+
+void
+drmu_env_int_restore(drmu_env_t * const du)
+{
+    if (du->da_restore != NULL)
+        env_restore(du);
+}
+
+static void
+env_free(drmu_env_t * const du)
+{
+    if (!du)
+        return;
+
+    if (du->poll_env)
+        du->poll_destroy(&du->poll_env, du);
+    drmu_env_int_restore(du);
+
+    env_free_planes(du);
+    env_free_conns(du);
+    env_free_crtcs(du);
+    drmu_bo_env_uninit(&du->boe);
+    pthread_mutex_destroy(&du->lock);
+
+    {
+        void * const post_delete_v = du->post_delete_v;
+        const drmu_env_post_delete_fn post_delete_fn = du->post_delete_fn;
+        const int fd = du->fd;
+        free(du);
+        post_delete_fn(post_delete_v, fd);
+    }
+}
+
+void
+drmu_env_unref(drmu_env_t ** const ppdu)
+{
+    drmu_env_t * const du = *ppdu;
+    int n;
+
+    if (!du)
+        return;
+    *ppdu = NULL;
+
+    n = atomic_fetch_sub(&du->ref_count, 1);
+    assert(n >= 0);
+    if (n == 0)
+        env_free(du);
+}
+
+// Kill the Q
+void
+drmu_env_kill(drmu_env_t ** const ppdu)
+{
+    drmu_env_t * du = *ppdu;
+    struct drmu_queue_s * pe;
+    bool old_kill;
+
+    if (!du)
+        return;
+    *ppdu = NULL;
+
+    pthread_mutex_lock(&du->lock);
+    old_kill = du->kill;
+    pe = du->poll_env;
+    du->kill = true;
+    du->poll_env = NULL;
+    pthread_mutex_unlock(&du->lock);
+
+    if (!old_kill) {
+        // Only do these once and only outside env lock
+        if (pe != NULL)
+            du->poll_destroy(&pe, du);
+
+         // If we had a poll env this should have already been done, if it has
+         // already been done this is a noop
+         drmu_env_int_restore(du);
+    }
+
+    drmu_env_unref(&du);
+}
+
+drmu_env_t *
+drmu_env_ref(drmu_env_t * const du)
+{
+    if (du)
+        atomic_fetch_add(&du->ref_count, 1);
+    return du;
+}
+
+static int
+env_object_state_save(drmu_env_t * const du, const uint32_t obj_id, const uint32_t obj_type)
+{
+    drmu_props_t * props;
+    drmu_atomic_t * da;
+    int rv;
+
+    if (!du->da_restore)
+        return -EINVAL;
+
+    if ((props = props_new(du, obj_id, obj_type)) == NULL)
+        return -ENOENT;
+
+    if ((da = drmu_atomic_new(du)) == NULL) {
+        rv = -ENOMEM;
+        goto fail;
+    }
+
+    if ((rv = drmu_atomic_props_add_save(da, obj_id, props)) != 0)
+        goto fail;
+
+    props_free(props);
+    return drmu_atomic_env_restore_add_snapshot(&da);
+
+fail:
+    if (props)
+        props_free(props);
+    return rv;
+}
+
+int
+drmu_env_restore_enable(drmu_env_t * const du)
+{
+    uint32_t i;
+
+    if (du->da_restore)
+        return 0;
+    if ((du->da_restore = drmu_atomic_new(du)) == NULL)
+        return -ENOMEM;
+
+    // Save state of anything already claimed
+    // Cannot rewind time but this allows us to be a bit lax with the
+    // precise ordering of calls on setup (which is handy for scan)
+    for (i = 0; i != du->conn_count; ++i)
+        if (drmu_conn_is_claimed(du->conns + i))
+            conn_state_save(du, du->conns + i);
+    for (i = 0; i != du->crtc_count; ++i)
+        if (drmu_crtc_is_claimed(du->crtcs + i))
+            crtc_state_save(du, du->crtcs + i);
+    for (i = 0; i != du->plane_count; ++i)
+        if (drmu_plane_is_claimed(du->planes + i))
+            plane_state_save(du, du->planes + i);
+
+    return 0;
+}
+
+bool
+drmu_env_restore_is_enabled(const drmu_env_t * const du)
+{
+    return du->da_restore != NULL;
+}
+
+int
+drmu_atomic_env_restore_add_snapshot(drmu_atomic_t ** const ppda)
+{
+    drmu_atomic_t * da = *ppda;
+    drmu_atomic_t * fails = NULL;
+    drmu_env_t * const du = drmu_atomic_env(da);
+
+    *ppda = NULL;
+
+    if (!du || !du->da_restore) {
+        drmu_atomic_unref(&da);
+        return 0;
+    }
+
+    // Lose anything we can't restore
+    fails = drmu_atomic_new(du);
+    if (drmu_atomic_commit_test(da, DRM_MODE_ATOMIC_ALLOW_MODESET | DRM_MODE_ATOMIC_TEST_ONLY, fails) != 0)
+        drmu_atomic_sub(da, fails);
+    drmu_atomic_unref(&fails);
+
+    return drmu_atomic_merge(du->da_restore, &da);
+}
+
+static int
+env_set_client_cap(drmu_env_t * const du, uint64_t cap_id, uint64_t cap_val)
+{
+    struct drm_set_client_cap cap = {
+        .capability = cap_id,
+        .value = cap_val
+    };
+    return drmu_ioctl(du, DRM_IOCTL_SET_CLIENT_CAP, &cap);
+}
+
+int
+drmu_env_int_poll_set(drmu_env_t * const du,
+                  const drmu_poll_new_fn new_fn, const drmu_poll_destroy_fn destroy_fn,
+                  struct drmu_queue_s ** const ppPe)
+{
+    int rv = 0;
+
+    if (du == NULL)
+        return -EINVAL;
+
+    pthread_mutex_lock(&du->lock);
+    if (du->kill) {
+        rv = -EBUSY;
+    }
+    else if (du->poll_env == NULL) {
+        du->poll_destroy = destroy_fn;
+        if ((du->poll_env = new_fn(du)) == NULL)
+            rv = -ENOMEM;
+    }
+    *ppPe = du->poll_env;
+    pthread_mutex_unlock(&du->lock);
+
+    if (rv == -ENOMEM)
+        drmu_err(du, "Failed to create poll env");
+
+    return rv;
+}
+
+struct drmu_queue_s *
+drmu_env_int_poll_get(drmu_env_t * const du)
+{
+    struct drmu_queue_s * pe;
+    pthread_mutex_lock(&du->lock);
+    pe = du->poll_env;
+    pthread_mutex_unlock(&du->lock);
+    return pe;
+}
+
+// Closes fd on failure
+drmu_env_t *
+drmu_env_new_fd2(const int fd, const struct drmu_log_env_s * const log,
+                 drmu_env_post_delete_fn post_delete_fn, void * post_delete_v)
+{
+    drmu_env_t * const du = calloc(1, sizeof(*du));
+    int rv;
+    uint32_t * conn_ids = NULL;
+    uint32_t * crtc_ids = NULL;
+    uint32_t * plane_ids = NULL;
+
+    if (!du) {
+        drmu_err_log(log, "Failed to create du: No memory");
+        post_delete_fn(post_delete_v, fd);
+        return NULL;
+    }
+
+    du->log = (log == NULL) ? drmu_log_env_none : *log;
+    du->fd = fd;
+    du->post_delete_fn = post_delete_fn;
+    du->post_delete_v = post_delete_v;
+
+    pthread_mutex_init(&du->lock, NULL);
+    drmu_bo_env_init(&du->boe);
+
+    // We need atomic for almost everything we do
+    if (env_set_client_cap(du, DRM_CLIENT_CAP_ATOMIC, 1) != 0) {
+        drmu_err(du, "Failed to set atomic cap");
+        goto fail1;
+    }
+    // We want the primary plane for video
+    if (env_set_client_cap(du, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1) != 0)
+        drmu_debug(du, "Failed to set universal planes cap");
+    // We can understand AR info
+    if (env_set_client_cap(du, DRM_CLIENT_CAP_ASPECT_RATIO, 1) != 0)
+        drmu_debug(du, "Failed to set AR cap");
+    // We would like to see writeback connectors
+    if (env_set_client_cap(du, DRM_CLIENT_CAP_WRITEBACK_CONNECTORS, 1) != 0)
+        drmu_debug(du, "Failed to set writeback cap");
+
+    {
+        struct drm_mode_get_plane_res res;
+        uint32_t req_planes = 0;
+
+        do {
+            memset(&res, 0, sizeof(res));
+            res.plane_id_ptr     = (uintptr_t)plane_ids;
+            res.count_planes     = req_planes;
+
+            if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_GETPLANERESOURCES, &res)) != 0) {
+                drmu_err(du, "Failed to get resources: %s", strerror(-rv));
+                goto fail1;
+            }
+        } while ((rv = retry_alloc_u32(&plane_ids, &req_planes, res.count_planes)) == 1);
+        if (rv < 0)
+            goto fail1;
+
+        if (env_planes_populate(du, res.count_planes, plane_ids) != 0)
+            goto fail1;
+
+        free(plane_ids);
+        plane_ids = NULL;
+    }
+
+    {
+        struct drm_mode_card_res res;
+        uint32_t req_conns = 0;
+        uint32_t req_crtcs = 0;
+
+        for (;;) {
+            memset(&res, 0, sizeof(res));
+            res.crtc_id_ptr      = (uintptr_t)crtc_ids;
+            res.connector_id_ptr = (uintptr_t)conn_ids;
+            res.count_crtcs      = req_crtcs;
+            res.count_connectors = req_conns;
+
+            if ((rv = drmu_ioctl(du, DRM_IOCTL_MODE_GETRESOURCES, &res)) != 0) {
+                drmu_err(du, "Failed to get resources: %s", strerror(-rv));
+                goto fail1;
+            }
+
+            if (res.count_crtcs <= req_crtcs && res.count_connectors <= req_conns)
+                break;
+
+            if (retry_alloc_u32(&conn_ids, &req_conns, res.count_connectors) < 0 ||
+                retry_alloc_u32(&crtc_ids, &req_crtcs, res.count_crtcs) < 0)
+                goto fail1;
+        }
+
+        if (env_conn_populate(du, res.count_connectors, conn_ids) != 0)
+            goto fail1;
+        if (env_crtc_populate(du, res.count_crtcs,      crtc_ids) != 0)
+            goto fail1;
+
+        free(conn_ids);
+        free(crtc_ids);
+        conn_ids = NULL;
+        crtc_ids = NULL;
+    }
+
+    free(plane_ids);
+    return du;
+
+fail1:
+    env_free(du);
+    free(conn_ids);
+    free(crtc_ids);
+    free(plane_ids);
+    return NULL;
+}
+
+static void
+env_post_delete_close_cb(void * v, int fd)
+{
+    (void)v;
+    close(fd);
+}
+
+drmu_env_t *
+drmu_env_new_fd(const int fd, const struct drmu_log_env_s * const log)
+{
+    return drmu_env_new_fd2(fd, log, env_post_delete_close_cb, NULL);
+}
+
+// * As the only remaining libdrm code dependency this should maybe be evicted
+// * to its own file
+drmu_env_t *
+drmu_env_new_open(const char * name, const struct drmu_log_env_s * const log2)
+{
+    const struct drmu_log_env_s * const log = (log2 == NULL) ? &drmu_log_env_none : log2;
+    int fd = drmOpen(name, NULL);
+    if (fd == -1) {
+        drmu_err_log(log, "Failed to open %s", name);
+        return NULL;
+    }
+    return drmu_env_new_fd(fd, log);
+}
+
+//----------------------------------------------------------------------------
+//
+// Logging
+
+static void
+log_none_cb(void * v, enum drmu_log_level_e level, const char * fmt, va_list vl)
+{
+    (void)v;
+    (void)level;
+    (void)fmt;
+    (void)vl;
+}
+
+const struct drmu_log_env_s drmu_log_env_none = {
+    .fn = log_none_cb,
+    .v = NULL,
+    .max_level = DRMU_LOG_LEVEL_NONE
+};
+
+void
+drmu_log_generic(const struct drmu_log_env_s * const log, const enum drmu_log_level_e level,
+                 const char * const fmt, ...)
+{
+    va_list vl;
+    va_start(vl, fmt);
+    log->fn(log->v, level, fmt, vl);
+    va_end(vl);
+}
+
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu.h
@@ -0,0 +1,703 @@
+#ifndef _DRMU_DRMU_H
+#define _DRMU_DRMU_H
+
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#include "drmu_chroma.h"
+#include "drmu_math.h"
+
+// Maybe this shoudl not be included?
+#include "drmu_poll.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct drmu_blob_s;
+typedef struct drmu_blob_s drmu_blob_t;
+
+struct drmu_prop_enum_s;
+typedef struct drmu_prop_enum_s drmu_prop_enum_t;
+
+struct drmu_prop_range_s;
+typedef struct drmu_prop_range_s drmu_prop_range_t;
+
+struct drmu_bo_s;
+typedef struct drmu_bo_s drmu_bo_t;
+struct drmu_bo_env_s;
+typedef struct drmu_bo_env_s drmu_bo_env_t;
+
+struct drmu_fb_s;
+typedef struct drmu_fb_s drmu_fb_t;
+
+struct drmu_prop_object_s;
+typedef struct drmu_prop_object_s drmu_prop_object_t;
+
+struct drmu_crtc_s;
+typedef struct drmu_crtc_s drmu_crtc_t;
+
+struct drmu_conn_s;
+typedef struct drmu_conn_s drmu_conn_t;
+
+struct drmu_plane_s;
+typedef struct drmu_plane_s drmu_plane_t;
+
+struct drmu_atomic_s;
+
+struct drmu_env_s;
+typedef struct drmu_env_s drmu_env_t;
+
+struct drm_log_env_s;
+typedef struct drmu_log_env_s drmu_log_env_t;
+
+// HDR enums is copied from linux include/linux/hdmi.h (strangely not part of uapi)
+enum hdmi_metadata_type
+{
+    HDMI_STATIC_METADATA_TYPE1 = 0,
+};
+enum hdmi_eotf
+{
+    HDMI_EOTF_TRADITIONAL_GAMMA_SDR,
+    HDMI_EOTF_TRADITIONAL_GAMMA_HDR,
+    HDMI_EOTF_SMPTE_ST2084,
+    HDMI_EOTF_BT_2100_HLG,
+};
+
+typedef enum drmu_isset_e {
+    DRMU_ISSET_UNSET = 0,  // Thing unset
+    DRMU_ISSET_NULL,       // Thing is empty
+    DRMU_ISSET_SET,        // Thing has valid data
+} drmu_isset_t;
+
+// Blob
+
+void drmu_blob_unref(drmu_blob_t ** const ppBlob);
+uint32_t drmu_blob_id(const drmu_blob_t * const blob);
+// blob data & length
+const void * drmu_blob_data(const drmu_blob_t * const blob);
+size_t drmu_blob_len(const drmu_blob_t * const blob);
+
+drmu_blob_t * drmu_blob_ref(drmu_blob_t * const blob);
+// Make a new blob - keeps a copy of the data
+drmu_blob_t * drmu_blob_new(drmu_env_t * const du, const void * const data, const size_t len);
+// Update a blob with new data
+// Creates if it didn't exist before, unrefs if data NULL
+int drmu_blob_update(drmu_env_t * const du, drmu_blob_t ** const ppblob, const void * const data, const size_t len);
+// Create a new blob from an existing blob_id
+drmu_blob_t * drmu_blob_copy_id(drmu_env_t * const du, uint32_t blob_id);
+int drmu_atomic_add_prop_blob(struct drmu_atomic_s * const da, const uint32_t obj_id, const uint32_t prop_id, drmu_blob_t * const blob);
+
+// Enum & bitmask
+// These are very close to the same thing so we use the same struct
+typedef drmu_prop_enum_t drmu_prop_bitmask_t;
+
+// Ptr to value of the named enum/bit, NULL if not found or pen == NULL. If bitmask then bit number
+const uint64_t * drmu_prop_enum_value(const drmu_prop_enum_t * const pen, const char * const name);
+// Bitmask only - value as a (single-bit) bitmask - 0 if not found or not bitmask or pen == NULL
+uint64_t drmu_prop_bitmask_value(const drmu_prop_enum_t * const pen, const char * const name);
+
+uint32_t drmu_prop_enum_id(const drmu_prop_enum_t * const pen);
+#define drmu_prop_bitmask_id drmu_prop_enum_id
+void drmu_prop_enum_delete(drmu_prop_enum_t ** const pppen);
+#define drmu_prop_bitmask_delete drmu_prop_enum_delete
+drmu_prop_enum_t * drmu_prop_enum_new(drmu_env_t * const du, const uint32_t id);
+#define drmu_prop_bitmask_new drmu_prop_enum_new
+int drmu_atomic_add_prop_enum(struct drmu_atomic_s * const da, const uint32_t obj_id, const drmu_prop_enum_t * const pen, const char * const name);
+int drmu_atomic_add_prop_bitmask(struct drmu_atomic_s * const da, const uint32_t obj_id, const drmu_prop_enum_t * const pen, const uint64_t value);
+
+// Range
+
+void drmu_prop_range_delete(drmu_prop_range_t ** pppra);
+bool drmu_prop_range_validate(const drmu_prop_range_t * const pra, const uint64_t x);
+bool drmu_prop_range_immutable(const drmu_prop_range_t * const pra);
+uint64_t drmu_prop_range_max(const drmu_prop_range_t * const pra);
+uint64_t drmu_prop_range_min(const drmu_prop_range_t * const pra);
+uint32_t drmu_prop_range_id(const drmu_prop_range_t * const pra);
+const char * drmu_prop_range_name(const drmu_prop_range_t * const pra);
+drmu_prop_range_t * drmu_prop_range_new(drmu_env_t * const du, const uint32_t id);
+int drmu_atomic_add_prop_range(struct drmu_atomic_s * const da, const uint32_t obj_id, const drmu_prop_range_t * const pra, const uint64_t x);
+
+// BO
+
+struct drm_mode_create_dumb;
+
+// Create an fd from a bo
+// fd not tracked by the bo so it is the callers reponsibility to free it
+// if flags are 0 then RDWR | CLOEXEC will be used
+int drmu_bo_export_fd(drmu_bo_t * bo, uint32_t flags);
+
+// Map a BO.
+// Size isn't saved in the BO so must be given here
+// Returns NULL on failure unlike system mmap
+// Mapping isn't held by the BO, must be umapped by user
+void * drmu_bo_mmap(const drmu_bo_t * const bo, const size_t length, const int prot, const int flags);
+
+// Get BO handle
+uint32_t drmu_bo_handle(const drmu_bo_t * const bo);
+
+void drmu_bo_unref(drmu_bo_t ** const ppbo);
+drmu_bo_t * drmu_bo_ref(drmu_bo_t * const bo);
+drmu_bo_t * drmu_bo_new_fd(drmu_env_t *const du, const int fd);
+drmu_bo_t * drmu_bo_new_dumb(drmu_env_t *const du, struct drm_mode_create_dumb * const d);
+drmu_bo_t * drmu_bo_new_external(drmu_env_t *const du, const uint32_t bo_handle);
+void drmu_bo_env_uninit(drmu_bo_env_t * const boe);
+void drmu_bo_env_init(drmu_bo_env_t * boe);
+
+// fb
+struct hdr_output_metadata;
+struct drmu_fmt_info_s;
+
+// Called pre delete.
+// Zero returned means continue delete.
+// Non-zero means stop delete - fb will have zero refs so will probably want a new ref
+//   before next use
+typedef int (* drmu_fb_pre_delete_fn)(struct drmu_fb_s * dfb, void * v);
+// Called after an fb has been deleted and therefore has ceased using any
+// user resources
+typedef void (* drmu_fb_on_delete_fn)(void * v);
+
+void drmu_fb_pre_delete_set(drmu_fb_t *const dfb, drmu_fb_pre_delete_fn fn, void * v);
+void drmu_fb_pre_delete_unset(drmu_fb_t *const dfb);
+unsigned int drmu_fb_pixel_bits(const drmu_fb_t * const dfb);
+uint32_t drmu_fb_pixel_format(const drmu_fb_t * const dfb);
+uint64_t drmu_fb_modifier(const drmu_fb_t * const dfb, const unsigned int plane);
+drmu_fb_t * drmu_fb_new_dumb(drmu_env_t * const du, uint32_t w, uint32_t h, const uint32_t format);
+drmu_fb_t * drmu_fb_new_dumb_mod(drmu_env_t * const du, uint32_t w, uint32_t h, const uint32_t format, const uint64_t mod);
+drmu_fb_t * drmu_fb_new_dumb_multi(drmu_env_t * const du, uint32_t w, uint32_t h,
+                     const uint32_t format, const uint64_t mod, const bool multi);
+drmu_fb_t * drmu_fb_realloc_dumb(drmu_env_t * const du, drmu_fb_t * dfb, uint32_t w, uint32_t h, const uint32_t format);
+drmu_fb_t * drmu_fb_realloc_dumb_mod(drmu_env_t * const du, drmu_fb_t * dfb, uint32_t w, uint32_t h, const uint32_t format, const uint64_t mod);
+// Try to reset geometry to these values
+// True if done, false if not
+bool drmu_fb_try_reuse(drmu_fb_t * dfb, uint32_t w, uint32_t h, const uint32_t format, const uint64_t mod);
+void drmu_fb_unref(drmu_fb_t ** const ppdfb);
+drmu_fb_t * drmu_fb_ref(drmu_fb_t * const dfb);
+
+#define DRMU_FB_PIXEL_BLEND_UNSET               NULL
+#define DRMU_FB_PIXEL_BLEND_PRE_MULTIPLIED      "Pre-multiplied"  // Default
+#define DRMU_FB_PIXEL_BLEND_COVERAGE            "Coverage"        // Not premultipled
+#define DRMU_FB_PIXEL_BLEND_NONE                "None"            // Ignore pixel alpha (opaque)
+int drmu_fb_pixel_blend_mode_set(drmu_fb_t *const dfb, const char * const mode);
+
+uint32_t drmu_fb_pitch(const drmu_fb_t *const dfb, const unsigned int layer);
+// Pitch2 is only a sand thing
+uint32_t drmu_fb_pitch2(const drmu_fb_t *const dfb, const unsigned int layer);
+void * drmu_fb_data(const drmu_fb_t *const dfb, const unsigned int layer);
+drmu_bo_t * drmu_fb_bo(const drmu_fb_t * const dfb, const unsigned int layer);
+// Allocated width height - may be rounded up from requested w/h
+uint32_t drmu_fb_width(const drmu_fb_t *const dfb);
+uint32_t drmu_fb_height(const drmu_fb_t *const dfb);
+// Set cropping (fractional) - x, y, relative to active x, y (and must be +ve)
+int drmu_fb_crop_frac_set(drmu_fb_t *const dfb, drmu_rect_t crop_frac);
+// get cropping (fractional 16.16) x, y relative to active area
+drmu_rect_t drmu_fb_crop_frac(const drmu_fb_t *const dfb);
+// get active area (all valid pixels - buffer can/will contain padding outside this)
+// rect in pixels (not fractional)
+drmu_rect_t drmu_fb_active(const drmu_fb_t *const dfb);
+
+int drmu_atomic_add_prop_fb(struct drmu_atomic_s * const da, const uint32_t obj_id, const uint32_t prop_id, drmu_fb_t * const dfb);
+
+// FB creation helpers - only use for creatino of new FBs
+drmu_fb_t * drmu_fb_int_alloc(drmu_env_t * const du);
+void drmu_fb_int_free(drmu_fb_t * const dfb);
+// Set size
+// w, h are buffer sizes, active is the valid pixel area inside that
+// crop will be set to the whole active area
+void drmu_fb_int_fmt_size_set(drmu_fb_t *const dfb, uint32_t fmt, uint32_t w, uint32_t h, const drmu_rect_t active);
+// All assumed to be const strings that do not need freed
+typedef const char * drmu_color_encoding_t;
+#define DRMU_COLOR_ENCODING_UNSET               NULL
+#define DRMU_COLOR_ENCODING_BT2020              "ITU-R BT.2020 YCbCr"
+#define DRMU_COLOR_ENCODING_BT709               "ITU-R BT.709 YCbCr"
+#define DRMU_COLOR_ENCODING_BT601               "ITU-R BT.601 YCbCr"
+static inline bool drmu_color_encoding_is_set(const drmu_color_encoding_t x) {return x != NULL;}
+// Note: Color range only applies to YCbCr planes - ignored for RGB
+typedef const char * drmu_color_range_t;
+#define DRMU_COLOR_RANGE_UNSET                  NULL
+#define DRMU_COLOR_RANGE_YCBCR_FULL_RANGE       "YCbCr full range"
+#define DRMU_COLOR_RANGE_YCBCR_LIMITED_RANGE    "YCbCr limited range"
+static inline bool drmu_color_range_is_set(const drmu_color_range_t x) {return x != NULL;}
+typedef const char * drmu_colorspace_t;
+#define DRMU_COLORSPACE_UNSET                   NULL
+#define DRMU_COLORSPACE_DEFAULT                 "Default"
+#define DRMU_COLORSPACE_BT2020_CYCC             "BT2020_CYCC"
+#define DRMU_COLORSPACE_BT2020_RGB              "BT2020_RGB"
+#define DRMU_COLORSPACE_BT2020_YCC              "BT2020_YCC"
+#define DRMU_COLORSPACE_BT709_YCC               "BT709_YCC"
+#define DRMU_COLORSPACE_DCI_P3_RGB_D65          "DCI-P3_RGB_D65"
+#define DRMU_COLORSPACE_DCI_P3_RGB_THEATER      "DCI-P3_RGB_Theater"
+#define DRMU_COLORSPACE_SMPTE_170M_YCC          "SMPTE_170M_YCC"
+#define DRMU_COLORSPACE_SYCC_601                "SYCC_601"
+#define DRMU_COLORSPACE_XVYCC_601               "XVYCC_601"
+#define DRMU_COLORSPACE_XVYCC_709               "XVYCC_709"
+static inline bool drmu_colorspace_is_set(const drmu_colorspace_t x) {return x != NULL;}
+typedef const char * drmu_broadcast_rgb_t;
+#define DRMU_BROADCAST_RGB_UNSET                NULL
+#define DRMU_BROADCAST_RGB_AUTOMATIC            "Automatic"
+#define DRMU_BROADCAST_RGB_FULL                 "Full"
+#define DRMU_BROADCAST_RGB_LIMITED_16_235       "Limited 16:235"
+static inline bool drmu_broadcast_rgb_is_set(const drmu_broadcast_rgb_t x) {return x != NULL;}
+void drmu_fb_color_set(drmu_fb_t *const dfb, const drmu_color_encoding_t enc, const drmu_color_range_t range, const drmu_colorspace_t space);
+void drmu_fb_chroma_siting_set(drmu_fb_t *const dfb, const drmu_chroma_siting_t siting);
+void drmu_fb_int_on_delete_set(drmu_fb_t *const dfb, drmu_fb_on_delete_fn fn, void * v);
+void drmu_fb_int_bo_set(drmu_fb_t *const dfb, const unsigned int obj_idx, drmu_bo_t * const bo);
+void drmu_fb_int_layer_set(drmu_fb_t *const dfb, unsigned int i, unsigned int obj_idx, uint32_t pitch, uint32_t offset);
+void drmu_fb_int_layer_mod_set(drmu_fb_t *const dfb, unsigned int i, unsigned int obj_idx, uint32_t pitch, uint32_t offset, uint64_t modifier);
+void drmu_fb_int_fd_set(drmu_fb_t *const dfb, const unsigned int obj_idx, const int fd);
+void drmu_fb_int_mmap_set(drmu_fb_t *const dfb, const unsigned int obj_idx, void * const buf, const size_t size, const size_t pitch);
+drmu_isset_t drmu_fb_hdr_metadata_isset(const drmu_fb_t *const dfb);
+const struct hdr_output_metadata * drmu_fb_hdr_metadata_get(const drmu_fb_t *const dfb);
+drmu_broadcast_rgb_t drmu_color_range_to_broadcast_rgb(const drmu_color_range_t range);
+drmu_colorspace_t drmu_fb_colorspace_get(const drmu_fb_t * const dfb);
+drmu_color_range_t drmu_fb_color_range_get(const drmu_fb_t * const dfb);
+const struct drmu_fmt_info_s * drmu_fb_format_info_get(const drmu_fb_t * const dfb);
+void drmu_fb_hdr_metadata_set(drmu_fb_t *const dfb, const struct hdr_output_metadata * meta);
+int drmu_fb_int_make(drmu_fb_t *const dfb);
+
+// Set FB orientation.
+// Orienation is the orintatin of the FB i.e. the inverse of the rotation
+// required to display on an unrotated display
+int drmu_fb_orientation_set(drmu_fb_t *const dfb, const unsigned int orientation);
+// Get orientation
+unsigned int drmu_fb_orientation_get(const drmu_fb_t *const dfb);
+// Get rotation required on this fb for a display rotated dest_rot
+// helper fn - equivalent to _subb(dest_rot, orientation)
+unsigned int drmu_fb_rotation(const drmu_fb_t *const dfb, const unsigned int dest_rot);
+
+// Cached fb sync ops
+int drmu_fb_write_start(drmu_fb_t * const dfb);
+int drmu_fb_write_end(drmu_fb_t * const dfb);
+int drmu_fb_read_start(drmu_fb_t * const dfb);
+int drmu_fb_read_end(drmu_fb_t * const dfb);
+
+// Called after commit succeeded and/or when atomic deleted
+//
+// On commit (with dfb != NULL, fd != -1) may possibly be called > once if
+// atomic copied or reused
+//
+// On delete (with dfb == NULL, fd == -1) will be called once after any commit
+// callbacks. If atomic deleted before commit or commit has error then commit
+// may never be called.
+typedef void drmu_fb_fence_fd_fn(void * v, int fd, drmu_fb_t * dfb);
+
+// Wait for data to become ready when fb used as destination of writeback
+// Returns:
+//  -ve   error
+//  0     timeout
+//  1     ready
+int drmu_fb_out_fence_wait(drmu_fb_t * const fb, const int timeout_ms);
+
+// Take the fence fd. Resets fb fence fd. User is now responsible for closing it.
+int drmu_fb_out_fence_take_fd(drmu_fb_t * const fb);
+
+// Object Id
+
+struct drmu_propinfo_s;
+
+uint32_t drmu_prop_object_value(const drmu_prop_object_t * const obj);
+void drmu_prop_object_unref(drmu_prop_object_t ** ppobj);
+drmu_prop_object_t * drmu_prop_object_new_propinfo(drmu_env_t * const du, const uint32_t obj_id, const struct drmu_propinfo_s * const pi);
+int drmu_atomic_add_prop_object(struct drmu_atomic_s * const da, drmu_prop_object_t * obj, uint32_t val);
+
+// Props
+
+// Grab all the props of an object and add to an atomic
+// * Does not add references to any properties (BO or FB) currently, it maybe
+//   should but if so we need to avoid accidentally closing BOs that we inherit
+//   from outside when we delete the atomic.
+int drmu_atomic_obj_add_snapshot(struct drmu_atomic_s * const da, const uint32_t objid, const uint32_t objtype);
+
+// CRTC
+
+struct _drmModeModeInfo;
+struct hdr_output_metadata;
+
+void drmu_crtc_delete(drmu_crtc_t ** ppdc);
+drmu_env_t * drmu_crtc_env(const drmu_crtc_t * const dc);
+uint32_t drmu_crtc_id(const drmu_crtc_t * const dc);
+int drmu_crtc_idx(const drmu_crtc_t * const dc);
+
+drmu_crtc_t * drmu_env_crtc_find_id(drmu_env_t * const du, const uint32_t crtc_id);
+drmu_crtc_t * drmu_env_crtc_find_n(drmu_env_t * const du, const unsigned int n);
+
+typedef struct drmu_mode_simple_params_s {
+    unsigned int width;
+    unsigned int height;
+    unsigned int hz_x_1000;  // Frame rate * 1000 i.e. 50Hz = 50000 (N.B. frame not field rate if interlaced)
+    drmu_ufrac_t par;  // Picture Aspect Ratio (0:0 if unknown)
+    drmu_ufrac_t sar;  // Sample Aspect Ratio
+    uint32_t type;
+    uint32_t flags;
+} drmu_mode_simple_params_t;
+
+const struct drm_mode_modeinfo * drmu_crtc_modeinfo(const drmu_crtc_t * const dc);
+// Get simple properties of initial crtc mode
+drmu_mode_simple_params_t drmu_crtc_mode_simple_params(const drmu_crtc_t * const dc);
+
+int drmu_atomic_crtc_add_modeinfo(struct drmu_atomic_s * const da, drmu_crtc_t * const dc, const struct drm_mode_modeinfo * const modeinfo);
+int drmu_atomic_crtc_add_active(struct drmu_atomic_s * const da, drmu_crtc_t * const dc, unsigned int val);
+
+bool drmu_crtc_is_claimed(const drmu_crtc_t * const dc);
+void drmu_crtc_unref(drmu_crtc_t ** const ppdc);
+drmu_crtc_t * drmu_crtc_ref(drmu_crtc_t * const dc);
+// A Conn should be claimed before any op that might change its state
+int drmu_crtc_claim_ref(drmu_crtc_t * const dc);
+
+// Connector
+
+// Set none if m=NULL
+int drmu_atomic_conn_add_hdr_metadata(struct drmu_atomic_s * const da, drmu_conn_t * const dn, const struct hdr_output_metadata * const m);
+
+// Does this connector have > 8 bit support?
+bool drmu_conn_has_hi_bpc(const drmu_conn_t * const dn);
+// False set max_bpc to 8, true max value
+int drmu_atomic_conn_add_hi_bpc(struct drmu_atomic_s * const da, drmu_conn_t * const dn, bool hi_bpc);
+
+int drmu_atomic_conn_add_colorspace(struct drmu_atomic_s * const da, drmu_conn_t * const dn, const drmu_colorspace_t colorspace);
+int drmu_atomic_conn_add_broadcast_rgb(struct drmu_atomic_s * const da, drmu_conn_t * const dn, const drmu_broadcast_rgb_t bcrgb);
+
+// Add crtc id
+int drmu_atomic_conn_add_crtc(struct drmu_atomic_s * const da, drmu_conn_t * const dn, drmu_crtc_t * const dc);
+
+// Add writeback fb & fence with callback
+// Neither makes sense without the other so do together
+// If fn is null then no callback, user must wait
+int drmu_atomic_conn_add_writeback_fb(struct drmu_atomic_s * const da_out, drmu_conn_t * const dn,
+                                      drmu_fb_t * const dfb,
+                                      drmu_fb_fence_fd_fn * const fn, void * const v);
+
+// List of supported writeback formats - no modifiers supported
+// *ppcount receives the count
+const uint32_t * drmu_conn_writeback_formats(drmu_conn_t * const dn, size_t * const ppcount);
+
+// Connector might support some rotations - true if given rotation supported
+bool drmu_conn_has_rotation(const drmu_conn_t * const dn, const unsigned int rotation);
+
+// Get mask of rotations supported by this conn
+// Will return a mask with only _ROTATION_0 set if the property isn't supported
+unsigned int drmu_conn_rotation_mask(const drmu_conn_t * const dn);
+
+// Add rotation to connector
+int drmu_atomic_conn_add_rotation(struct drmu_atomic_s * const da, drmu_conn_t * const dn, const unsigned int rotation);
+
+const struct drm_mode_modeinfo * drmu_conn_modeinfo(const drmu_conn_t * const dn, const int mode_id);
+drmu_mode_simple_params_t drmu_conn_mode_simple_params(const drmu_conn_t * const dn, const int mode_id);
+
+// Beware: this refects initial value or the last thing set, but currently
+// has no way of guessing if the atomic from the set was ever committed
+// successfully
+uint32_t drmu_conn_crtc_id_get(const drmu_conn_t * const dn);
+
+// Bitmask of CRTCs that might be able to use this Conn
+uint32_t drmu_conn_possible_crtcs(const drmu_conn_t * const dn);
+
+bool drmu_conn_is_output(const drmu_conn_t * const dn);
+bool drmu_conn_is_writeback(const drmu_conn_t * const dn);
+const char * drmu_conn_name(const drmu_conn_t * const dn);
+unsigned int drmu_conn_idx_get(const drmu_conn_t * const dn);
+
+// Retrieve the the n-th conn. Use for iteration. Returns NULL when none left
+drmu_conn_t * drmu_env_conn_find_n(drmu_env_t * const du, const unsigned int n);
+
+bool drmu_conn_is_claimed(const drmu_conn_t * const dn);
+void drmu_conn_unref(drmu_conn_t ** const ppdn);
+drmu_conn_t * drmu_conn_ref(drmu_conn_t * const dn);
+// A Conn should be claimed before any op that might change its state
+int drmu_conn_claim_ref(drmu_conn_t * const dn);
+
+
+// Plane
+
+uint32_t drmu_plane_id(const drmu_plane_t * const dp);
+
+#define DRMU_PLANE_TYPE_CURSOR  4
+#define DRMU_PLANE_TYPE_PRIMARY 2
+#define DRMU_PLANE_TYPE_OVERLAY 1
+#define DRMU_PLANE_TYPE_UNKNOWN 0
+unsigned int drmu_plane_type(const drmu_plane_t * const dp);
+
+const uint32_t * drmu_plane_formats(const drmu_plane_t * const dp, unsigned int * const pCount);
+bool drmu_plane_format_check(const drmu_plane_t * const dp, const uint32_t format, const uint64_t modifier);
+
+// Get mask of rotations supported by this plane
+// Will return a mask with only _ROTATION_0 set if the property isn't supported
+unsigned int drmu_plane_rotation_mask(const drmu_plane_t * const dp);
+// Is rot a valid rotation for this plane?
+bool drmu_plane_rotation_valid(const drmu_plane_t * const dp, const unsigned int rot);
+
+// Alpha: -1 = no not set, 0 = transparent, 0xffff = opaque
+#define DRMU_PLANE_ALPHA_UNSET                  (-1)
+#define DRMU_PLANE_ALPHA_TRANSPARENT            0
+#define DRMU_PLANE_ALPHA_OPAQUE                 0xffff
+int drmu_atomic_plane_add_alpha(struct drmu_atomic_s * const da, const drmu_plane_t * const dp, const int alpha);
+
+int drmu_atomic_plane_add_zpos(struct drmu_atomic_s * const da, const drmu_plane_t * const dp, const int zpos);
+
+// X, Y & TRANSPOSE can be ORed to get all others
+#define DRMU_ROTATION_0                   0
+#define DRMU_ROTATION_H_FLIP              1  // Horizontal flip (x -> -x)
+#define DRMU_ROTATION_V_FLIP              2  // Vertical flip (y -> -y)
+#define DRMU_ROTATION_180                 3
+// *** These don't exist on Pi - no inherent transpose
+#define DRMU_ROTATION_TRANSPOSE           4
+#define DRMU_ROTATION_270                 5  // Rotate 90 anti-cockwise
+#define DRMU_ROTATION_90                  6  // Rotate 90 clockwise
+#define DRMU_ROTATION_180_TRANSPOSE       7  // Rotate 180 & transpose
+
+// Aliases that mirror (IMHO confusing) DRM naming
+#define DRMU_ROTATION_REFLECT_X           DRMU_ROTATION_H_FLIP
+#define DRMU_ROTATION_REFLECT_Y           DRMU_ROTATION_V_FLIP
+
+#define DRMU_ROTATION_INVALID             ~0U
+
+static inline bool drmu_rotation_is_transposed(const unsigned int r)
+{
+    return (r & 4) != 0;
+}
+
+static inline bool drmu_rotation_is_valid(const unsigned int r)
+{
+    return (r & ~7) == 0;
+}
+
+// Transpose r if c is transposed.
+// Probably not a useful user fn but used in +/-
+static inline unsigned int
+drmu_rotation_ctranspose(const unsigned int r, const unsigned int c)
+{
+    const unsigned int s = (c & 4) >> 2;
+    return (r & 4) | ((r & 2) >> s) | ((r & 1) << s);
+}
+
+// a then b
+// Beware a + b != b + a
+static inline unsigned int
+drmu_rotation_add(const unsigned int a, const unsigned int b)
+{
+    return ((a | b) & ~7) != 0 ? DRMU_ROTATION_INVALID : drmu_rotation_ctranspose(a, b) ^ b;
+}
+
+// Returns value that if b is added to gets a
+// i.e. suba(a, b) + b = a
+static inline unsigned int
+drmu_rotation_suba(const unsigned int a, const unsigned int b)
+{
+    return ((a | b) & ~7) != 0 ? DRMU_ROTATION_INVALID : drmu_rotation_ctranspose(a ^ b, b);
+}
+
+// Returns value that would need to be added to a to get b
+// i.e. a + subb(b, a) = b
+static inline unsigned int
+drmu_rotation_subb(const unsigned int b, const unsigned int a)
+{
+    return ((a | b) & ~7) != 0 ? DRMU_ROTATION_INVALID : drmu_rotation_ctranspose(a, a ^ b) ^ b;
+}
+
+// Find a rotation that exists in mask_a which when combined with a rotation
+// in mask_b gives req_rot. If req_rot exists in mask_a then the return value
+// will be req_rot. If no such value exists _INVALID will be returned
+// Use _subb(return_value, req_rot) to get rotation required in b
+unsigned int drmu_rotation_find(const unsigned int req_rot, const unsigned int mask_a, const unsigned int mask_b);
+
+int drmu_atomic_plane_add_rotation(struct drmu_atomic_s * const da, const drmu_plane_t * const dp, const int rot);
+
+int drmu_atomic_plane_add_chroma_siting(struct drmu_atomic_s * const da, const drmu_plane_t * const dp, const drmu_chroma_siting_t siting);
+
+// Set FB to 0 (i.e. clear the plane)
+int drmu_atomic_plane_clear_add(struct drmu_atomic_s * const da, drmu_plane_t * const dp);
+
+// Adds the fb to the plane along with all fb properties that apply to a plane
+// If fb == NULL is equivalent to _plane_clear_add
+// pos is dest rect on the plane in full pixels (not frac)
+int drmu_atomic_plane_add_fb(struct drmu_atomic_s * const da, drmu_plane_t * const dp, drmu_fb_t * const dfb, const drmu_rect_t pos);
+
+// Is this plane reffed?
+bool drmu_plane_is_claimed(drmu_plane_t * const dp);
+
+// Unref a plane
+void drmu_plane_unref(drmu_plane_t ** const ppdp);
+
+// Ref a plane - expects it is already associated
+drmu_plane_t * drmu_plane_ref(drmu_plane_t * const dp);
+
+// Associate a plane with a crtc and ref it
+// Returns -EBUSY if plane already associated
+int drmu_plane_ref_crtc(drmu_plane_t * const dp, drmu_crtc_t * const dc);
+
+typedef bool (*drmu_plane_new_find_ok_fn)(const drmu_plane_t * dp, void * v);
+
+// Find a "free" plane that satisfies (returns true) the ok callback
+// Binds to the crtc & takes a reference
+drmu_plane_t * drmu_plane_new_find_ref(drmu_crtc_t * const dc, const drmu_plane_new_find_ok_fn cb, void * const v);
+// Find a "free" plane of the given type. Types can be ORed
+// Binds to the crtc & takes a reference
+drmu_plane_t * drmu_plane_new_find_ref_type(drmu_crtc_t * const dc, const unsigned int req_type);
+
+// Find plane n. Does not ref.
+drmu_plane_t * drmu_env_plane_find_n(drmu_env_t * const du, const unsigned int n);
+
+
+// Env
+struct drmu_log_env_s;
+
+// Poll environment maintenance functions used by drmu_poll.c
+// Could be use to set up custom polling functions. struct drmu_poll_env_s is
+// opaque to drmu.c
+struct drmu_queue_s;
+typedef struct drmu_queue_s * (* drmu_poll_new_fn)(drmu_env_t * du);
+typedef void (* drmu_poll_destroy_fn)(struct drmu_queue_s ** ppPoll_env, drmu_env_t * du);
+// Get/set poll environment. Value returned in *ppPe
+// If du killed then *ppPe = NULL and rv = -EBUSY
+// If already set then value returned and rv == 0
+// If unset then new_fn called and its value stored. If null then rv == -ENOMEM
+// destroy_fn called when du killed
+int drmu_env_int_poll_set(drmu_env_t * const du,
+                  const drmu_poll_new_fn new_fn, const drmu_poll_destroy_fn destroy_fn,
+                  struct drmu_queue_s ** const ppPe);
+// Return poll env. NULL if unset
+struct drmu_queue_s * drmu_env_int_poll_get(drmu_env_t * const du);
+
+// Do ioctl - returns -errno on error, 0 on success
+// deals with recalling the ioctl when required
+int drmu_ioctl(const drmu_env_t * const du, unsigned long req, void * arg);
+int drmu_fd(const drmu_env_t * const du);
+const struct drmu_log_env_s * drmu_env_log(const drmu_env_t * const du);
+void drmu_env_unref(drmu_env_t ** const ppdu);
+drmu_env_t * drmu_env_ref(drmu_env_t * const du);
+// Disable queue, restore saved state and unref
+// Doesn't guarantee that the env will be freed by exit as there may still be
+// buffers that hold a ref for logging or DRM fd but it should resolve circular
+// reference problems where buffers on the screen hold refs to the env.
+void drmu_env_kill(drmu_env_t ** const ppdu);
+// Restore state on env close
+int drmu_env_restore_enable(drmu_env_t * const du);
+bool drmu_env_restore_is_enabled(const drmu_env_t * const du);
+// Add an object snapshot to the restore state
+// Tests for commitability and removes any props that won't commit
+int drmu_atomic_env_restore_add_snapshot(struct drmu_atomic_s ** const ppda);
+// Do the restore - semi-internal function - only use externally as part of
+// a poll shutdown function. Leaves restore disabled.
+void drmu_env_int_restore(drmu_env_t * const du);
+
+// Open a drmu environment with the drm fd
+// Takes a logging structure so early errors can be reported. The logging
+// environment is copied so does not have to be valid for greater than the
+// duration of the call.
+// If log = NULL logging is disabled (set to drmu_log_env_none).
+// post_delete_fn is called after the env is deleted - this includes failures
+// in _new_fd2 itself
+typedef void (*drmu_env_post_delete_fn)(void * v, int fd);
+drmu_env_t * drmu_env_new_fd2(const int fd, const struct drmu_log_env_s * const log,
+                              drmu_env_post_delete_fn post_delete_fn, void * v);
+// Same as _new_fd2 but post_delete_fn is set to simply close the fd
+drmu_env_t * drmu_env_new_fd(const int fd, const struct drmu_log_env_s * const log);
+// open with device name
+drmu_env_t * drmu_env_new_open(const char * name, const struct drmu_log_env_s * const log);
+
+// Logging
+
+extern const struct drmu_log_env_s drmu_log_env_none;   // pre-built do-nothing log structure
+
+// drmu_atomic
+
+struct drmu_atomic_s;
+typedef struct drmu_atomic_s drmu_atomic_t;
+
+void drmu_atomic_dump_lvl(const drmu_atomic_t * const da, const int lvl);
+void drmu_atomic_dump(const drmu_atomic_t * const da);
+drmu_env_t * drmu_atomic_env(const drmu_atomic_t * const da);
+void drmu_atomic_unref(drmu_atomic_t ** const ppda);
+drmu_atomic_t * drmu_atomic_ref(drmu_atomic_t * const da);
+drmu_atomic_t * drmu_atomic_new(drmu_env_t * const du);
+
+// Copy (rather than just ref) b
+drmu_atomic_t * drmu_atomic_copy(drmu_atomic_t * const b);
+
+// 'Move' b to the return value
+// If b has a single ref then rv is simply b otherwise it is a copy of b
+drmu_atomic_t * drmu_atomic_move(drmu_atomic_t ** const ppb);
+
+// Merge b into a
+// This reference to b is unrefed (inc. on error); if this was the only
+// reference to b this allows the code to simply move properites from b
+// to a rather than having to copy. If there is >1 ref then the merge
+// will copy safely without breaking the other refs to b.
+int drmu_atomic_merge(drmu_atomic_t * const a, drmu_atomic_t ** const ppb);
+
+// Merge b into a, b is unrefed; if a == NULL then simply move
+// Move and copy work as their descriptions above
+static inline int drmu_atomic_move_merge(drmu_atomic_t ** const ppa, drmu_atomic_t ** const ppb)
+{
+    if (*ppa)
+        return drmu_atomic_merge(*ppa, ppb);
+    *ppa = drmu_atomic_move(ppb);
+    return 0;
+}
+
+// Remove all els in a that are also in b
+// b may be sorted (if not already) but is otherwise unchanged
+void drmu_atomic_sub(drmu_atomic_t * const a, drmu_atomic_t * const b);
+
+// Is da NULL or has no properties set?
+bool drmu_atomic_is_empty(const drmu_atomic_t * const da);
+
+// flags are DRM_MODE_ATOMIC_xxx (e.g. DRM_MODE_ATOMIC_TEST_ONLY) and DRM_MODE_PAGE_FLIP_xxx
+int drmu_atomic_commit(const drmu_atomic_t * const da, uint32_t flags);
+// Attempt commit - if it fails add failing members to da_fail
+// This does NOT remove failing props from da.  If da_fail == NULL then same as _commit
+int drmu_atomic_commit_test(const drmu_atomic_t * const da, uint32_t flags, drmu_atomic_t * const da_fail);
+
+// Add a callback that occurs when the atomic has been committed
+// This will occur on flip if atomic queued via _atomic_queue - if multiple
+// atomics are queued before flip then all fill occur on the same flip
+// If cb is 0 then NOP
+typedef void drmu_atomic_commit_fn(void * v);
+int drmu_atomic_add_commit_callback(drmu_atomic_t * const da, drmu_atomic_commit_fn * const cb, void * const v);
+// Clear all commit callbacks from this atomic
+void drmu_atomic_clear_commit_callbacks(drmu_atomic_t * const da);
+// Run all commit callbacks on this atomic. Callbacks are not cleared.
+void drmu_atomic_run_commit_callbacks(const drmu_atomic_t * const da);
+
+// Run the property commit callbacks - only call on a successful commit
+void drmu_atomic_run_prop_commit_callbacks(const drmu_atomic_t * const da);
+
+typedef void drmu_prop_unref_fn(void * v);
+typedef void drmu_prop_ref_fn(void * v);
+typedef void drmu_prop_commit_fn(void * v, uint64_t value);
+
+typedef struct drmu_atomic_prop_fns_s {
+    drmu_prop_ref_fn * ref;
+    drmu_prop_unref_fn * unref;
+    drmu_prop_commit_fn * commit;
+} drmu_atomic_prop_fns_t;
+
+drmu_prop_ref_fn drmu_prop_fn_null_unref;
+drmu_prop_unref_fn drmu_prop_fn_null_ref;
+drmu_prop_commit_fn drmu_prop_fn_null_commit;
+
+int drmu_atomic_add_prop_generic(drmu_atomic_t * const da,
+        const uint32_t obj_id, const uint32_t prop_id, const uint64_t value,
+        const drmu_atomic_prop_fns_t * const fns, void * const v);
+int drmu_atomic_add_prop_value(drmu_atomic_t * const da, const uint32_t obj_id, const uint32_t prop_id, const uint64_t value);
+
+// drmu_xlease
+
+drmu_env_t * drmu_env_new_xlease(const struct drmu_log_env_s * const log);
+
+// drmu_xdri3
+
+drmu_env_t * drmu_env_new_xdri3(const drmu_log_env_t * const log);
+
+// drmu_waylease
+
+drmu_env_t * drmu_env_new_waylease(const struct drmu_log_env_s * const log);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_atomic.c
@@ -0,0 +1,992 @@
+#include "drmu.h"
+#include "drmu_log.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <stdatomic.h>
+#include <string.h>
+
+#include <libdrm/drm.h>
+#include <libdrm/drm_mode.h>
+
+// Atomic property chain structures - no external visibility
+typedef struct aprop_prop_s {
+    uint32_t id;
+    uint64_t value;
+    void * v;
+    const drmu_atomic_prop_fns_t * fns;
+} aprop_prop_t;
+
+typedef struct aprop_obj_s {
+    uint32_t id;
+    unsigned int n;
+    unsigned int size;
+    bool unsorted;
+    aprop_prop_t * props;
+} aprop_obj_t;
+
+typedef struct aprop_hdr_s {
+    unsigned int n;
+    unsigned int size;
+    bool unsorted;
+    aprop_obj_t * objs;
+} aprop_hdr_t;
+
+typedef struct atomic_cb_s {
+    struct atomic_cb_s * next;
+    void * v;
+    drmu_atomic_commit_fn * cb;
+} atomic_cb_t;
+
+typedef struct drmu_atomic_s {
+    atomic_int ref_count;  // 0 == 1 ref for ease of init
+
+    struct drmu_env_s * du;
+
+    aprop_hdr_t props;
+
+    atomic_cb_t * commit_cb_q;
+    atomic_cb_t ** commit_cb_last_ptr;
+} drmu_atomic_t;
+
+static inline unsigned int
+max_uint(const unsigned int a, const unsigned int b)
+{
+    return a < b ? b : a;
+}
+
+static atomic_cb_t *
+atomic_cb_new(drmu_atomic_commit_fn * cb, void * v)
+{
+    atomic_cb_t * acb = malloc(sizeof(*acb));
+    if (acb == NULL)
+        return NULL;
+
+    *acb = (atomic_cb_t){
+        .next = NULL,
+        .cb = cb,
+        .v = v
+    };
+    return acb;
+}
+
+static void
+aprop_prop_unref(aprop_prop_t * const pp)
+{
+    pp->fns->unref(pp->v);
+}
+
+static void
+aprop_prop_ref(aprop_prop_t * const pp)
+{
+    pp->fns->ref(pp->v);
+}
+
+static void
+aprop_prop_committed(aprop_prop_t * const pp)
+{
+    pp->fns->commit(pp->v, pp->value);
+}
+
+static void
+aprop_obj_uninit(aprop_obj_t * const po)
+{
+    unsigned int i;
+    for (i = 0; i != po->n; ++i)
+        aprop_prop_unref(po->props + i);
+    free(po->props);
+    memset(po, 0, sizeof(*po));
+}
+
+static int
+aprop_obj_copy(aprop_obj_t * const po_c, const aprop_obj_t * const po_a)
+{
+    unsigned int i;
+    aprop_prop_t * props;
+
+    aprop_obj_uninit(po_c);
+    if (po_a->n == 0)
+        return 0;
+
+    if ((props = calloc(po_a->size, sizeof(*props))) == NULL)
+        return -ENOMEM;
+    memcpy(props, po_a->props, po_a->n * sizeof(*po_a->props));
+
+    *po_c = *po_a;
+    po_c->props = props;
+
+    for (i = 0; i != po_a->n; ++i)
+        aprop_prop_ref(props + i);
+    return 0;
+}
+
+static void
+aprop_obj_move(aprop_obj_t * const po_c, aprop_obj_t * const po_a)
+{
+    *po_c = *po_a;
+    memset(po_a, 0, sizeof(*po_a));
+}
+
+static int
+aprop_prop_qsort_cb(const void * va, const void * vb)
+{
+    const aprop_prop_t * const a = va;
+    const aprop_prop_t * const b = vb;
+    return a->id == b->id ? 0 : a->id < b->id ? -1 : 1;
+}
+
+static void
+aprop_obj_props_sort(aprop_obj_t * const po)
+{
+    if (!po->unsorted)
+        return;
+    qsort(po->props, po->n, sizeof(po->props[0]), aprop_prop_qsort_cb);
+    po->unsorted = false;
+}
+
+// Merge b into a and put the result in c. a & b are uninit on exit
+// Could (easily) merge into a but its more convienient for the caller to create new
+static int
+aprop_obj_merge(aprop_obj_t * const po_c, aprop_obj_t * const po_a, aprop_obj_t * const po_b)
+{
+    unsigned int i, j, k;
+    unsigned int c_size;
+    aprop_prop_t * c;
+    aprop_prop_t * const a = po_a->props;
+    aprop_prop_t * const b = po_b->props;
+
+    // As we should have no identical els we don't care that qsort is unstable
+    aprop_obj_props_sort(po_a);
+    aprop_obj_props_sort(po_b);
+
+    // Pick a size
+    c_size = max_uint(po_a->size, po_b->size);
+    if (c_size < po_a->n + po_b->n)
+        c_size *= 2;
+    if ((c = calloc(c_size, sizeof(*c))) == NULL)
+        return -ENOMEM;
+
+    for (i = 0, j = 0, k = 0; i < po_a->n && j < po_b->n; ++k) {
+        if (a[i].id < b[j].id)
+            c[k] = a[i++];
+        else if (a[i].id > b[j].id)
+            c[k] = b[j++];
+        else {
+            c[k] = b[j++];
+            aprop_prop_unref(a + i++);
+        }
+    }
+    for (; i < po_a->n; ++i, ++k)
+        c[k] = a[i];
+    for (; j < po_b->n; ++j, ++k)
+        c[k] = b[j];
+
+    *po_c = (aprop_obj_t){
+        .id = po_a->id,
+        .n = k,
+        .size = c_size,
+        .unsorted = false,
+        .props = c
+    };
+
+    // We have avoided excess ref / unref by simple copy so just free the props array
+    free(a);
+    free(b);
+
+    memset(po_a, 0, sizeof(*po_a));
+    memset(po_b, 0, sizeof(*po_b));
+
+    return 0;
+}
+
+// Remove any props in a that are also in b
+// b must be sorted
+// Returns count of props remaining in a
+static unsigned int
+aprop_obj_sub(aprop_obj_t * const po_a, const aprop_obj_t * const po_b)
+{
+    unsigned int i = 0, j = 0, k;
+    aprop_prop_t * const a = po_a->props;
+    const aprop_prop_t * const b = po_b->props;
+
+    if (po_a->n == 0 || po_b->n == 0)
+        return po_a->n;
+
+    // As we should have no identical els we don't care that qsort is unstable
+    aprop_obj_props_sort(po_a);
+    assert(!po_b->unsorted);
+
+    // Skip initial non-matches, returning if no match found
+    while (a[i].id != b[j].id) {
+        if (a[i].id < b[j].id) {
+            if (++i == po_a->n)
+                return po_a->n;
+        }
+        else {
+            if (++j == po_b->n)
+                return po_a->n;
+        }
+    }
+    // We have a match - next loop will do the unref
+    k = i;
+
+    do {
+        if (a[i].id < b[j].id)
+            a[k++] = a[i++];
+        else {
+            if (a[i].id == b[j].id)
+                aprop_prop_unref(a + i++);
+            j++;
+        }
+    } while (i != po_a->n && j != po_b->n);
+
+    for (; i < po_a->n; ++i, ++k)
+        a[k] = a[i];
+    po_a->n = k;
+
+    return po_a->n;
+}
+
+
+static aprop_prop_t *
+aprop_obj_prop_get(aprop_obj_t * const po, const uint32_t id)
+{
+    unsigned int i;
+    aprop_prop_t * pp = po->props;
+
+    static const drmu_atomic_prop_fns_t null_fns = {
+        .ref    = drmu_prop_fn_null_ref,
+        .unref  = drmu_prop_fn_null_unref,
+        .commit = drmu_prop_fn_null_commit
+    };
+
+    for (i = 0; i != po->n; ++i, ++pp) {
+        if (pp->id == id)
+            return pp;
+    }
+
+    if (po->n >= po->size) {
+        size_t newsize = po->size < 16 ? 16 : po->size * 2;
+        if ((pp = realloc(po->props, newsize * sizeof(*pp))) == NULL)
+            return NULL;
+        memset(pp + po->size, 0, (newsize - po->size) * sizeof(*pp));
+
+        po->props = pp;
+        po->size = newsize;
+        pp += po->n;
+    }
+    if (!po->unsorted && po->n != 0 && pp[-1].id > id)
+        po->unsorted = true;
+    ++po->n;
+
+    pp->id = id;
+    pp->fns = &null_fns;
+    return pp;
+}
+
+static void
+aprop_obj_atomic_fill(const aprop_obj_t * const po, uint32_t * prop_ids, uint64_t * prop_values)
+{
+    unsigned int i;
+    for (i = 0; i != po->n; ++i) {
+        *prop_ids++ = po->props[i].id;
+        *prop_values++ = po->props[i].value;
+    }
+}
+
+static void
+aprop_obj_dump(drmu_env_t * const du,
+               const drmu_log_env_t * const log, const enum drmu_log_level_e lvl,
+               const aprop_obj_t * const po)
+{
+    unsigned int i;
+    drmu_log_lvl(log, lvl, "Obj: id %#02x size %d n %d", po->id, po->size, po->n);
+    for (i = 0; i != po->n; ++i) {
+        struct drm_mode_get_property pattr = {.prop_id = po->props[i].id};
+        drmu_ioctl(du, DRM_IOCTL_MODE_GETPROPERTY, &pattr);
+
+        drmu_log_lvl(log, lvl, "Obj %#04x: Prop %#04x (%s) Value %#"PRIx64" v %p",
+                     po->id, po->props[i].id, pattr.name, po->props[i].value, po->props[i].v);
+    }
+}
+
+static void
+aprop_obj_committed(const aprop_obj_t * const po)
+{
+    unsigned int i;
+    for (i = 0; i != po->n; ++i)
+        aprop_prop_committed(po->props + i);
+}
+
+static void
+aprop_hdr_dump(drmu_env_t * const du,
+               const drmu_log_env_t * const log, const enum drmu_log_level_e lvl,
+               const aprop_hdr_t * const ph)
+{
+    unsigned int i;
+    drmu_log_lvl(log, lvl, "Header: size %d n %d", ph->size, ph->n);
+    for (i = 0; i != ph->n; ++i)
+        aprop_obj_dump(du, log, lvl, ph->objs + i);
+}
+
+static void
+aprop_hdr_committed(const aprop_hdr_t * const ph)
+{
+    unsigned int i;
+    for (i = 0; i != ph->n; ++i)
+        aprop_obj_committed(ph->objs + i);
+}
+
+static aprop_obj_t *
+aprop_hdr_obj_get(aprop_hdr_t * const ph, const uint32_t id)
+{
+    unsigned int i;
+    aprop_obj_t * po = ph->objs;
+
+    for (i = 0; i != ph->n; ++i, ++po) {
+        if (po->id == id)
+            return po;
+    }
+
+    if (ph->n >= ph->size) {
+        size_t newsize = ph->size < 16 ? 16 : ph->size * 2;
+        if ((po = realloc(ph->objs, newsize * sizeof(*po))) == NULL)
+            return NULL;
+        memset(po + ph->size, 0, (newsize - ph->size) * sizeof(*po));
+
+        ph->objs = po;
+        ph->size = newsize;
+        po += ph->n;
+    }
+    if (!ph->unsorted && ph->n != 0 && po[-1].id > id)
+        ph->unsorted = true;
+    ++ph->n;
+
+    po->id = id;
+    return po;
+}
+
+static void
+aprop_hdr_uninit(aprop_hdr_t * const ph)
+{
+    unsigned int i;
+    for (i = 0; i != ph->n; ++i)
+        aprop_obj_uninit(ph->objs + i);
+    free(ph->objs);
+    memset(ph, 0, sizeof(*ph));
+}
+
+static int
+aprop_hdr_copy(aprop_hdr_t * const ph_c, const aprop_hdr_t * const ph_a)
+{
+    unsigned int i;
+
+    aprop_hdr_uninit(ph_c);
+
+    if (ph_a->n == 0)
+        return 0;
+
+    if ((ph_c->objs = calloc(ph_a->size, sizeof(*ph_c->objs))) == NULL)
+        return -ENOMEM;
+
+    ph_c->n = ph_a->n;
+    ph_c->size = ph_a->size;
+    ph_c->unsorted = ph_a->unsorted;
+
+    for (i = 0; i != ph_a->n; ++i)
+        aprop_obj_copy(ph_c->objs + i, ph_a->objs + i);
+    return 0;
+}
+
+// Move b to a. a must be empty
+static int
+aprop_hdr_move(aprop_hdr_t * const ph_a, aprop_hdr_t * const ph_b)
+{
+    *ph_a = *ph_b;
+    *ph_b = (aprop_hdr_t){0};
+    return 0;
+}
+
+static int
+aprop_obj_qsort_cb(const void * va, const void * vb)
+{
+    const aprop_obj_t * const a = va;
+    const aprop_obj_t * const b = vb;
+    return a->id == b->id ? 0 : a->id < b->id ? -1 : 1;
+}
+
+// As we should have no identical els we don't care that qsort is unstable
+// Doesn't sort props
+static void
+aprop_hdr_sort(aprop_hdr_t * const ph)
+{
+    if (!ph->unsorted)
+        return;
+    qsort(ph->objs, ph->n, sizeof(ph->objs[0]), aprop_obj_qsort_cb);
+    ph->unsorted = false;
+}
+
+// Merge b into a. b will be uninited
+static int
+aprop_hdr_merge(aprop_hdr_t * const ph_a, aprop_hdr_t * const ph_b)
+{
+    unsigned int i, j, k;
+    unsigned int c_size;
+    aprop_obj_t * c;
+    aprop_obj_t * const a = ph_a->objs;
+    aprop_obj_t * const b = ph_b->objs;
+
+    if (ph_b->n == 0)
+        return 0;
+    if (ph_a->n == 0)
+        return aprop_hdr_move(ph_a, ph_b);
+
+    aprop_hdr_sort(ph_a);
+    aprop_hdr_sort(ph_b);
+
+    // Pick a size
+    c_size = max_uint(ph_a->size, ph_b->size);
+    if (c_size < ph_a->n + ph_b->n)
+        c_size *= 2;
+    if ((c = calloc(c_size, sizeof(*c))) == NULL)
+        return -ENOMEM;
+
+    for (i = 0, j = 0, k = 0; i < ph_a->n && j < ph_b->n; ++k) {
+        if (a[i].id < b[j].id)
+            aprop_obj_move(c + k, a + i++);
+        else if (a[i].id > b[j].id)
+            aprop_obj_move(c + k, b + j++);
+        else
+            aprop_obj_merge(c + k, a + i++, b + j++);
+    }
+    for (; i < ph_a->n; ++i, ++k)
+        aprop_obj_move(c + k, a + i);
+    for (; j < ph_b->n; ++j, ++k)
+        aprop_obj_move(c + k, b + j);
+
+    aprop_hdr_uninit(ph_a);
+    aprop_hdr_uninit(ph_b);
+
+    ph_a->n = k;
+    ph_a->size = c_size;
+    ph_a->objs = c;
+    // Merge will maintain sort so leave unsorted false
+
+    return 0;
+}
+
+// Remove any props in a that are also in b
+// b must be sorted
+static void
+aprop_hdr_sub(aprop_hdr_t * const ph_a, const aprop_hdr_t * const ph_b)
+{
+    unsigned int i = 0, j = 0, k;
+    aprop_obj_t * const a = ph_a->objs;
+    const aprop_obj_t * const b = ph_b->objs;
+
+    aprop_hdr_sort(ph_a);
+    assert(!ph_b->unsorted);
+
+    // Scan whilst we haven't deleted anything
+    for (;;) {
+        // If we run out of either array then nothing more needed
+        if (i == ph_a->n || j == ph_b->n)
+            return;
+
+        if (a[i].id < b[j].id)
+            ++i;
+        else if (a[i].id > b[j].id)
+            ++j;
+        else {
+            k = i;
+            if (aprop_obj_sub(a + i++, b + j++) == 0) {
+                aprop_obj_uninit(a + k);
+                break;
+            }
+        }
+    }
+
+    // Move & scan
+    while (i < ph_a->n && j < ph_b->n) {
+        if (a[i].id < b[j].id)
+            aprop_obj_move(a + k++, a + i++);
+        else if (a[i].id > b[j].id)
+            j++;
+        else {
+            if (aprop_obj_sub(a + i, b + j) == 0)
+                aprop_obj_uninit(a + i);
+            else
+                aprop_obj_move(a + k++, a + i);
+            i++;
+            j++;
+        }
+    }
+
+    // Move any remaining entries
+    for (; i < ph_a->n; ++i, ++k)
+        aprop_obj_move(a + k, a + i);
+    ph_a->n = k;
+
+    return;
+}
+
+// Sort header objs & obj props
+static void
+aprop_hdr_props_sort(aprop_hdr_t * const ph)
+{
+    aprop_hdr_sort(ph);
+    for (unsigned int i = 0; i != ph->n; ++i)
+        aprop_obj_props_sort(ph->objs + i);
+}
+
+static aprop_prop_t *
+aprop_hdr_prop_get(aprop_hdr_t * const ph, const uint32_t obj_id, const uint32_t prop_id)
+{
+    aprop_obj_t * const po = aprop_hdr_obj_get(ph, obj_id);
+    return po == NULL ? NULL : aprop_obj_prop_get(po, prop_id);
+}
+
+// Total props
+static unsigned int
+aprop_hdr_props_count(const aprop_hdr_t * const ph)
+{
+    unsigned int i;
+    unsigned int n = 0;
+
+    for (i = 0; i != ph->n; ++i)
+        n += ph->objs[i].n;
+    return n;
+}
+
+// Total props
+static bool
+aprop_hdr_props_is_empty(const aprop_hdr_t * const ph)
+{
+    unsigned int i;
+
+    for (i = 0; i != ph->n; ++i)
+        if (ph->objs[i].n != 0)
+            return false;
+    return true;
+}
+
+static unsigned int
+aprop_hdr_objs_count(const aprop_hdr_t * const ph)
+{
+    return ph->n;
+}
+
+static void
+aprop_hdr_atomic_fill(const aprop_hdr_t * const ph,
+                     uint32_t * obj_ids,
+                     uint32_t * prop_counts,
+                     uint32_t * prop_ids,
+                     uint64_t * prop_values)
+{
+    unsigned int i;
+    for (i = 0; i != ph->n; ++i) {
+        const unsigned int n = ph->objs[i].n;
+        *obj_ids++ = ph->objs[i].id;
+        *prop_counts++ = n;
+        aprop_obj_atomic_fill(ph->objs +i, prop_ids, prop_values);
+        prop_ids += n;
+        prop_values += n;
+    }
+}
+
+void
+drmu_prop_fn_null_unref(void * v)
+{
+    (void)v;
+}
+
+void
+drmu_prop_fn_null_ref(void * v)
+{
+    (void)v;
+}
+
+void
+drmu_prop_fn_null_commit(void * v, uint64_t value)
+{
+    (void)v;
+    (void)value;
+}
+
+int
+drmu_atomic_add_commit_callback(drmu_atomic_t * const da, drmu_atomic_commit_fn * const cb, void * const v)
+{
+    if (cb) {
+        atomic_cb_t *acb = atomic_cb_new(cb, v);
+        if (acb == NULL)
+            return -ENOMEM;
+
+        *da->commit_cb_last_ptr = acb;
+        da->commit_cb_last_ptr = &acb->next;
+    }
+
+    return 0;
+}
+
+void
+drmu_atomic_clear_commit_callbacks(drmu_atomic_t * const da)
+{
+    atomic_cb_t *p = da->commit_cb_q;
+
+    da->commit_cb_q = NULL;
+    da->commit_cb_last_ptr = &da->commit_cb_q;
+
+    while (p != NULL) {
+        atomic_cb_t * const next = p->next;
+        free(p);
+        p = next;
+    }
+}
+
+void
+drmu_atomic_run_prop_commit_callbacks(const drmu_atomic_t * const da)
+{
+    if (da == NULL)
+        return;
+    aprop_hdr_committed(&da->props);
+}
+
+void
+drmu_atomic_run_commit_callbacks(const drmu_atomic_t * const da)
+{
+    if (da == NULL)
+        return;
+
+    for (const atomic_cb_t *p = da->commit_cb_q; p != NULL; p = p->next)
+        p->cb(p->v);
+}
+
+int
+drmu_atomic_add_prop_generic(drmu_atomic_t * const da,
+                  const uint32_t obj_id, const uint32_t prop_id, const uint64_t value,
+                  const drmu_atomic_prop_fns_t * const fns, void * const v)
+{
+    aprop_hdr_t * const ph = &da->props;
+
+    if (obj_id == 0 || prop_id == 0)
+    {
+        return -EINVAL;
+    }
+    else
+    {
+        aprop_prop_t *const pp = aprop_hdr_prop_get(ph, obj_id, prop_id);
+        if (pp == NULL)
+            return -ENOMEM;
+
+        aprop_prop_unref(pp);
+        pp->value = value;
+        if (fns) {
+            pp->fns = fns;
+            pp->v = v;
+        }
+        aprop_prop_ref(pp);
+        return 0;
+    }
+}
+
+int
+drmu_atomic_add_prop_value(drmu_atomic_t * const da, const uint32_t obj_id, const uint32_t prop_id, const uint64_t value)
+{
+    if (drmu_atomic_add_prop_generic(da, obj_id, prop_id, value, NULL, NULL) < 0)
+        drmu_warn(drmu_atomic_env(da), "%s: Failed to set obj_id=%#x, prop_id=%#x, val=%" PRId64, __func__,
+                 obj_id, prop_id, value);
+    return 0;
+}
+
+void
+drmu_atomic_dump_lvl(const drmu_atomic_t * const da, const int lvl)
+{
+    drmu_env_t * const du = da->du;
+    const drmu_log_env_t * const log = drmu_env_log(du);
+
+    if (!drmu_log_lvl_test(log, lvl))
+        return;
+
+    drmu_log_lvl(log, lvl, "Atomic %p: refs %d", da, atomic_load(&da->ref_count)+1);
+    aprop_hdr_dump(du, log, lvl, &da->props);
+}
+
+void
+drmu_atomic_dump(const drmu_atomic_t * const da)
+{
+    drmu_atomic_dump_lvl(da, DRMU_LOG_LEVEL_INFO);
+}
+
+drmu_env_t *
+drmu_atomic_env(const drmu_atomic_t * const da)
+{
+    return da == NULL ? NULL : da->du;
+}
+
+static void
+drmu_atomic_free(drmu_atomic_t * const da)
+{
+    drmu_atomic_clear_commit_callbacks(da);
+    aprop_hdr_uninit(&da->props);
+    free(da);
+}
+
+void
+drmu_atomic_unref(drmu_atomic_t ** const ppda)
+{
+    drmu_atomic_t * const da = *ppda;
+
+    if (da == NULL)
+        return;
+    *ppda = NULL;
+
+    if (atomic_fetch_sub(&da->ref_count, 1) == 0)
+        drmu_atomic_free(da);
+}
+
+drmu_atomic_t *
+drmu_atomic_ref(drmu_atomic_t * const da)
+{
+    atomic_fetch_add(&da->ref_count, 1);
+    return da;
+}
+
+drmu_atomic_t *
+drmu_atomic_new(drmu_env_t * const du)
+{
+    drmu_atomic_t * const da = calloc(1, sizeof(*da));
+
+    if (da == NULL) {
+        drmu_err(du, "%s: Failed to alloc struct", __func__);
+        return NULL;
+    }
+    da->du = du;
+    da->commit_cb_last_ptr = &da->commit_cb_q;
+
+    return da;
+}
+
+drmu_atomic_t *
+drmu_atomic_copy(drmu_atomic_t * const b)
+{
+    drmu_atomic_t * a;
+
+    if (b == NULL || (a = drmu_atomic_new(b->du)) == NULL)
+        return NULL;
+
+    if (aprop_hdr_copy(&a->props, &b->props) != 0)
+        goto fail;
+    for (atomic_cb_t * p = b->commit_cb_q; p != NULL; p = p->next)
+        if (drmu_atomic_add_commit_callback(a, p->cb, p->v) != 0)
+            goto fail;
+    return a;
+
+fail:
+    drmu_atomic_free(a);
+    return NULL;
+}
+
+drmu_atomic_t *
+drmu_atomic_move(drmu_atomic_t ** const ppb)
+{
+    drmu_atomic_t * a;
+    drmu_atomic_t * b = *ppb;
+    *ppb = NULL;
+
+    if (b == NULL || atomic_load(&b->ref_count) == 0)
+        return b;
+
+    a = drmu_atomic_copy(b);
+    drmu_atomic_unref(&b);
+    return a;
+}
+
+// Merge b into a. b is unrefed (inc on error)
+// Commit cbs are added
+int
+drmu_atomic_merge(drmu_atomic_t * const a, drmu_atomic_t ** const ppb)
+{
+    drmu_atomic_t * b;
+    int rv = -EINVAL;
+
+    if (*ppb == NULL)
+        return 0;
+
+    if (a == NULL) {
+        drmu_atomic_unref(ppb);
+        return -EINVAL;
+    }
+
+    if ((b = drmu_atomic_move(ppb)) == NULL)
+        return -ENOMEM;
+
+    if (b->commit_cb_q != NULL) {
+        *a->commit_cb_last_ptr = b->commit_cb_q;
+        a->commit_cb_last_ptr = b->commit_cb_last_ptr;
+        b->commit_cb_q = NULL;
+    }
+
+    rv = aprop_hdr_merge(&a->props, &b->props);
+    drmu_atomic_unref(&b);
+
+    if (rv != 0) {
+        drmu_err(a->du, "%s: Merge Failed", __func__);
+        return rv;
+    }
+
+    return 0;
+}
+
+void
+drmu_atomic_sub(drmu_atomic_t * const a, drmu_atomic_t * const b)
+{
+    aprop_hdr_props_sort(&b->props);
+    aprop_hdr_sub(&a->props, &b->props);
+}
+
+static void
+atomic_props_crop(struct drm_mode_atomic * const f, const unsigned int n, uint32_t ** const undo_p, uint32_t * const undo_v)
+{
+    unsigned int i;
+    unsigned int t = 0;
+    uint32_t * const c = (uint32_t *)(uintptr_t)f->count_props_ptr;
+
+    for (i = 0; i != f->count_objs; ++i) {
+        t += c[i];
+        if (t >= n) {
+            f->count_objs = i + 1;
+            *undo_p = c + i;
+            *undo_v = c[i];
+            c[i] -= t - n;
+            break;
+        }
+    }
+}
+
+static void
+atomic_props_del(struct drm_mode_atomic * const f, const unsigned int n, const unsigned int cp,
+                 uint32_t * const objid, uint32_t * const propid, uint64_t * const val)
+{
+    unsigned int i;
+    unsigned int t = 0;
+    uint32_t * const c = (uint32_t *)(uintptr_t)f->count_props_ptr;
+    uint32_t * const o = (uint32_t *)(uintptr_t)f->objs_ptr;
+    uint32_t * const p = (uint32_t *)(uintptr_t)f->props_ptr;
+    uint64_t * const v = (uint64_t *)(uintptr_t)f->prop_values_ptr;
+
+    for (i = 0; i != f->count_objs; ++i) {
+        t += c[i];
+        if (t > n) {
+            // Copy out what we are going to delete
+            *objid = o[i];
+            *propid = p[n];
+            *val = v[n];
+
+            memmove(p + n, p + n + 1, (cp - n - 1) * sizeof(*p));
+            memmove(v + n, v + n + 1, (cp - n - 1) * sizeof(*v));
+
+            if (--c[i] == 0) {
+                memmove(c + i, c + i + 1, (f->count_objs - i - 1) * sizeof(*c));
+                memmove(o + i, o + i + 1, (f->count_objs - i - 1) * sizeof(*o));
+                --f->count_objs;
+            }
+            break;
+        }
+    }
+}
+
+// Returns count of initial good els (i.e. n of 1st bad)
+static unsigned int
+commit_find_good(drmu_env_t * const du, const struct drm_mode_atomic * const atomic, const unsigned int n_props)
+{
+    unsigned int a = 0;             // N known good
+    unsigned int b = n_props + 1;   // N maybe good + 1
+
+    while (a + 1 < b) {
+        struct drm_mode_atomic at = *atomic;
+        unsigned int n = (a + b) / 2;
+        uint32_t * undo_p = NULL;
+        uint32_t undo_v = 0;
+
+        at.flags = DRM_MODE_ATOMIC_TEST_ONLY | (DRM_MODE_ATOMIC_ALLOW_MODESET & atomic->flags);
+        atomic_props_crop(&at, n, &undo_p, &undo_v);
+        assert(undo_p != NULL);
+
+        if (drmu_ioctl(du, DRM_IOCTL_MODE_ATOMIC, &at) == 0)
+            a = n;
+        else
+            b = n;
+
+        *undo_p = undo_v;  // Should always be set
+    }
+
+    return a;
+}
+
+// da_fail does not keep refs to its values - for info only
+int
+drmu_atomic_commit_test(const drmu_atomic_t * const da, uint32_t flags, drmu_atomic_t * const da_fail)
+{
+    drmu_env_t * const du = da->du;
+    const unsigned int n_objs = aprop_hdr_objs_count(&da->props);
+    unsigned int n_props = aprop_hdr_props_count(&da->props);
+    int rv = 0;
+
+    if (n_props != 0) {
+        uint32_t obj_ids[n_objs];
+        uint32_t prop_counts[n_objs];
+        uint32_t prop_ids[n_props];
+        uint64_t prop_values[n_props];
+        struct drm_mode_atomic atomic = {
+            .flags           = flags,
+            .count_objs      = n_objs,
+            .objs_ptr        = (uintptr_t)obj_ids,
+            .count_props_ptr = (uintptr_t)prop_counts,
+            .props_ptr       = (uintptr_t)prop_ids,
+            .prop_values_ptr = (uintptr_t)prop_values,
+            .user_data       = (uintptr_t)da
+        };
+
+        aprop_hdr_atomic_fill(&da->props, obj_ids, prop_counts, prop_ids, prop_values);
+
+        rv = drmu_ioctl(du, DRM_IOCTL_MODE_ATOMIC, &atomic);
+        if (rv == 0)
+            drmu_atomic_run_prop_commit_callbacks(da);
+        drmu_atomic_run_commit_callbacks(da);
+
+        if (rv  == 0 || !da_fail)
+            return rv;
+
+        for (;;) {
+            unsigned int a = commit_find_good(du, &atomic, n_props);
+            uint32_t objid = 0;
+            uint32_t propid = 0;
+            uint64_t val = 0;
+
+            if (a >= n_props)
+                break;
+
+            atomic_props_del(&atomic, a, n_props, &objid, &propid, &val);
+            --n_props;
+
+            drmu_atomic_add_prop_value(da_fail, objid, propid, val);
+        }
+    }
+
+    return rv;
+}
+
+
+int
+drmu_atomic_commit(const drmu_atomic_t * const da, uint32_t flags)
+{
+    return drmu_atomic_commit_test(da, flags, NULL);
+}
+
+bool
+drmu_atomic_is_empty(const drmu_atomic_t * const da)
+{
+    return da == NULL || aprop_hdr_props_is_empty(&da->props);
+}
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_chroma.h
@@ -0,0 +1,47 @@
+#ifndef _DRMU_DRMU_CHROMA_H
+#define _DRMU_DRMU_CHROMA_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "drmu_chroma.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct drmu_chroma_siting_s {
+    int32_t x, y;
+} drmu_chroma_siting_t;
+
+// Init constants - C winges if the struct is specified in a const init (which seems like a silly error)
+#define drmu_chroma_siting_float_i(_x, _y) {.x = (int32_t)((double)(_x) * 65536 + .5), .y = (int32_t)((double)(_y) * 65536 + .5)}
+#define DRMU_CHROMA_SITING_BOTTOM_I             drmu_chroma_siting_float_i(0.5, 1.0)
+#define DRMU_CHROMA_SITING_BOTTOM_LEFT_I        drmu_chroma_siting_float_i(0.0, 1.0)
+#define DRMU_CHROMA_SITING_CENTER_I             drmu_chroma_siting_float_i(0.5, 0.5)
+#define DRMU_CHROMA_SITING_LEFT_I               drmu_chroma_siting_float_i(0.0, 0.5)
+#define DRMU_CHROMA_SITING_TOP_I                drmu_chroma_siting_float_i(0.5, 0.0)
+#define DRMU_CHROMA_SITING_TOP_LEFT_I           drmu_chroma_siting_float_i(0.0, 0.0)
+#define DRMU_CHROMA_SITING_UNSPECIFIED_I        {INT32_MIN, INT32_MIN}
+// Inline constants
+#define drmu_chroma_siting_float(_x, _y) (drmu_chroma_siting_t)drmu_chroma_siting_float_i(_x, _y)
+#define DRMU_CHROMA_SITING_BOTTOM               drmu_chroma_siting_float(0.5, 1.0)
+#define DRMU_CHROMA_SITING_BOTTOM_LEFT          drmu_chroma_siting_float(0.0, 1.0)
+#define DRMU_CHROMA_SITING_CENTER               drmu_chroma_siting_float(0.5, 0.5)
+#define DRMU_CHROMA_SITING_LEFT                 drmu_chroma_siting_float(0.0, 0.5)
+#define DRMU_CHROMA_SITING_TOP                  drmu_chroma_siting_float(0.5, 0.0)
+#define DRMU_CHROMA_SITING_TOP_LEFT             drmu_chroma_siting_float(0.0, 0.0)
+#define DRMU_CHROMA_SITING_UNSPECIFIED          (drmu_chroma_siting_t){INT32_MIN, INT32_MIN}
+
+static inline bool
+drmu_chroma_siting_eq(const drmu_chroma_siting_t a, const drmu_chroma_siting_t b)
+{
+    return a.x == b.x && a.y == b.y;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_dmabuf.c
@@ -0,0 +1,206 @@
+#include "drmu_dmabuf.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdatomic.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <linux/mman.h>
+#include <linux/dma-heap.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+
+#include "drmu.h"
+#include "drmu_fmts.h"
+#include "drmu_log.h"
+#include "drmu_pool.h"
+
+struct drmu_dmabuf_env_s {
+    atomic_int ref_count;
+    drmu_env_t * du;
+    int fd;
+    size_t page_size;
+};
+
+drmu_fb_t *
+drmu_fb_new_dmabuf_mod(drmu_dmabuf_env_t * const dde, const uint32_t w, const uint32_t h, const uint32_t format, const uint64_t mod)
+{
+    const drmu_fmt_info_t * const fmti = drmu_fmt_info_find_fmt(format);
+    drmu_env_t * const du = dde->du;
+    unsigned int i;
+    unsigned int layers;
+    unsigned int bypp;
+    uint32_t w2 = (w + 31) & ~31;
+    uint32_t h2 = (h + 15) & ~15;
+    drmu_fb_t * fb;
+    uint32_t offset = 0;
+
+    if (fmti == NULL) {
+        drmu_err(du, "%s: Format not found: %s", __func__, drmu_log_fourcc(format));
+        return NULL;
+    }
+
+    if ((fb = drmu_fb_int_alloc(du)) == NULL)
+        return NULL;
+
+    drmu_fb_int_fmt_size_set(fb, format, w, h, drmu_rect_wh(w, h));
+
+    layers = drmu_fmt_info_plane_count(fmti);
+    bypp = (drmu_fmt_info_pixel_bits(fmti) + 7) / 8;
+
+    for (offset = 0, i = 0; i != layers; ++i) {
+        const uint32_t stride = w2 * bypp / drmu_fmt_info_wdiv(fmti, i);
+        const uint32_t size = stride * h2 / drmu_fmt_info_hdiv(fmti, i);
+        offset += size;
+    }
+
+
+    {
+        struct dma_heap_allocation_data data = {
+            .len = (offset + dde->page_size - 1) & ~(dde->page_size - 1),
+            .fd = 0,
+            .fd_flags = O_RDWR | O_CLOEXEC,
+            .heap_flags = 0
+        };
+        void * map_ptr;
+        drmu_bo_t * bo;
+
+        while (ioctl(dde->fd, DMA_HEAP_IOCTL_ALLOC, &data)) {
+            const int err = errno;
+            if (err == EINTR)
+                continue;
+            drmu_err(dde->du, "Failed to alloc %" PRIu64 " from dma-heap(fd=%d): %d (%s)",
+                    (uint64_t)data.len, dde->fd, err, strerror(err));
+            goto fail;
+        }
+
+        drmu_fb_int_fd_set(fb, 0, data.fd);
+
+        if ((bo = drmu_bo_new_fd(du, data.fd)) == NULL) {
+            drmu_err(du, "%s: Failed to allocate BO", __func__);
+            goto fail;
+        }
+
+        drmu_fb_int_bo_set(fb, 0, bo);
+
+        if ((map_ptr = mmap(NULL, (size_t)data.len,
+                            PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,
+                            data.fd, 0)) == MAP_FAILED) {
+            drmu_err(du, "%s: mmap failed (size=%zd, fd=%d): %s", __func__,
+                     (size_t)data.len, data.fd, strerror(errno));
+            goto fail;
+        }
+
+        drmu_fb_int_mmap_set(fb, 0, map_ptr, (size_t)data.len, w2 * bypp);
+    }
+
+    for (offset = 0, i = 0; i != layers; ++i) {
+        const uint32_t stride = w2 * bypp / drmu_fmt_info_wdiv(fmti, i);
+        const uint32_t size = stride * h2 / drmu_fmt_info_hdiv(fmti, i);
+        drmu_fb_int_layer_mod_set(fb, i, 0, stride, offset, mod);
+        offset += size;
+    }
+
+    if (drmu_fb_int_make(fb))
+        goto fail;
+
+    return fb;
+
+fail:
+    drmu_fb_int_free(fb);
+    return NULL;
+}
+
+drmu_dmabuf_env_t *
+drmu_dmabuf_env_ref(drmu_dmabuf_env_t * const dde)
+{
+    atomic_fetch_add(&dde->ref_count, 1);
+    return dde;
+}
+
+void drmu_dmabuf_env_unref(drmu_dmabuf_env_t ** const ppdde)
+{
+    drmu_dmabuf_env_t * const dde = *ppdde;
+    if (dde == NULL)
+        return;
+    *ppdde = NULL;
+    if (atomic_fetch_sub(&dde->ref_count, 1) != 0)
+        return;
+
+    drmu_env_unref(&dde->du);
+    if (dde->fd != -1)
+        close(dde->fd);
+    free(dde);
+}
+
+drmu_dmabuf_env_t *
+drmu_dmabuf_env_new_fd(struct drmu_env_s * const du, const int fd)
+{
+    if (fd == -1) {
+        return NULL;
+    }
+    else {
+        drmu_dmabuf_env_t *const dde = calloc(1, sizeof(*dde));
+        if (dde == NULL) {
+            close(fd);
+            return NULL;
+        }
+        dde->du = drmu_env_ref(du);
+        dde->fd = fd;
+        dde->page_size = (size_t)sysconf(_SC_PAGE_SIZE);
+
+        return dde;
+    }
+}
+
+drmu_dmabuf_env_t *
+drmu_dmabuf_env_new_video(struct drmu_env_s * const du)
+{
+    static const char * const names[] = {
+        "/dev/dma_heap/vidbuf_cached",
+        "/dev/dma_heap/linux,cma",
+        "/dev/dma_heap/reserved",
+        NULL
+    };
+    const char * const * pfname;
+
+    for (pfname = names; *pfname != NULL; ++pfname) {
+        const int fd = open(*pfname, O_RDWR | O_CLOEXEC);
+        drmu_dmabuf_env_t * const dde = drmu_dmabuf_env_new_fd(du, fd);
+        if (dde != NULL)
+            return dde;
+    }
+    return NULL;
+}
+
+static drmu_fb_t *
+pool_dmabuf_alloc_cb(void * const v, const uint32_t w, const uint32_t h, const uint32_t format, const uint64_t mod)
+{
+    return drmu_fb_new_dmabuf_mod(v, w, h, format, mod);
+}
+
+static void
+pool_dmabuf_on_delete_cb(void * const v)
+{
+    drmu_dmabuf_env_t * dde = v;
+    drmu_dmabuf_env_unref(&dde);
+}
+
+drmu_pool_t *
+drmu_pool_new_dmabuf(drmu_dmabuf_env_t * dde, unsigned int total_fbs_max)
+{
+    static const drmu_pool_callback_fns_t fns = {
+        .alloc_fn = pool_dmabuf_alloc_cb,
+        .on_delete_fn = pool_dmabuf_on_delete_cb,
+        .try_reuse_fn = drmu_fb_try_reuse,
+    };
+    if (dde == NULL)
+        return NULL;
+    return drmu_pool_new_alloc(dde->du, total_fbs_max,
+                               &fns, drmu_dmabuf_env_ref(dde));
+}
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_dmabuf.h
@@ -0,0 +1,47 @@
+#ifndef _DRMU_DRMU_DMABUF_H
+#define _DRMU_DRMU_DMABUF_H
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct drmu_env_s;
+struct drmu_fb_s;
+struct drmu_pool_s;
+
+struct drmu_dmabuf_env_s;
+typedef struct drmu_dmabuf_env_s drmu_dmabuf_env_t;
+
+struct drmu_fb_s * drmu_fb_new_dmabuf_mod(drmu_dmabuf_env_t * const dde, const uint32_t w, const uint32_t h, const uint32_t format, const uint64_t mod);
+
+drmu_dmabuf_env_t * drmu_dmabuf_env_ref(drmu_dmabuf_env_t * const dde);
+void drmu_dmabuf_env_unref(drmu_dmabuf_env_t ** const ppdde);
+// Takes control of fd and will close it when the env is deleted
+// or on creation error so dup if it is needed to survive the pool
+drmu_dmabuf_env_t * drmu_dmabuf_env_new_fd(struct drmu_env_s * const du, int fd);
+
+drmu_dmabuf_env_t * drmu_dmabuf_env_new_video(struct drmu_env_s * const du);
+
+// Construct an fb pool from dmabufs
+// A reference to dde is held by the pool so it is safe to unref immediately
+// after this call
+// dde = NULL returns NULL safely
+struct drmu_pool_s * drmu_pool_new_dmabuf(drmu_dmabuf_env_t * dde, unsigned int total_fbs_max);
+
+// Convienience fn.
+static inline struct drmu_pool_s *
+drmu_pool_new_dmabuf_video(struct drmu_env_s * const du, unsigned int total_fbs_max)
+{
+    drmu_dmabuf_env_t * dde = drmu_dmabuf_env_new_video(du);
+    struct drmu_pool_s * const pool = drmu_pool_new_dmabuf(dde, total_fbs_max);
+    drmu_dmabuf_env_unref(&dde);
+    return pool;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/modules/video_output/drmu/drmu_fmts.c
@@ -0,0 +1,253 @@
+#include "drmu_fmts.h"
+
+#include <stddef.h>
+
+#include <libdrm/drm_fourcc.h>
+
+#ifndef HAS_SORTED_FMTS
+#define HAS_SORTED_FMTS 0
+#endif
+#ifndef BUILD_MK_SORTED_FMTS_H
+#define BUILD_MK_SORTED_FMTS_H 0
+#endif
+
+#ifndef DRM_FORMAT_P030
+#define DRM_FORMAT_P030 fourcc_code('P', '0', '3', '0')
+#endif
+
+// Format properties
+
+typedef struct drmu_fmt_info_s {
+    uint32_t fourcc;
+    uint8_t  bpp;  // For dumb BO alloc
+    uint8_t  bit_depth;  // For display
+    uint8_t  plane_count;
+    struct {
+        uint8_t wdiv;
+        uint8_t hdiv;
+    } planes[4];
+    drmu_chroma_siting_t chroma_siting;  // Default for this format (YUV420 = (0.0, 0.5), otherwise (0, 0)
+} drmu_fmt_info_t;
+
+#if BUILD_MK_SORTED_FMTS_H || !HAS_SORTED_FMTS
+
+#define P_ONE       {{.wdiv = 1, .hdiv = 1}}
+#define P_YC420     {{.wdiv = 1, .hdiv = 1}, {.wdiv = 1, .hdiv = 2}}
+#define P_YC422     {{.wdiv = 1, .hdiv = 1}, {.wdiv = 1, .hdiv = 1}}
+#define P_YC444     {{.wdiv = 2, .hdiv = 1}, {.wdiv = 1, .hdiv = 1}}  // Assumes doubled .bpp
+#define P_YUV420    {{.wdiv = 1, .hdiv = 1}, {.wdiv = 2, .hdiv = 2}, {.wdiv = 2, .hdiv = 2}}
+#define P_YUV422    {{.wdiv = 1, .hdiv = 1}, {.wdiv = 2, .hdiv = 1}, {.wdiv = 2, .hdiv = 1}}
+#define P_YUV444    {{.wdiv = 1, .hdiv = 1}, {.wdiv = 1, .hdiv = 1}, {.wdiv = 1, .hdiv = 1}}
+
+static
+// Not const when creating the sorted version 'cos we sort in place
+#if !BUILD_MK_SORTED_FMTS_H
+const
+#endif
+drmu_fmt_info_t format_info[] = {
+    { .fourcc = DRM_FORMAT_XRGB1555, .bpp = 16, .bit_depth = 5, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_XBGR1555, .bpp = 16, .bit_depth = 5, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_RGBX5551, .bpp = 16, .bit_depth = 5, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_BGRX5551, .bpp = 16, .bit_depth = 5, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_ARGB1555, .bpp = 16, .bit_depth = 5, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_ABGR1555, .bpp = 16, .bit_depth = 5, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_RGBA5551, .bpp = 16, .bit_depth = 5, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_BGRA5551, .bpp = 16, .bit_depth = 5, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_BGR565, .bpp = 16, .bit_depth = 5, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_RGB565, .bpp = 16, .bit_depth = 5, .plane_count = 1, .planes = P_ONE},
+
+    { .fourcc = DRM_FORMAT_RGB888, .bpp = 24, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_BGR888, .bpp = 24, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+
+    { .fourcc = DRM_FORMAT_XRGB8888, .bpp = 32, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_XBGR8888, .bpp = 32, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_RGBX8888, .bpp = 32, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_BGRX8888, .bpp = 32, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_ARGB8888, .bpp = 32, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_ABGR8888, .bpp = 32, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_RGBA8888, .bpp = 32, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_BGRA8888, .bpp = 32, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+
+    { .fourcc = DRM_FORMAT_XRGB2101010, .bpp = 32, .bit_depth = 10, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_XBGR2101010, .bpp = 32, .bit_depth = 10, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_RGBX1010102, .bpp = 32, .bit_depth = 10, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_BGRX1010102, .bpp = 32, .bit_depth = 10, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_ARGB2101010, .bpp = 32, .bit_depth = 10, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_ABGR2101010, .bpp = 32, .bit_depth = 10, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_RGBA1010102, .bpp = 32, .bit_depth = 10, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_BGRA1010102, .bpp = 32, .bit_depth = 10, .plane_count = 1, .planes = P_ONE},
+
+    { .fourcc = DRM_FORMAT_AYUV,        .bpp = 32, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_XYUV8888,    .bpp = 32, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_VUY888,      .bpp = 24, .bit_depth = 8, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_XVYU2101010, .bpp = 32, .bit_depth = 10, .plane_count = 1, .planes = P_ONE},
+
+    { .fourcc = DRM_FORMAT_XVYU12_16161616, .bpp = 64, .bit_depth = 12, .plane_count = 1, .planes = P_ONE},
+    { .fourcc = DRM_FORMAT_XVYU16161616, .bpp = 64, .bit_depth = 16, .plane_count = 1, .planes = P_ONE},
+
+    { .fourcc = DRM_FORMAT_YUYV, .bpp = 16, .bit_depth = 8, .plane_count = 1, .planes = P_ONE,
+        .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+    { .fourcc = DRM_FORMAT_YVYU, .bpp = 16, .bit_depth = 8, .plane_count = 1, .planes = P_ONE,
+        .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+    { .fourcc = DRM_FORMAT_VYUY, .bpp = 16, .bit_depth = 8, .plane_count = 1, .planes = P_ONE,
+        .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+    { .fourcc = DRM_FORMAT_UYVY, .bpp = 16, .bit_depth = 8, .plane_count = 1, .planes = P_ONE,
+        .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+
+    { .fourcc = DRM_FORMAT_NV12,   .bpp = 8,  .bit_depth = 8,  .plane_count = 2, .planes = P_YC420,
+      .chroma_siting = DRMU_CHROMA_SITING_LEFT_I },
+    { .fourcc = DRM_FORMAT_NV21,   .bpp = 8,  .bit_depth = 8,  .plane_count = 2, .planes = P_YC420,
+      .chroma_siting = DRMU_CHROMA_SITING_LEFT_I },
+    { .fourcc = DRM_FORMAT_P010,   .bpp = 16, .bit_depth = 10, .plane_count = 2, .planes = P_YC420,
+      .chroma_siting = DRMU_CHROMA_SITING_LEFT_I },
+    { .fourcc = DRM_FORMAT_NV16,   .bpp = 8,  .bit_depth = 8,  .plane_count = 2, .planes = P_YC422,
+      .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+    { .fourcc = DRM_FORMAT_NV61,   .bpp = 8,  .bit_depth = 8,  .plane_count = 2, .planes = P_YC422,
+      .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+    { .fourcc = DRM_FORMAT_NV24,   .bpp = 16, .bit_depth = 8,  .plane_count = 2, .planes = P_YC444,
+      .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+    { .fourcc = DRM_FORMAT_NV42,   .bpp = 16, .bit_depth = 8,  .plane_count = 2, .planes = P_YC444,
+      .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+
+    { .fourcc = DRM_FORMAT_YUV420, .bpp = 8, .bit_depth = 8, .plane_count = 3, .planes = P_YUV420,
+      .chroma_siting = DRMU_CHROMA_SITING_LEFT_I },
+    { .fourcc = DRM_FORMAT_YVU420, .bpp = 8, .bit_depth = 8, .plane_count = 3, .planes = P_YUV420,
+      .chroma_siting = DRMU_CHROMA_SITING_LEFT_I },
+    { .fourcc = DRM_FORMAT_YUV422, .bpp = 8, .bit_depth = 8, .plane_count = 3, .planes = P_YUV422,
+      .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+    { .fourcc = DRM_FORMAT_YUV422, .bpp = 8, .bit_depth = 8, .plane_count = 3, .planes = P_YUV422,
+      .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+    { .fourcc = DRM_FORMAT_YUV444, .bpp = 8, .bit_depth = 8, .plane_count = 3, .planes = P_YUV444,
+      .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+    { .fourcc = DRM_FORMAT_YUV444, .bpp = 8, .bit_depth = 8, .plane_count = 3, .planes = P_YUV444,
+      .chroma_siting = DRMU_CHROMA_SITING_TOP_LEFT_I },
+
+    // 3 pel in 32 bits. So code as 32bpp with wdiv 3.
+    { .fourcc = DRM_FORMAT_P030,   .bpp = 32, .bit_depth = 10, .plane_count = 2,
+      .planes = {{.wdiv = 3, .hdiv = 1}, {.wdiv = 3, .hdiv = 2}},
+      .chroma_siting = DRMU_CHROMA_SITING_LEFT_I },
+
+    { .fourcc = 0 }
+};
+#endif
+
+#if BUILD_MK_SORTED_FMTS_H
+// ---------------------------------------------------------------------------
+//
+// Sort & emit format table (not part of the lib)
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <inttypes.h>
+
+static const unsigned int format_count = sizeof(format_info)/sizeof(format_info[0]) - 1;  // Ignore null term in count
+
+static int sort_fn(const void * va, const void * vb)
+{
+    const drmu_fmt_info_t * a = va;
+    const drmu_fmt_info_t * b = vb;
+    return a->fourcc < b->fourcc ? -1 : a->fourcc == b->fourcc ? 0 : 1;
+}
+
+int
+main(int argc, char * argv[])
+{
+    FILE * f;
+    unsigned int i;
+
+    if (argc != 2) {
+        fprintf(stderr, "Needs output file only\n");
+        return 1;
+    }
+    if ((f = fopen(argv[1], "wt")) == NULL) {
+        fprintf(stderr, "Failed to open'%s'\n", argv[1]);
+        return 1;
+    }
+    qsort(format_info, format_count, sizeof(format_info[0]), sort_fn);
+
+    fprintf(f, "static const drmu_fmt_info_t format_info[] = {\n");
+    for (i = 0; i != format_count; ++i) {
+        const drmu_fmt_info_t * x = format_info + i;
+        unsigned int j;
+        fprintf(f, "{%#"PRIx32",%d,%d,%d,{", x->fourcc, x->bpp, x->bit_depth, x->plane_count);
+        for (j = 0; j != sizeof(x->planes)/sizeof(x->planes[0]); ++j) {
+            fprintf(f, "{%d,%d},", x->planes[j].wdiv, x->planes[j].hdiv);
+        }
+        fprintf(f, "},");
+        fprintf(f, "{%d,%d},", x->chroma_siting.x, x->chroma_siting.y);
+        fprintf(f, "},\n");
+    }
+    fprintf(f, "{0}\n};\n");
+    fprintf(f, "static const unsigned int format_count = %d;\n", format_count);
+
+    fclose(f);
+    return 0;
+}
+
+#else
+// ---------------------------------------------------------------------------
+//
+// Include sorted format table
+#if HAS_SORTED_FMTS
+#include "sorted_fmts.h"
+#endif
+
+const drmu_fmt_info_t *
+drmu_fmt_info_find_fmt(const uint32_t fourcc)
+{
+    if (!fourcc)
+        return NULL;
+#if HAS_SORTED_FMTS
+    unsigned int lo = 0;
+    unsigned int hi = format_count;
+
+    while (lo < hi) {
+        unsigned int x = (hi + lo) / 2;
+        if (format_info[x].fourcc == fourcc)
+            return &format_info[x];
+        if (format_info[x].fourcc < fourcc)
+            lo = x + 1;
+        else
+            hi = x;
+    }
+#else
+    for (const drmu_fmt_info_t * p = format_info; p->fourcc; ++p) {
+        if (p->fourcc == fourcc)
+            return p;
+    }
+#endif
+    return NULL;
+}
+
+unsigned int
+drmu_fmt_info_bit_depth(const drmu_fmt_info_t * const fmt_info)
+{
+    return !fmt_info ? 0 : fmt_info->bit_depth;
+}
+uint32_t drmu_fmt_info_fourcc(const drmu_fmt_info_t * const fmt_info)
+{
+    return fmt_info->fourcc;
+}
+unsigned int drmu_fmt_info_pixel_bits(const drmu_fmt_info_t * const fmt_info)
+{
+    return !fmt_info ? 0 : fmt_info->bpp;
+}
+unsigned int drmu_fmt_info_plane_count(const drmu_fmt_info_t * const fmt_info)
+{
+    return !fmt_info ? 0 : fmt_info->plane_count;
+}
+unsigned int drmu_fmt_info_wdiv(const drmu_fmt_info_t * const fmt_info, const unsigned int plane_n)
+{
+    return fmt_info->planes[plane_n].wdiv;
+}
+unsigned int drmu_fmt_info_hdiv(const drmu_fmt_info_t * const fmt_info, const unsigned int plane_n)
+{
+    return fmt_info->planes[plane_n].hdiv;
+}
+drmu_chroma_siting_t drmu_fmt_info_chroma_siting(const drmu_fmt_info_t * const fmt_info)
+{
+    return !fmt_info ? DRMU_CHROMA_SITING_TOP_LEFT : fmt_info->chroma_siting;
+}
+
+#endif
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_fmts.h
@@ -0,0 +1,31 @@
+#ifndef _DRMU_DRMU_FMTS_H
+#define _DRMU_DRMU_FMTS_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "drmu_chroma.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct drmu_fmt_info_s;
+typedef struct drmu_fmt_info_s drmu_fmt_info_t;
+
+const drmu_fmt_info_t * drmu_fmt_info_find_fmt(const uint32_t fourcc);
+
+unsigned int drmu_fmt_info_bit_depth(const drmu_fmt_info_t * const fmt_info);
+uint32_t drmu_fmt_info_fourcc(const drmu_fmt_info_t * const fmt_info);
+unsigned int drmu_fmt_info_pixel_bits(const drmu_fmt_info_t * const fmt_info);
+unsigned int drmu_fmt_info_plane_count(const drmu_fmt_info_t * const fmt_info);
+unsigned int drmu_fmt_info_wdiv(const drmu_fmt_info_t * const fmt_info, const unsigned int plane_n);
+unsigned int drmu_fmt_info_hdiv(const drmu_fmt_info_t * const fmt_info, const unsigned int plane_n);
+drmu_chroma_siting_t drmu_fmt_info_chroma_siting(const drmu_fmt_info_t * const fmt_info);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_log.h
@@ -0,0 +1,81 @@
+#ifndef _DRMU_DRMU_LOG_H
+#define _DRMU_DRMU_LOG_H
+
+#include <stdarg.h>
+#include <stdbool.h>
+
+struct drmu_env_s;
+
+enum drmu_log_level_e {
+        DRMU_LOG_LEVEL_NONE = -1,     // Max level specifier for nothing (not a real level)
+        DRMU_LOG_LEVEL_MESSAGE = 0,   // (Nearly) always printed info
+        DRMU_LOG_LEVEL_ERROR,         // Error
+        DRMU_LOG_LEVEL_WARNING,
+        DRMU_LOG_LEVEL_INFO,          // Interesting but not critical info
+        DRMU_LOG_LEVEL_DEBUG,         // Info only useful for debug
+        DRMU_LOG_LEVEL_ALL,           // Max level specifier for everything (not a real level)
+};
+
+typedef void drmu_log_fn(void * v, enum drmu_log_level_e level, const char * fmt, va_list vl);
+
+typedef struct drmu_log_env_s {
+        drmu_log_fn * fn;
+        void * v;
+        enum drmu_log_level_e max_level;
+} drmu_log_env_t;
+
+void drmu_log_generic(const struct drmu_log_env_s * const log, const enum drmu_log_level_e level,
+                      const char * const fmt, ...);
+
+// Char offset if file, line extracted - func still in format
+#define DRMU_LOG_FMT_OFFSET_FUNC        6
+// Char offset if file, line & fn extracted
+#define DRMU_LOG_FMT_OFFSET_FMT         10
+
+#define drmu_log_lvl(_log, _level, _fmt, ...) \
+    drmu_log_generic(_log, (_level), "%s:%u:%s: " _fmt, __FILE__, __LINE__, __func__, ##__VA_ARGS__)
+
+static inline bool
+drmu_log_lvl_test(const drmu_log_env_t * const log, const enum drmu_log_level_e lvl)
+{
+    return lvl <= log->max_level;
+}
+
+#define drmu_log_macro(_log, _level, _fmt, ...) do {\
+    const drmu_log_env_t * const _log2 = (_log);\
+    if (drmu_log_lvl_test(_log2, (_level)))\
+        drmu_log_lvl(_log2, (_level), _fmt, ##__VA_ARGS__);\
+} while (0)
+
+#define drmu_err_log(_log, ...)      drmu_log_macro((_log), DRMU_LOG_LEVEL_ERROR,   __VA_ARGS__)
+#define drmu_warn_log(_log, ...)     drmu_log_macro((_log), DRMU_LOG_LEVEL_WARNING, __VA_ARGS__)
+#define drmu_info_log(_log, ...)     drmu_log_macro((_log), DRMU_LOG_LEVEL_INFO,    __VA_ARGS__)
+#define drmu_debug_log(_log, ...)    drmu_log_macro((_log), DRMU_LOG_LEVEL_DEBUG,   __VA_ARGS__)
+
+#define drmu_err(_du, ...)      drmu_err_log(drmu_env_log(_du), __VA_ARGS__)
+#define drmu_warn(_du, ...)     drmu_warn_log(drmu_env_log(_du), __VA_ARGS__)
+#define drmu_info(_du, ...)     drmu_info_log(drmu_env_log(_du), __VA_ARGS__)
+#define drmu_debug(_du, ...)    drmu_debug_log(drmu_env_log(_du), __VA_ARGS__)
+
+static inline char drmu_log_safechar(int c)
+{
+    return (c < ' ' || c >=0x7f) ? '?' : c;
+}
+
+static inline const char * drmu_log_fourcc_to_str(char buf[5], uint32_t fcc)
+{
+    if (fcc == 0)
+        return "----";
+    buf[0] = drmu_log_safechar((fcc >> 0) & 0xff);
+    buf[1] = drmu_log_safechar((fcc >> 8) & 0xff);
+    buf[2] = drmu_log_safechar((fcc >> 16) & 0xff);
+    buf[3] = drmu_log_safechar((fcc >> 24) & 0xff);
+    buf[4] = 0;
+    return buf;
+}
+
+#define drmu_log_fourcc(fcc) drmu_log_fourcc_to_str((char[5]){0}, fcc)
+
+
+#endif
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_math.c
@@ -0,0 +1,43 @@
+#include "drmu_math.h"
+
+#include <limits.h>
+
+drmu_ufrac_t
+drmu_ufrac_reduce(drmu_ufrac_t x)
+{
+    static const unsigned int primes[] = {2,3,5,7,11,13,17,19,23,29,31,UINT_MAX};
+    const unsigned int * p;
+
+    // Deal with specials
+    if (x.den == 0) {
+        x.num = 0;
+        return x;
+    }
+    if (x.num == 0) {
+        x.den = 1;
+        return x;
+    }
+
+    // Shortcut the 1:1 common case - also ensures the default loop terminates
+    if (x.num == x.den) {
+        x.num = 1;
+        x.den = 1;
+        return x;
+    }
+
+    // As num != den, (num/UINT_MAX == 0 || den/UINT_MAX == 0) must be true
+    // so loop will terminate
+    for (p = primes;; ++p) {
+        const unsigned int n = *p;
+        for (;;) {
+            const unsigned int xd = x.den / n;
+            const unsigned int xn = x.num / n;
+            if (xn == 0 || xd == 0)
+                return x;
+            if (xn * n != x.num || xd * n != x.den)
+                break;
+            x.num = xn;
+            x.den = xd;
+        }
+    }
+}
--- /dev/null
+++ b/modules/video_output/drmu/drmu_math.h
@@ -0,0 +1,149 @@
+#ifndef _DRMU_DRMU_MATH_H
+#define _DRMU_DRMU_MATH_H
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct drmu_rect_s {
+    int32_t x, y;
+    uint32_t w, h;
+} drmu_rect_t;
+
+typedef struct drmu_ufrac_s {
+    unsigned int num;
+    unsigned int den;
+} drmu_ufrac_t;
+
+drmu_ufrac_t drmu_ufrac_reduce(drmu_ufrac_t x);
+
+static inline drmu_ufrac_t
+drmu_ufrac_invert(const drmu_ufrac_t x)
+{
+    return (drmu_ufrac_t){
+        .num = x.den,
+        .den = x.num
+    };
+}
+
+static inline int32_t
+drmu_rect_rescale_1s(int_fast32_t x, uint_fast32_t mul, uint_fast32_t div)
+{
+    const int_fast64_t m = x * (int_fast64_t)mul;
+    const uint_fast32_t d2 = div/2;
+    return div == 0 ? (int32_t)m :
+        m >= 0 ? (int32_t)(((uint_fast64_t)m + d2) / div) :
+            -(int32_t)(((uint_fast64_t)(-m) + d2) / div);
+}
+
+static inline uint32_t
+drmu_rect_rescale_1u(uint_fast32_t x, uint_fast32_t mul, uint_fast32_t div)
+{
+    const uint_fast64_t m = x * (uint_fast64_t)mul;
+    return (uint32_t)(div == 0 ? m : (m + div/2) / div);
+}
+
+static inline drmu_rect_t
+drmu_rect_rescale(const drmu_rect_t s, const drmu_rect_t mul, const drmu_rect_t div)
+{
+    return (drmu_rect_t){
+        .x = drmu_rect_rescale_1s(s.x - div.x, mul.w, div.w) + mul.x,
+        .y = drmu_rect_rescale_1s(s.y - div.y, mul.h, div.h) + mul.y,
+        .w = drmu_rect_rescale_1u(s.w,         mul.w, div.w),
+        .h = drmu_rect_rescale_1u(s.h,         mul.h, div.h)
+    };
+}
+
+static inline drmu_rect_t
+drmu_rect_add_xy(const drmu_rect_t a, const drmu_rect_t b)
+{
+    return (drmu_rect_t){
+        .x = a.x + b.x,
+        .y = a.y + b.y,
+        .w = a.w,
+        .h = a.h
+    };
+}
+
+static inline drmu_rect_t
+drmu_rect_wh(const unsigned int w, const unsigned int h)
+{
+    return (drmu_rect_t){
+        .x = 0,
+        .y = 0,
+        .w = w,
+        .h = h
+    };
+}
+
+static inline drmu_rect_t
+drmu_rect_shl16(const drmu_rect_t a)
+{
+    return (drmu_rect_t){
+        .x = a.x << 16,
+        .y = a.y << 16,
+        .w = a.w << 16,
+        .h = a.h << 16
+    };
+}
+
+static inline drmu_rect_t
+drmu_rect_shr16(const drmu_rect_t a)
+{
+    return (drmu_rect_t){
+        .x = a.x >> 16,
+        .y = a.y >> 16,
+        .w = a.w >> 16,
+        .h = a.h >> 16
+    };
+}
+
+static inline drmu_rect_t
+drmu_rect_shr_rnd(const drmu_rect_t a, unsigned int n)
+{
+    if (n == 0)
+        return a;
+    --n;
+    return (drmu_rect_t) {
+        .x = ((a.x >> n) + 1) >> 1,
+        .y = ((a.y >> n) + 1) >> 1,
+        .w = ((a.w >> n) + 1) >> 1,
+        .h = ((a.h >> n) + 1) >> 1
+    };
+}
+
+static inline drmu_rect_t
+drmu_rect_shr16_rnd(const drmu_rect_t a)
+{
+    return drmu_rect_shr_rnd(a, 16);
+}
+
+static inline drmu_rect_t
+drmu_rect_div_xy(const drmu_rect_t a, const unsigned int dx, const unsigned int dy)
+{
+    return (drmu_rect_t) {
+        .x = a.x / (int)dx,
+        .y = a.y / (int)dy,
+        .w = a.w / dx,
+        .h = a.h / dy
+    };
+}
+
+static inline  drmu_rect_t
+drmu_rect_transpose(const drmu_rect_t a)
+{
+    return (drmu_rect_t){
+        .x = a.y,
+        .y = a.x,
+        .w = a.h,
+        .h = a.w
+    };
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/modules/video_output/drmu/drmu_output.c
@@ -0,0 +1,589 @@
+#include "drmu_output.h"
+
+#include "drmu_fmts.h"
+#include "drmu_log.h"
+
+#include <errno.h>
+#include <stdatomic.h>
+#include <string.h>
+
+#include <libdrm/drm.h>
+#include <libdrm/drm_mode.h>
+
+// Update return value with a new one for cases where we don't stop on error
+static inline int rvup(int rv1, int rv2)
+{
+    return rv2 ? rv2 : rv1;
+}
+
+struct drmu_output_s {
+    atomic_int ref_count;
+
+    drmu_env_t * du;
+    drmu_crtc_t * dc;
+    unsigned int conn_n;
+    unsigned int conn_size;
+    drmu_conn_t ** dns;
+    bool has_max_bpc;
+    bool max_bpc_allow;
+    bool modeset_allow;
+    int mode_id;
+    drmu_mode_simple_params_t mode_params;
+
+    // These are expected to be static consts so no copy / no free
+    const drmu_fmt_info_t * fmt_info;
+    drmu_colorspace_t colorspace;
+    drmu_broadcast_rgb_t broadcast_rgb;
+
+    // HDR metadata
+    drmu_isset_t hdr_metadata_isset;
+    struct hdr_output_metadata hdr_metadata;
+};
+
+drmu_plane_t *
+drmu_output_plane_ref_primary(drmu_output_t * const dout)
+{
+    return drmu_plane_new_find_ref_type(dout->dc, DRMU_PLANE_TYPE_PRIMARY);
+}
+
+drmu_plane_t *
+drmu_output_plane_ref_other(drmu_output_t * const dout)
+{
+    return drmu_plane_new_find_ref_type(dout->dc, DRMU_PLANE_TYPE_CURSOR | DRMU_PLANE_TYPE_OVERLAY);
+}
+
+struct plane_format_s {
+    unsigned int types;
+    uint32_t fmt;
+    uint64_t mod;
+};
+
+static bool plane_find_format_cb(const drmu_plane_t * dp, void * v)
+{
+    const struct plane_format_s * const f = v;
+    return (f->types & drmu_plane_type(dp)) != 0 &&
+        drmu_plane_format_check(dp, f->fmt, f->mod);
+}
+
+drmu_plane_t *
+drmu_output_plane_ref_format(drmu_output_t * const dout, const unsigned int types, const uint32_t format, const uint64_t mod)
+{
+    struct plane_format_s fm = {
+        .types = (types != 0) ? types : (DRMU_PLANE_TYPE_PRIMARY |  DRMU_PLANE_TYPE_CURSOR | DRMU_PLANE_TYPE_OVERLAY),
+        .fmt = format,
+        .mod = mod
+    };
+
+    return drmu_plane_new_find_ref(dout->dc, plane_find_format_cb, &fm);
+}
+
+
+int
+drmu_atomic_output_add_connect(drmu_atomic_t * const da, drmu_output_t * const dout)
+{
+    int rv;
+
+    if ((rv = drmu_atomic_crtc_add_active(da, dout->dc, 1)) != 0)
+        return rv;
+
+    for (unsigned int i = 0; i != dout->conn_n; ++i) {
+        if ((rv = drmu_atomic_conn_add_crtc(da, dout->dns[i], dout->dc)) != 0)
+            return rv;
+    }
+
+    return 0;
+}
+
+int
+drmu_atomic_output_add_props(drmu_atomic_t * const da, drmu_output_t * const dout)
+{
+    int rv = 0;
+    unsigned int i;
+
+    if (!dout->modeset_allow)
+        return 0;
+
+    rv = drmu_atomic_crtc_add_modeinfo(da, dout->dc, drmu_conn_modeinfo(dout->dns[0], dout->mode_id));
+
+    for (i = 0; i != dout->conn_n; ++i) {
+        drmu_conn_t * const dn = dout->dns[i];
+
+        if (dout->fmt_info && dout->max_bpc_allow)
+            rv = rvup(rv, drmu_atomic_conn_add_hi_bpc(da, dn, (drmu_fmt_info_bit_depth(dout->fmt_info) > 8)));
+        if (drmu_colorspace_is_set(dout->colorspace))
+            rv = rvup(rv, drmu_atomic_conn_add_colorspace(da, dn, dout->colorspace));
+        if (drmu_broadcast_rgb_is_set(dout->broadcast_rgb))
+            rv = rvup(rv, drmu_atomic_conn_add_broadcast_rgb(da, dn, dout->broadcast_rgb));
+        if (dout->hdr_metadata_isset != DRMU_ISSET_UNSET)
+            rv = rvup(rv, drmu_atomic_conn_add_hdr_metadata(da, dn,
+                dout->hdr_metadata_isset == DRMU_ISSET_NULL ? NULL : &dout->hdr_metadata));
+    }
+
+    return rv;
+}
+
+// Set all the fb info props that might apply to a crtc on the crtc
+// (e.g. hdr_metadata, colorspace) but do not set the mode (resolution
+// and refresh)
+//
+// N.B. Only changes those props that are set in the fb. If unset in the fb
+// then their value is unchanged.
+int
+drmu_output_fb_info_set(drmu_output_t * const dout, const drmu_fb_t * const fb)
+{
+    const drmu_isset_t hdr_isset = drmu_fb_hdr_metadata_isset(fb);
+    const drmu_fmt_info_t * fmt_info = drmu_fb_format_info_get(fb);
+    const drmu_colorspace_t colorspace  = drmu_fb_colorspace_get(fb);
+    const drmu_broadcast_rgb_t broadcast_rgb = drmu_color_range_to_broadcast_rgb(drmu_fb_color_range_get(fb));
+
+    if (fmt_info)
+        dout->fmt_info = fmt_info;
+    if (drmu_colorspace_is_set(colorspace))
+        dout->colorspace = colorspace;
+    if (drmu_broadcast_rgb_is_set(broadcast_rgb))
+        dout->broadcast_rgb = broadcast_rgb;
+
+    if (hdr_isset != DRMU_ISSET_UNSET) {
+        dout->hdr_metadata_isset = hdr_isset;
+        if (hdr_isset == DRMU_ISSET_SET)
+            dout->hdr_metadata = *drmu_fb_hdr_metadata_get(fb);
+    }
+
+    return 0;
+}
+
+void
+drmu_output_fb_info_unset(drmu_output_t * const dout)
+{
+    dout->fmt_info = NULL;
+    dout->colorspace = DRMU_COLORSPACE_UNSET;
+    dout->broadcast_rgb = DRMU_BROADCAST_RGB_UNSET;
+    dout->hdr_metadata_isset = DRMU_ISSET_UNSET;
+}
+
+
+int
+drmu_output_mode_id_set(drmu_output_t * const dout, const int mode_id)
+{
+    drmu_info(dout->du, "%s: mode_id=%d", __func__, mode_id);
+
+    if (mode_id != dout->mode_id) {
+        drmu_mode_simple_params_t sp = drmu_conn_mode_simple_params(dout->dns[0], mode_id);
+        if (sp.width == 0)
+            return -EINVAL;
+
+        dout->mode_id = mode_id;
+        dout->mode_params = sp;
+    }
+    return 0;
+}
+
+const drmu_mode_simple_params_t *
+drmu_output_mode_simple_params(const drmu_output_t * const dout)
+{
+    return &dout->mode_params;
+}
+
+static int
+score_freq(const drmu_mode_simple_params_t * const mode, const drmu_mode_simple_params_t * const p)
+{
+    const int pref = (mode->type & DRM_MODE_TYPE_PREFERRED) != 0;
+    const unsigned int r_m = (mode->flags & DRM_MODE_FLAG_INTERLACE) != 0 ?
+        mode->hz_x_1000 * 2: mode->hz_x_1000;
+    const unsigned int r_f = (p->flags & DRM_MODE_FLAG_INTERLACE) != 0 ?
+        p->hz_x_1000 * 2 : p->hz_x_1000;
+
+    // If we haven't been given any hz then pick pref or fastest
+    // Max out at 300Hz (=300,0000)
+    if (r_f == 0)
+        return pref ? 83000000 : 80000000 + (r_m >= 2999999 ? 2999999 : r_m);
+    // Prefer a good match to 29.97 / 30 but allow the other
+    else if ((r_m + 10 >= r_f && r_m <= r_f + 10))
+        return 100000000;
+    else if ((r_m + 100 >= r_f && r_m <= r_f + 100))
+        return 95000000;
+    // Double isn't bad
+    else if ((r_m + 10 >= r_f * 2 && r_m <= r_f * 2 + 10))
+        return 90000000;
+    else if ((r_m + 100 >= r_f * 2 && r_m <= r_f * 2 + 100))
+        return 85000000;
+    return -1;
+}
+
+// Avoid interlace no matter what our source
+int
+drmu_mode_pick_simple_cb(void * v, const drmu_mode_simple_params_t * mode)
+{
+    const drmu_mode_simple_params_t * const p = v;
+    const int pref = (mode->type & DRM_MODE_TYPE_PREFERRED) != 0;
+    int score = -1;
+
+    if (p->width == mode->width && p->height == mode->height &&
+        (mode->flags & DRM_MODE_FLAG_INTERLACE) == 0)
+        score = score_freq(mode, p);
+
+    if (score > 0 && (p->width != mode->width || p->height != mode->height))
+        score -= 30000000;
+
+    if (score <= 0 && pref)
+        score = 10000000;
+
+    return score;
+}
+
+// Pick the preferred mode or the 1st one if nothing preferred
+int
+drmu_mode_pick_simple_preferred_cb(void * v, const drmu_mode_simple_params_t * mode)
+{
+    (void)v;
+    return (mode->type & DRM_MODE_TYPE_PREFERRED) != 0 ? 1 : 0;
+}
+
+// Try to match interlace as well as everything else
+int
+drmu_mode_pick_simple_interlace_cb(void * v, const drmu_mode_simple_params_t * mode)
+{
+    const drmu_mode_simple_params_t * const p = v;
+
+    const int pref = (mode->type & DRM_MODE_TYPE_PREFERRED) != 0;
+    int score = -1;
+
+    if (p->width == mode->width && p->height == mode->height)
+        score = score_freq(mode, p);
+
+    if (score > 0 && (p->width != mode->width || p->height != mode->height))
+        score -= 30000000;
+    if (((mode->flags ^ p->flags) & DRM_MODE_FLAG_INTERLACE) != 0)
+        score -= 20000000;
+
+    if (score <= 0 && pref)
+        score = 10000000;
+
+    return score;
+}
+
+
+int
+drmu_output_mode_pick_simple(drmu_output_t * const dout, drmu_mode_score_fn * const score_fn, void * const score_v)
+{
+    int best_score = -1;
+    int best_mode = -1;
+    int i;
+
+    for (i = 0;; ++i) {
+        const drmu_mode_simple_params_t sp = drmu_conn_mode_simple_params(dout->dns[0], i);
+        int score;
+
+        if (sp.width == 0)
+            break;
+
+        score = score_fn(score_v, &sp);
+        if (score > best_score) {
+            best_score = score;
+            best_mode = i;
+        }
+    }
+
+    return best_mode;
+}
+
+int
+drmu_output_max_bpc_allow(drmu_output_t * const dout, const bool allow)
+{
+    dout->max_bpc_allow = allow && dout->has_max_bpc;
+    return allow && !dout->has_max_bpc ? -ENOENT : 0;
+}
+
+int
+drmu_output_modeset_allow(drmu_output_t * const dout, const bool allow)
+{
+    dout->modeset_allow = allow;
+    return 0;
+}
+
+static int
+check_conns_size(drmu_output_t * const dout)
+{
+    if (dout->conn_n >= dout->conn_size) {
+        unsigned int n = !dout->conn_n ? 4 : dout->conn_n * 2;
+        drmu_conn_t ** dns = realloc(dout->dns, sizeof(*dout->dns) * n);
+        if (dns == NULL) {
+            drmu_err(dout->du, "Failed conn array realloc");
+            return -ENOMEM;
+        }
+        dout->dns = dns;
+        dout->conn_size = n;
+    }
+    return 0;
+}
+
+// Experimental, more flexible version of _add_output
+
+static drmu_crtc_t *
+output_add_find_crtc(drmu_env_t * const du, drmu_conn_t * const dn)
+{
+    uint32_t possible_crtcs = drmu_conn_possible_crtcs(dn);
+    drmu_crtc_t * dc;
+
+    for (unsigned int i = 0; possible_crtcs != 0; ++i, possible_crtcs >>= 1) {
+        if ((possible_crtcs & 1) == 0)
+            continue;
+        if ((dc = drmu_env_crtc_find_n(du, i)) == NULL)
+            continue;
+        if (drmu_crtc_is_claimed(dc))
+            continue;
+
+        return dc;
+    }
+    return NULL;
+}
+
+int
+drmu_output_add_output2(drmu_output_t * const dout, const char * const conn_name, const unsigned int flags)
+{
+    const size_t nlen = !conn_name ? 0 : strlen(conn_name);
+    unsigned int retries = 0;
+    drmu_env_t * const du = dout->du;
+    drmu_conn_t * dn;
+    drmu_conn_t * dn_t;
+    drmu_crtc_t * dc;
+    int rv;
+    const bool wants_writeback = ((flags & DRMU_OUTPUT_FLAG_ADD_WRITEBACK) != 0);
+    const bool try_connected = (flags & DRMU_OUTPUT_FLAG_ADD_DISCONNECTED_ONLY) == 0;
+    const bool try_disconnected = (flags & DRMU_OUTPUT_FLAG_ADD_DISCONNECTED_ONLY) != 0 ||
+        (flags & DRMU_OUTPUT_FLAG_ADD_ANY) != 0 ||
+        (flags & DRMU_OUTPUT_FLAG_ADD_DISCONNECTED) != 0;
+
+    if (wants_writeback && !dout->modeset_allow) {
+        drmu_debug(du, "modeset_allow required for writeback");
+        return -EINVAL;
+    }
+
+    retry:
+    if (++retries > 16) {
+        drmu_err(du, "Retry count exceeded");
+        return -EBUSY;
+    }
+    dn = NULL;
+    dc = NULL;
+
+    for (unsigned int i = 0; (dn_t = drmu_env_conn_find_n(du, i)) != NULL; ++i) {
+        drmu_crtc_t * dc_t;
+        uint32_t crtc_id;
+
+        if ((wants_writeback && !drmu_conn_is_writeback(dn_t)) ||
+            (!wants_writeback && !drmu_conn_is_output(dn_t)))
+            continue;
+        if (drmu_conn_is_claimed(dn_t))
+            continue;
+
+        if (nlen && strncmp(conn_name, drmu_conn_name(dn_t), nlen) != 0)
+            continue;
+
+        crtc_id = drmu_conn_crtc_id_get(dn_t);
+        if (crtc_id != 0 && try_connected) {
+            dc_t = drmu_env_crtc_find_id(du, crtc_id);
+            if (dc_t == NULL || drmu_crtc_is_claimed(dc_t))
+                continue;
+            dn = dn_t;
+            dc = dc_t;
+            break;
+        }
+        else if (crtc_id == 0 && try_disconnected) {
+            dc_t = output_add_find_crtc(du, dn_t);
+            if (dc_t == NULL || drmu_crtc_is_claimed(dc_t))
+                continue;
+            dn = dn_t;
+            dc = dc_t;
+            if ((flags & DRMU_OUTPUT_FLAG_ADD_ANY) != 0 || !try_connected)
+                break;
+        }
+    }
+
+    if (!dn)
+        return -ENOENT;
+
+    if ((rv = check_conns_size(dout)) != 0)
+        return rv;
+
+    if (drmu_crtc_claim_ref(dc)) {
+        drmu_debug(du, "Crtc already claimed");
+        goto retry;
+    }
+    if (drmu_conn_claim_ref(dn)) {
+        drmu_debug(du, "Conn already claimed");
+        drmu_crtc_unref(&dc);
+        goto retry;
+    }
+
+    // Test features
+    dout->has_max_bpc = drmu_conn_has_hi_bpc(dn);
+
+    dout->dns[dout->conn_n++] = dn;
+    dout->dc = dc;
+
+    dout->mode_params = drmu_crtc_mode_simple_params(dout->dc);
+
+    return 0;
+}
+
+int
+drmu_output_add_output(drmu_output_t * const dout, const char * const conn_name)
+{
+    return drmu_output_add_output2(dout, conn_name, 0);
+}
+
+int
+drmu_output_add_writeback(drmu_output_t * const dout)
+{
+    return drmu_output_add_output2(dout, NULL, DRMU_OUTPUT_FLAG_ADD_WRITEBACK | DRMU_OUTPUT_FLAG_ADD_ANY);
+}
+
+static struct drm_mode_modeinfo
+modeinfo_fake(unsigned int w, unsigned int h)
+{
+    return (struct drm_mode_modeinfo){
+        .clock = (h + 30)*(w + 20)*60,
+        .hdisplay = w,
+        .hsync_start = w + 10,
+        .hsync_end = w + 20,
+        .htotal = w + 30,
+        .hskew = 0,
+        .vdisplay = h,
+        .vsync_start = h + 10,
+        .vsync_end = h + 12,
+        .vtotal = h + 20,
+        .vscan = 0,
+        .vrefresh = 60,
+        .type = DRM_MODE_TYPE_USERDEF,
+        .flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+        .name = {"fake"},
+    };
+}
+
+int
+drmu_atomic_output_add_writeback_fb_callback(drmu_atomic_t * const da_out, drmu_output_t * const dout,
+                                    drmu_fb_t * const dfb, const unsigned int rot,
+                                    drmu_fb_fence_fd_fn * const fn, void * const v)
+{
+    drmu_env_t * const du = dout->du;
+    drmu_atomic_t * da = drmu_atomic_new(drmu_atomic_env(da_out));
+    int rv;
+    struct drm_mode_modeinfo mode = !drmu_rotation_is_transposed(rot) ?
+        modeinfo_fake(drmu_fb_width(dfb), drmu_fb_height(dfb)) :
+        modeinfo_fake(drmu_fb_height(dfb), drmu_fb_width(dfb));
+    drmu_conn_t * const dn = dout->dns[0];
+
+    if (da == NULL) {
+        if (fn)
+            fn(v, -1, NULL);
+        return -ENOMEM;
+    }
+
+    if ((rv = drmu_atomic_conn_add_writeback_fb(da, dn, dfb, fn, v)) != 0) {
+        drmu_err(du, "Failed to add FB to conn");
+        goto fail;
+    }
+    if ((rv = drmu_atomic_conn_add_rotation(da, dn, rot)) != 0) {
+        drmu_err(du, "Failed to add rotation to conn");
+        goto fail;
+    }
+    if ((rv = drmu_atomic_crtc_add_modeinfo(da, dout->dc, &mode)) != 0) {
+        drmu_err(du, "Failed to add modeinfo to CRTC");
+        goto fail;
+    }
+    if ((rv = drmu_atomic_conn_add_crtc(da, dn, dout->dc)) != 0) {
+        drmu_err(du, "Failed to add CRTC to Conn");
+        goto fail;
+    }
+    if ((rv = drmu_atomic_crtc_add_active(da, dout->dc, 1)) != 0) {
+        drmu_err(du, "Failed to add Active to Conn");
+        goto fail;
+    }
+
+    return drmu_atomic_merge(da_out, &da);
+
+fail:
+    drmu_atomic_unref(&da);
+    return rv;
+}
+
+int
+drmu_atomic_output_add_writeback_fb_rotate(drmu_atomic_t * const da_out, drmu_output_t * const dout,
+                                    drmu_fb_t * const dfb, const unsigned int rot)
+{
+    return drmu_atomic_output_add_writeback_fb_callback(da_out, dout, dfb, rot, NULL, NULL);
+}
+
+int
+drmu_atomic_output_add_writeback_fb(drmu_atomic_t * const da_out, drmu_output_t * const dout,
+                                    drmu_fb_t * const dfb)
+{
+    return drmu_atomic_output_add_writeback_fb_rotate(da_out, dout, dfb, DRMU_ROTATION_0);
+}
+
+drmu_crtc_t *
+drmu_output_crtc(const drmu_output_t * const dout)
+{
+    return !dout ? NULL : dout->dc;
+}
+
+drmu_conn_t *
+drmu_output_conn(const drmu_output_t * const dout, const unsigned int n)
+{
+    return !dout || n >= dout->conn_n ? NULL : dout->dns[n];
+}
+
+drmu_env_t *
+drmu_output_env(const drmu_output_t * const dout)
+{
+    return dout->du;
+}
+
+static void
+output_free(drmu_output_t * const dout)
+{
+    unsigned int i;
+    for (i = 0; i != dout->conn_n; ++i)
+        drmu_conn_unref(dout->dns + i);
+    free(dout->dns);
+    drmu_crtc_unref(&dout->dc);
+    drmu_env_unref(&dout->du);
+    free(dout);
+}
+
+void
+drmu_output_unref(drmu_output_t ** const ppdout)
+{
+    drmu_output_t * const dout = *ppdout;
+    if (dout == NULL)
+        return;
+    *ppdout = NULL;
+
+    if (atomic_fetch_sub(&dout->ref_count, 1) == 0)
+        output_free(dout);
+}
+
+drmu_output_t *
+drmu_output_ref(drmu_output_t * const dout)
+{
+    if (dout != NULL)
+        atomic_fetch_add(&dout->ref_count, 1);
+    return dout;
+}
+
+drmu_output_t *
+drmu_output_new(drmu_env_t * const du)
+{
+    drmu_output_t * const dout = calloc(1, sizeof(*dout));
+
+    if (dout == NULL) {
+        drmu_err(du, "Failed to alloc memory for drmu_output");
+        return NULL;
+    }
+
+    dout->du = drmu_env_ref(du);
+    dout->mode_id = -1;
+    return dout;
+}
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_output.h
@@ -0,0 +1,114 @@
+#ifndef _DRMU_DRMU_OUTPUT_H
+#define _DRMU_DRMU_OUTPUT_H
+
+#include "drmu.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct drmu_output_s;
+typedef struct drmu_output_s drmu_output_t;
+
+drmu_plane_t * drmu_output_plane_ref_primary(drmu_output_t * const dout);
+drmu_plane_t * drmu_output_plane_ref_other(drmu_output_t * const dout);
+// Find and ref a plane that supports the given format & mod on the current crtc
+// Types is a bit field of acceptable plane types (DRMU_PLANE_TYPE_xxx), 0 => any
+//
+// add_output must be called before this (so we have a crtc to check against)
+drmu_plane_t * drmu_output_plane_ref_format(drmu_output_t * const dout, const unsigned int types, const uint32_t format, const uint64_t mod);
+
+// Add all props accumulated on the output to the atomic
+int drmu_atomic_output_add_props(drmu_atomic_t * const da, drmu_output_t * const dout);
+// Add activate & CRTC connect props - only needed if output started off disconnected
+int drmu_atomic_output_add_connect(drmu_atomic_t * const da, drmu_output_t * const dout);
+
+// Set FB info (bit-depth, HDR metadata etc.)
+// Only sets properties that are set in the fb - retains previous value otherwise
+int drmu_output_fb_info_set(drmu_output_t * const dout, const drmu_fb_t * const fb);
+// Unset all FB info
+// (set only sets stuff that is set in the fb, so will never clear anything)
+void drmu_output_fb_info_unset(drmu_output_t * const dout);
+
+// Set output mode
+int drmu_output_mode_id_set(drmu_output_t * const dout, const int mode_id);
+
+// Width/height of the current mode
+const drmu_mode_simple_params_t * drmu_output_mode_simple_params(const drmu_output_t * const dout);
+
+typedef int drmu_mode_score_fn(void * v, const drmu_mode_simple_params_t * mode);
+
+int drmu_output_mode_pick_simple(drmu_output_t * const dout, drmu_mode_score_fn * const score_fn, void * const score_v);
+
+// Simple mode picker cb - looks for width / height and then refresh
+// If nothing "plausible" defaults to EDID preferred mode
+drmu_mode_score_fn drmu_mode_pick_simple_cb;
+// As above but may choose an interlaced mode
+drmu_mode_score_fn drmu_mode_pick_simple_interlace_cb;
+// Just pick a preferred mode
+drmu_mode_score_fn drmu_mode_pick_simple_preferred_cb;
+
+// Allow fb max_bpc info to set the output mode (default false)
+int drmu_output_max_bpc_allow(drmu_output_t * const dout, const bool allow);
+
+// Allow fb to set modes generally
+int drmu_output_modeset_allow(drmu_output_t * const dout, const bool allow);
+
+// Add a CONN/CRTC pair to an output
+// If conn_name == NULL then 1st connected connector is used
+// If != NULL then 1st conn with prefix-matching name is used
+int drmu_output_add_output(drmu_output_t * const dout, const char * const conn_name);
+
+// Allow _add_output2 to add a disconnected connect & asign a compatible CRTC
+// Mode select and active will have to happen later
+
+// Search disconnected conns too; but prefer connected
+#define DRMU_OUTPUT_FLAG_ADD_DISCONNECTED       1
+// Pick the first one we find; connected or disconnected
+#define DRMU_OUTPUT_FLAG_ADD_ANY                2
+// Only search disconnected
+#define DRMU_OUTPUT_FLAG_ADD_DISCONNECTED_ONLY  4
+// Only search writeback connectors; otherwise only search output connectors
+#define DRMU_OUTPUT_FLAG_ADD_WRITEBACK          8
+
+// Experimental, more flexible version of _add_output
+int drmu_output_add_output2(drmu_output_t * const dout, const char * const conn_name, const unsigned int flags);
+
+// Set writeback fb on output - rotation 0
+int drmu_atomic_output_add_writeback_fb(drmu_atomic_t * const da_req, drmu_output_t * const dout,
+                                    drmu_fb_t * const dfb);
+
+// Set writeback fb on output - also set rotation on conn
+int drmu_atomic_output_add_writeback_fb_rotate(drmu_atomic_t * const da_out, drmu_output_t * const dout,
+                                    drmu_fb_t * const dfb, const unsigned int rot);
+
+int drmu_atomic_output_add_writeback_fb_callback(drmu_atomic_t * const da_out, drmu_output_t * const dout,
+                                    drmu_fb_t * const dfb, const unsigned int rot,
+                                    drmu_fb_fence_fd_fn * const fn, void * const v);
+
+// Add a writeback connector & find a crtc for it
+int drmu_output_add_writeback(drmu_output_t * const dout);
+
+// Conn & CRTC for when output isn't fine grained enough
+drmu_crtc_t * drmu_output_crtc(const drmu_output_t * const dout);
+drmu_conn_t * drmu_output_conn(const drmu_output_t * const dout, const unsigned int n);
+
+// Return the in-use drmu environment
+drmu_env_t * drmu_output_env(const drmu_output_t * const dout);
+
+// Create a new empty output - has no crtc or conn
+// Takes a ref on the env  (released when the output is deleted)
+drmu_output_t * drmu_output_new(drmu_env_t * const du);
+
+// Increment ref count on an output - cannot fail
+drmu_output_t * drmu_output_ref(drmu_output_t * const dout);
+// Unref an output - delete if ref count now zero
+void drmu_output_unref(drmu_output_t ** const ppdout);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_poll.c
@@ -0,0 +1,549 @@
+// Functions to merge commits onto the next vsync without blocking
+// Keeps references to everything that is in use
+//
+// Merged commits for the next flip are committed on the previous
+// flips callback. This is very safe timing-wise and requires no knowledge
+// of vsync rates but gives a worst case latency of nearly 2 flips for any
+// given commit.
+
+#include "drmu_poll.h"
+
+#include "drmu.h"
+#include "drmu_log.h"
+#include "pollqueue.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <stdatomic.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <libdrm/drm_mode.h>
+
+//----------------------------------------------------------------------------
+//
+// Atomic Q fns (internal)
+
+typedef struct flips_ent_s {
+    drmu_atomic_t * da;
+    unsigned int tag;
+} flip_ent_t;
+
+typedef struct next_flips_s {
+    flip_ent_t * flips;
+    unsigned int len;
+    unsigned int size;
+    unsigned int n;
+} next_flips_t;
+
+static bool
+next_flip_is_empty(const next_flips_t * const nf)
+{
+    return nf->len == 0;
+}
+
+static drmu_atomic_t *
+next_flip_head(const next_flips_t * const nf)
+{
+    return next_flip_is_empty(nf) ? NULL : nf->flips[nf->n].da;
+}
+
+static drmu_atomic_t **
+next_flip_find_tag(const next_flips_t * const nf, const unsigned int tag)
+{
+    unsigned int n;
+    unsigned int i;
+
+    n = nf->n + nf->len - 1 < nf->size ?
+        nf->n + nf->len - 1 :
+        nf->n + nf->len - 1 - nf->size;
+
+    for (i = 0; i != nf->len; ++i) {
+        if (nf->flips[n].tag == tag)
+            return &nf->flips[n].da;
+        n = (n == 0) ? nf->size - 1 : n - 1;
+    }
+    return NULL;
+}
+
+static drmu_atomic_t *
+next_flip_pop_head(next_flips_t * const nf)
+{
+    drmu_atomic_t * flip;
+
+    if (next_flip_is_empty(nf))
+        return NULL;
+    flip = nf->flips[nf->n].da;
+    nf->n = nf->n + 1 >= nf->size ? 0 : nf->n + 1;
+    --nf->len;
+    return flip;
+}
+
+static drmu_atomic_t **
+next_flip_add_tail(next_flips_t * const nf, unsigned int tag)
+{
+    const unsigned int oldlen = nf->len;
+
+    if (oldlen < nf->size) {
+        unsigned int n = nf->n + oldlen;
+        if (n >= nf->size)
+            n -= nf->size;
+        nf->flips[n].da = NULL;
+        nf->flips[n].tag = tag;
+        ++nf->len;
+        return &nf->flips[n].da;
+    }
+    else {
+        // Given the circular buffer can't just realloc, must alloc & rebuild
+        const unsigned int newsize = (oldlen < 8) ? 8 : oldlen * 2;
+        flip_ent_t * newflips = malloc(sizeof(*nf->flips) * newsize);
+        if (newflips == NULL)
+            return NULL;
+
+        assert(oldlen == nf->size);
+        memcpy(newflips, nf->flips + nf->n, (nf->size - nf->n) * sizeof(*nf->flips));
+        memcpy(newflips + (nf->size - nf->n), nf->flips, nf->n * sizeof(*nf->flips));
+        newflips[oldlen].da = NULL;
+        newflips[oldlen].tag = tag;
+        free(nf->flips);
+
+        nf->flips = newflips;
+        nf->size = newsize;
+        nf->len = oldlen + 1;
+        nf->n = 0;
+
+        return &newflips[oldlen].da;
+    }
+}
+
+static bool
+next_flip_discard_head(next_flips_t * const nf)
+{
+    drmu_atomic_t * da = next_flip_pop_head(nf);
+    if (da == NULL)
+        return false;
+    drmu_atomic_unref(&da);
+    return true;
+}
+
+static void
+next_flip_init(next_flips_t * const nf)
+{
+    memset(nf, 0, sizeof(*nf));
+}
+
+// Zap next flip q - leaves in a state that a new add will work
+static void
+next_flip_uninit(next_flips_t * const nf)
+{
+    while (!next_flip_is_empty(nf)) {
+        drmu_atomic_run_commit_callbacks(next_flip_head(nf));
+        next_flip_discard_head(nf);
+    }
+    free(nf->flips);
+    memset(nf, 0, sizeof(*nf));
+}
+
+//-----------------------------------------------------------------------------
+
+struct drmu_queue_s {
+    atomic_int ref_count;
+
+    drmu_env_t * du;
+
+    bool discard_last;
+    bool lock_on_commit;
+    bool locked;
+    unsigned int retry_count;
+    unsigned int qno; // Handy for debug
+
+    pthread_mutex_t lock;
+    pthread_cond_t cond;
+    next_flips_t next;
+    drmu_atomic_t * cur_flip;
+    drmu_atomic_t * last_flip;
+
+    bool wants_prod;
+    struct pollqueue * pq;
+    struct polltask * prod_pt;
+
+    // Finish vars
+    bool env_restore_req;
+    sem_t * finish_sem;
+};
+
+static void
+queue_prod_cb(void * v, short revents)
+{
+    drmu_queue_t * const aq = v;
+    drmu_env_t * const du = aq->du;
+    (void)revents;
+    uint32_t flags = DRM_MODE_ATOMIC_ALLOW_MODESET;
+    unsigned int prod_time = 0;
+    int rv;
+
+    // cur_flip, last_flip only used here so can be used outside lock
+
+    pthread_mutex_lock(&aq->lock);
+
+    if (!aq->locked) {
+        if (aq->cur_flip == NULL)
+            aq->cur_flip = next_flip_pop_head(&aq->next);
+        if (aq->cur_flip != NULL)
+            aq->locked = aq->lock_on_commit;
+        else {
+            aq->wants_prod = true;
+            pthread_cond_broadcast(&aq->cond);
+        }
+    }
+
+    pthread_mutex_unlock(&aq->lock);
+
+    if (aq->cur_flip == NULL)
+        return;
+
+    rv = drmu_atomic_commit(aq->cur_flip, flags);
+
+    if (rv == 0) {
+        if (aq->retry_count != 0)
+            drmu_warn(du, "[%d]: Atomic commit OK", aq->qno);
+        aq->retry_count = 0;
+
+        // This is the only place last_flip is written when not shutting down
+        // so we don't need the lock
+        if (aq->discard_last) {
+            pthread_mutex_lock(&aq->lock);
+            if (aq->locked) {
+                assert(aq->last_flip == NULL);
+                aq->last_flip = aq->cur_flip;
+                aq->cur_flip = NULL;
+            }
+            pthread_mutex_unlock(&aq->lock);
+
+            // Writeback doesn't need to keep the source once done
+            drmu_atomic_unref(&aq->cur_flip);
+        }
+        else {
+            // Must merge cur into last rather than just replace last as there may
+            // still be things on screen not updated by the current commit
+            drmu_atomic_move_merge(&aq->last_flip, &aq->cur_flip);
+        }
+    }
+    else if (rv == -EBUSY && ++aq->retry_count < 16) {
+        // This really shouldn't happen but we observe that the 1st commit after
+        // a modeset often fails with BUSY.  It seems to be fine on a 10ms retry
+        // but allow some more in case we need a bit longer in some cases
+        // *** This may never happen now with blocking commits
+        drmu_warn(du, "[%d]: Atomic commit BUSY", aq->qno);
+        prod_time = 20;
+    }
+    else {
+        drmu_err(du, "[%d]: Atomic commit failed: %s", aq->qno, strerror(-rv));
+        drmu_atomic_dump(aq->cur_flip);
+        drmu_atomic_unref(&aq->cur_flip);
+        aq->retry_count = 0;
+        // We haven't had a good commit so _unlock must not be called so no
+        // mutex required
+        aq->locked = false;
+    }
+
+    pollqueue_add_task(aq->prod_pt, prod_time);
+}
+
+static void
+queue_free(drmu_queue_t * const aq)
+{
+    sem_t * const finish_sem = aq->finish_sem;
+
+    // Delete will wait for a running polltask to finish
+    polltask_delete(&aq->prod_pt);
+
+    next_flip_uninit(&aq->next);
+    drmu_atomic_unref(&aq->cur_flip);
+
+    if (aq->env_restore_req)
+        drmu_env_int_restore(aq->du);
+
+    drmu_atomic_unref(&aq->last_flip);
+
+    pollqueue_finish(&aq->pq);
+
+    pthread_cond_destroy(&aq->cond);
+    pthread_mutex_destroy(&aq->lock);
+
+    drmu_env_unref(&aq->du);
+    free(aq);
+
+    // If we are waiting for this to die - signal it
+    if (finish_sem != NULL)
+        sem_post(finish_sem);
+}
+
+static void
+queue_finish(drmu_queue_t ** const ppAq, const bool wants_restore)
+{
+    sem_t sem;
+
+    if (*ppAq == NULL)
+        return;
+
+    sem_init(&sem, 0, 0);
+    (*ppAq)->env_restore_req = wants_restore;
+    (*ppAq)->finish_sem = &sem;
+    drmu_queue_unref(ppAq);
+
+    while (sem_wait(&sem) != 0 && errno == EINTR)
+        /* loop */;
+    sem_destroy(&sem);
+}
+
+//-----------------------------------------------------------------------------
+//
+// Default Q setup & destroy functions
+
+// Kill the Q
+// Ordering goes:
+//   Shutdown Q events
+//   Restore old state
+//   Clear previous atomics
+// Must be done in that order or we end up destroying buffers that are
+// still in use
+static void
+poll_destroy(drmu_queue_t ** ppAq, drmu_env_t * du)
+{
+    (void)du;
+    queue_finish(ppAq, true);
+}
+
+static drmu_queue_t *
+poll_new(drmu_env_t * du)
+{
+    return drmu_queue_new(du);
+}
+
+//-----------------------------------------------------------------------------
+//
+// External functions
+// Somewhat broken naming scheme for historic reasons
+
+drmu_queue_t *
+drmu_queue_new(struct drmu_env_s * const du)
+{
+    drmu_queue_t * const aq = calloc(1, sizeof(*aq));
+    pthread_condattr_t condattr;
+    static atomic_int qcount = ATOMIC_VAR_INIT(0);
+
+    if (aq == NULL)
+        return NULL;
+
+    aq->du = drmu_env_ref(du);
+    next_flip_init(&aq->next);
+    aq->cur_flip = NULL;
+    aq->last_flip = NULL;
+    aq->qno = atomic_fetch_add(&qcount, 1);
+    aq->wants_prod = true;
+
+    pthread_mutex_init(&aq->lock, NULL);
+
+    pthread_condattr_init(&condattr);
+    pthread_condattr_setclock(&condattr, CLOCK_MONOTONIC);
+    pthread_cond_init(&aq->cond, &condattr);
+    pthread_condattr_destroy(&condattr);
+
+    if ((aq->pq = pollqueue_new()) == NULL)
+        goto fail;
+    if ((aq->prod_pt = polltask_new(aq->pq, -1, 0, queue_prod_cb, aq)) == NULL)
+        goto fail;
+    return aq;
+
+fail:
+    queue_free(aq);
+    return aq;
+}
+
+drmu_queue_t *
+drmu_queue_ref(drmu_queue_t * const dq)
+{
+    atomic_fetch_add(&dq->ref_count, 1);
+    return dq;
+}
+
+void
+drmu_queue_unref(drmu_queue_t ** const ppdq)
+{
+    drmu_queue_t * const dq = *ppdq;
+    int n;
+
+    if (dq == NULL)
+        return;
+    *ppdq = NULL;
+
+    n = atomic_fetch_sub(&dq->ref_count, 1);
+    if (n != 0)
+        return;
+
+    queue_free(dq);
+}
+
+void
+drmu_queue_finish(drmu_queue_t ** const ppdq)
+{
+    queue_finish(ppdq, false);
+}
+
+int
+drmu_queue_queue_tagged(drmu_queue_t * const aq,
+                        const unsigned int tag, const drmu_queue_merge_t qmerge,
+                        struct drmu_atomic_s ** ppda)
+{
+    int rv = 0;
+    drmu_env_t * const du = drmu_atomic_env(*ppda);
+    drmu_atomic_t ** ppna = NULL;
+    drmu_atomic_t * discard_da = NULL;
+    bool wants_prod = false;
+
+    if (aq == NULL) {
+        rv = -EINVAL;
+        goto fail_unref;
+    }
+
+    if (drmu_atomic_is_empty(*ppda))
+        goto fail_unref;  // rv = 0 so not an error really
+
+    pthread_mutex_lock(&aq->lock);
+
+    if (qmerge != DRMU_QUEUE_MERGE_QUEUE)
+        ppna = next_flip_find_tag(&aq->next, tag);
+
+    if (ppna == NULL) {
+        if ((ppna = next_flip_add_tail(&aq->next, tag)) == NULL) {
+            rv = -ENOMEM;
+            goto fail_unlock;
+        }
+    }
+
+    switch (qmerge) {
+        case DRMU_QUEUE_MERGE_MERGE:
+            if ((rv = drmu_atomic_move_merge(ppna, ppda)) != 0)
+                goto fail_unlock;
+            break;
+        case DRMU_QUEUE_MERGE_QUEUE:
+        case DRMU_QUEUE_MERGE_DROP:
+            if (*ppna == NULL)
+                *ppna = drmu_atomic_move(ppda);
+            break;
+        case DRMU_QUEUE_MERGE_REPLACE:
+            discard_da = *ppna; // Unref can take a short while - move outside lock
+            *ppna = drmu_atomic_move(ppda);
+            break;
+        default:
+            drmu_err(du, "Bad qmerge value");
+            rv = -EINVAL;
+            goto fail_unlock;
+    }
+
+    // No pending commit?
+    if (aq->wants_prod) {
+        aq->wants_prod = false;
+        wants_prod = true;
+    }
+
+    rv = 0;
+
+fail_unlock:
+    pthread_mutex_unlock(&aq->lock);
+
+    // Do outside lock to avoid possible unneeded lock conflict
+    if (wants_prod)
+        pollqueue_add_task(aq->prod_pt, 0);
+
+    drmu_atomic_unref(&discard_da);
+fail_unref:
+    drmu_atomic_unref(ppda);
+    return rv;
+}
+
+int
+drmu_atomic_queue(drmu_atomic_t ** ppda)
+{
+    drmu_queue_t * const aq = drmu_env_queue_default(drmu_atomic_env(*ppda));
+    return drmu_queue_queue_tagged(aq, 0, DRMU_QUEUE_MERGE_MERGE, ppda);
+}
+
+drmu_queue_t *
+drmu_env_queue_default(drmu_env_t * const du)
+{
+    drmu_queue_t * aq;
+    if (drmu_env_int_poll_set(du, poll_new, poll_destroy, &aq) != 0)
+        return NULL;
+    return aq;
+}
+
+int
+drmu_queue_wait(drmu_queue_t * const aq)
+{
+    int rv = 0;
+    struct timespec ts;
+
+    if (aq == NULL)
+        return 0;
+
+    pthread_mutex_lock(&aq->lock);
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    ts.tv_sec += 1;  // We should never timeout if all is well - 1 sec is plenty
+
+    // wants_prod will be true once Q empty and commit finished
+    while (!aq->wants_prod)
+        if ((rv = pthread_cond_timedwait(&aq->cond, &aq->lock, &ts)) != 0)
+            break;
+
+    pthread_mutex_unlock(&aq->lock);
+    return rv;
+}
+
+void
+drmu_queue_keep_last_set(drmu_queue_t * const aq, const bool keep_last)
+{
+    aq->discard_last = !keep_last;
+}
+
+void
+drmu_queue_lock_on_commit_set(drmu_queue_t * const aq, const bool lock)
+{
+    aq->lock_on_commit = lock;
+}
+
+int
+drmu_queue_unlock(drmu_queue_t * const aq)
+{
+    bool wants_prod = false;
+    drmu_atomic_t * da = NULL;
+
+    pthread_mutex_lock(&aq->lock);
+    if (aq->locked) {
+        aq->locked = false;
+        wants_prod = true;
+
+        if (aq->discard_last) {
+            da = aq->last_flip;
+            aq->last_flip = NULL;
+        }
+    }
+    pthread_mutex_unlock(&aq->lock);
+
+    if (wants_prod)
+        pollqueue_add_task(aq->prod_pt, 0);
+
+    drmu_atomic_unref(&da);
+    return 0;
+}
+
+int
+drmu_env_queue_wait(drmu_env_t * const du)
+{
+    return drmu_queue_wait(drmu_env_queue_default(du));
+}
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_poll.h
@@ -0,0 +1,80 @@
+#ifndef _DRMU_DRMU_POLL_H
+#define _DRMU_DRMU_POLL_H
+
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct drmu_env_s;
+struct drmu_atomic_s;
+
+struct drmu_queue_s;
+typedef struct drmu_queue_s drmu_queue_t;
+
+drmu_queue_t * drmu_queue_new(struct drmu_env_s * const du);
+drmu_queue_t * drmu_queue_ref(drmu_queue_t * const dq);
+void drmu_queue_unref(drmu_queue_t ** const ppdq);
+
+// Unref and wait for all other unrefs to occur
+void drmu_queue_finish(drmu_queue_t ** const ppdq);
+
+typedef enum drmu_queue_merge_e {
+    DRMU_QUEUE_MERGE_MERGE,   // Merge with last existing (default)
+    DRMU_QUEUE_MERGE_DROP,    // Drop new request
+    DRMU_QUEUE_MERGE_REPLACE, // Replace previous request
+    DRMU_QUEUE_MERGE_QUEUE,   // Queue both
+} drmu_queue_merge_t;
+
+// Q the atomic on its associated env in the given q
+//
+// in-progress = The commit has been done but no ack yet
+// pending     = Commit Qed to be done when the in-progress commit has
+//               completed
+//
+// If no in-progress commit then this will be committed immediately
+// otherwise it becomes the pending commit
+// If there is a pending commit this atomic will be merged with it
+// Commits are done with the PAGE_FLIP flag set so we expect the ack
+// on the next page flip.
+int drmu_queue_queue_tagged(drmu_queue_t * const aq,
+                            const unsigned int tag, const drmu_queue_merge_t qmerge,
+                            struct drmu_atomic_s ** ppda);
+static inline int
+drmu_queue_queue(drmu_queue_t * const aq, struct drmu_atomic_s ** const ppda)
+{
+    return drmu_queue_queue_tagged(aq, 0, DRMU_QUEUE_MERGE_MERGE, ppda);
+}
+
+// Default Q
+drmu_queue_t * drmu_env_queue_default(struct drmu_env_s * const du);
+
+// drmu_atomic_queue_qno(ppda, 0)
+int drmu_atomic_queue(struct drmu_atomic_s ** ppda);
+
+// Wait for there to be no pending commit (there may be a commit in
+// progress)
+int drmu_queue_wait(drmu_queue_t * const aq);
+
+// Wait on default q
+int drmu_env_queue_wait(struct drmu_env_s * const du);
+
+// Keep a ref on the previous atomics until overwren by new atomics
+// Needed for most displays, not needed for writeback
+// Default queue keep_last state is true
+void drmu_queue_keep_last_set(drmu_queue_t * const aq, const bool keep_last);
+
+// Set a lock on this queue after a successful commit, next commit will not
+// proceed until _queue_unlock is called.
+// If _keep_last_set is false it also postpones the atomic unref until the
+// unlock.
+// This is primarily for use with writeback fences
+void drmu_queue_lock_on_commit_set(drmu_queue_t * const aq, const bool lock);
+int drmu_queue_unlock(drmu_queue_t * const aq);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_pool.c
@@ -0,0 +1,307 @@
+#include "drmu_pool.h"
+
+#include <assert.h>
+#include <pthread.h>
+#include <stdatomic.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#include "drmu.h"
+#include "drmu_log.h"
+
+//----------------------------------------------------------------------------
+//
+// Pool fns
+
+typedef struct drmu_fb_slot_s {
+    struct drmu_fb_s * fb;
+    struct drmu_fb_slot_s * next;
+    struct drmu_fb_slot_s * prev;
+} drmu_fb_slot_t;
+
+typedef struct drmu_fb_list_s {
+    drmu_fb_slot_t * head;      // Double linked list of free FBs; LRU @ head
+    drmu_fb_slot_t * tail;
+    drmu_fb_slot_t * unused;    // Single linked list of unused slots
+} drmu_fb_list_t;
+
+struct drmu_pool_s {
+    atomic_int ref_count;       // 0 == 1 ref for ease of init
+    bool dead;                  // Pool killed - never alloc again
+
+    unsigned int fb_count;      // FBs allocated (not free count)
+    unsigned int fb_max;        // Max FBs to allocate
+
+    struct drmu_env_s * du;     // Logging only - not reffed
+
+    drmu_pool_callback_fns_t callback_fns;
+    void * callback_v;
+
+    pthread_mutex_t lock;
+
+    drmu_fb_list_t free_fbs;    // Free FB list header
+    drmu_fb_slot_t * slots;     // [fb_max]
+};
+
+static void
+fb_list_add_tail(drmu_fb_list_t * const fbl, drmu_fb_t * const dfb)
+{
+    drmu_fb_slot_t * const slot = fbl->unused;
+
+    assert(slot != NULL);
+    fbl->unused = slot->next;
+    slot->fb = dfb;
+    slot->next = NULL;
+
+    if (fbl->tail == NULL)
+        fbl->head = slot;
+    else
+        fbl->tail->next = slot;
+    slot->prev = fbl->tail;
+    fbl->tail = slot;
+}
+
+static drmu_fb_t *
+fb_list_extract(drmu_fb_list_t * const fbl, drmu_fb_slot_t * const slot)
+{
+    drmu_fb_t * dfb;
+
+    if (slot == NULL)
+        return NULL;
+
+    if (slot->prev == NULL)
+        fbl->head = slot->next;
+    else
+        slot->prev->next = slot->next;
+
+    if (slot->next == NULL)
+        fbl->tail = slot->prev;
+    else
+        slot->next->prev = slot->prev;
+
+    dfb = slot->fb;
+    slot->fb = NULL;
+    slot->next = fbl->unused;
+    slot->prev = NULL;
+    fbl->unused = slot;
+    return dfb;
+}
+
+static drmu_fb_t *
+fb_list_extract_head(drmu_fb_list_t * const fbl)
+{
+    return fb_list_extract(fbl, fbl->head);
+}
+
+static void
+pool_free_pool(drmu_pool_t * const pool)
+{
+    drmu_fb_t * dfb;
+    pthread_mutex_lock(&pool->lock);
+    while ((dfb = fb_list_extract_head(&pool->free_fbs)) != NULL) {
+        --pool->fb_count;
+        pthread_mutex_unlock(&pool->lock);
+        drmu_fb_unref(&dfb);
+        pthread_mutex_lock(&pool->lock);
+    }
+    pthread_mutex_unlock(&pool->lock);
+}
+
+static void
+pool_free(drmu_pool_t * const pool)
+{
+    void *const v = pool->callback_v;
+    const drmu_pool_on_delete_fn on_delete_fn = pool->callback_fns.on_delete_fn;
+    pool_free_pool(pool);
+    free(pool->slots);
+    pthread_mutex_destroy(&pool->lock);
+    free(pool);
+
+    on_delete_fn(v);
+}
+
+void
+drmu_pool_unref(drmu_pool_t ** const pppool)
+{
+    drmu_pool_t * const pool = *pppool;
+    int n;
+
+    if (pool == NULL)
+        return;
+    *pppool = NULL;
+
+    n = atomic_fetch_sub(&pool->ref_count, 1);
+    assert(n >= 0);
+    if (n == 0)
+        pool_free(pool);
+}
+
+drmu_pool_t *
+drmu_pool_ref(drmu_pool_t * const pool)
+{
+    if (pool != NULL)
+        atomic_fetch_add(&pool->ref_count, 1);
+    return pool;
+}
+
+drmu_pool_t *
+drmu_pool_new_alloc(drmu_env_t * const du, const unsigned int total_fbs_max,
+                    const drmu_pool_callback_fns_t * const cb_fns,
+                    void * const v)
+{
+    drmu_pool_t * const pool = calloc(1, sizeof(*pool));
+    unsigned int i;
+
+    if (pool == NULL)
+        goto fail0;
+    if ((pool->slots = calloc(total_fbs_max, sizeof(*pool->slots))) == NULL)
+        goto fail1;
+
+    pool->du = du;
+    pool->fb_max = total_fbs_max;
+    pool->callback_fns = *cb_fns;
+    pool->callback_v = v;
+
+    for (i = 1; i != total_fbs_max; ++i)
+        pool->slots[i - 1].next = pool->slots + i;
+    pool->free_fbs.unused = pool->slots + 0;
+
+    pthread_mutex_init(&pool->lock, NULL);
+
+    return pool;
+
+fail1:
+    free(pool);
+fail0:
+    cb_fns->on_delete_fn(v);
+    drmu_err(du, "Failed pool env alloc");
+    return NULL;
+}
+
+static int
+pool_fb_pre_delete_cb(drmu_fb_t * dfb, void * v)
+{
+    drmu_pool_t * pool = v;
+
+    // Ensure we cannot end up in a delete loop
+    drmu_fb_pre_delete_unset(dfb);
+
+    // If dead set then might as well delete now
+    // It should all work without this shortcut but this reclaims
+    // storage quicker
+    if (pool->dead) {
+        drmu_pool_unref(&pool);
+        return 0;
+    }
+
+    drmu_fb_ref(dfb);  // Restore ref
+
+    pthread_mutex_lock(&pool->lock);
+    fb_list_add_tail(&pool->free_fbs, dfb);
+    pthread_mutex_unlock(&pool->lock);
+
+    // May cause suicide & recursion on fb delete, but that should be OK as
+    // the 1 we return here should cause simple exit of fb delete
+    drmu_pool_unref(&pool);
+    return 1;  // Stop delete
+}
+
+drmu_fb_t *
+drmu_pool_fb_new(drmu_pool_t * const pool, uint32_t w, uint32_t h, const uint32_t format, const uint64_t mod)
+{
+    drmu_fb_t * dfb;
+    drmu_fb_slot_t * slot;
+
+    pthread_mutex_lock(&pool->lock);
+
+    // If pool killed then _fb_new must fail
+    if (pool->dead)
+        goto fail_unlock;
+
+    slot = pool->free_fbs.head;
+    while (slot != NULL) {
+        dfb = slot->fb;
+        if (pool->callback_fns.try_reuse_fn(dfb, w, h, format, mod)) {
+            fb_list_extract(&pool->free_fbs, slot);
+            pthread_mutex_unlock(&pool->lock);
+            goto found;
+        }
+        slot = slot->next;
+    }
+    // Nothing reusable
+    dfb = NULL;
+
+    // Simply allocate new buffers until we hit fb_max then free LRU
+    // first. If nothing to free then fail.
+    if (pool->fb_count++ >= pool->fb_max) {
+        --pool->fb_count;
+        if ((dfb = fb_list_extract_head(&pool->free_fbs)) == NULL)
+            goto fail_unlock;
+    }
+    pthread_mutex_unlock(&pool->lock);
+
+    drmu_fb_unref(&dfb);  // Will free the dfb as pre-delete CB will be unset
+
+    if ((dfb = pool->callback_fns.alloc_fn(pool->callback_v, w, h, format, mod)) == NULL) {
+        pthread_mutex_lock(&pool->lock);
+        --pool->fb_count;
+        goto fail_unlock;
+    }
+
+found:
+    drmu_fb_pre_delete_set(dfb, pool_fb_pre_delete_cb, drmu_pool_ref(pool));
+    return dfb;
+
+fail_unlock:
+    pthread_mutex_unlock(&pool->lock);
+    return NULL;
+}
+
+// Mark pool as dead (i.e. no new allocs) and unref it
+// Simple unref will also work but this reclaims storage faster
+// Actual pool structure will persist until all referencing fbs are deleted too
+void
+drmu_pool_kill(drmu_pool_t ** const pppool)
+{
+    drmu_pool_t * pool = *pppool;
+
+    if (pool == NULL)
+        return;
+    *pppool = NULL;
+
+    pool->dead = true;
+    pool_free_pool(pool);
+
+    drmu_pool_unref(&pool);
+}
+
+//----------------------------------------------------------------------------
+//
+// Dumb pool setup
+
+static drmu_fb_t *
+pool_dumb_alloc_cb(void * const v, const uint32_t w, const uint32_t h, const uint32_t format, const uint64_t mod)
+{
+    return drmu_fb_new_dumb_mod(v, w, h, format, mod);
+}
+
+static void
+pool_dumb_on_delete_cb(void * const v)
+{
+    drmu_env_t * du = v;
+    drmu_env_unref(&du);
+}
+
+drmu_pool_t *
+drmu_pool_new_dumb(drmu_env_t * const du, unsigned int total_fbs_max)
+{
+    static const drmu_pool_callback_fns_t fns = {
+        .alloc_fn = pool_dumb_alloc_cb,
+        .on_delete_fn = pool_dumb_on_delete_cb,
+        .try_reuse_fn = drmu_fb_try_reuse,
+    };
+    return drmu_pool_new_alloc(du, total_fbs_max, &fns, drmu_env_ref(du));
+}
+
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_pool.h
@@ -0,0 +1,60 @@
+#ifndef _DRMU_DRMU_POOL_H
+#define _DRMU_DRMU_POOL_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct drmu_pool_s;
+typedef struct drmu_pool_s drmu_pool_t;
+
+struct drmu_env_s;
+struct drmu_fb_s;
+
+// fb pool
+
+void drmu_pool_unref(drmu_pool_t ** const pppool);
+drmu_pool_t * drmu_pool_ref(drmu_pool_t * const pool);
+
+// cb to allocate a new pool fb
+typedef struct drmu_fb_s * (* drmu_pool_alloc_fn)(void * const v, const uint32_t w, const uint32_t h, const uint32_t format, const uint64_t mod);
+// cb called when pool deleted or on new_pool failure - takes the same v as alloc
+typedef void (* drmu_pool_on_delete_fn)(void * const v);
+typedef bool (* drmu_pool_try_reuse_fn)(struct drmu_fb_s * dfb, uint32_t w, uint32_t h, const uint32_t format, const uint64_t mod);
+
+typedef struct drmu_pool_callback_fns_s {
+    drmu_pool_alloc_fn alloc_fn;
+    drmu_pool_on_delete_fn on_delete_fn;
+    drmu_pool_try_reuse_fn try_reuse_fn;
+} drmu_pool_callback_fns_t;
+
+// Create a new pool with custom alloc & pool delete
+// If pool creation fails then on_delete_fn(v) called and NULL returned
+// Pool entries are not pre-allocated.
+drmu_pool_t * drmu_pool_new_alloc(struct drmu_env_s * const du, const unsigned int total_fbs_max,
+                                  const drmu_pool_callback_fns_t * const cb_fns,
+                                  void * const v);
+
+// Marks the pool as dead & unrefs this reference
+//   No allocs will succeed after this
+//   All free fbs are unrefed
+void drmu_pool_kill(drmu_pool_t ** const pppool);
+
+// Create a new pool of fb allocated from dumb objects
+// N.B. BOs are alloced from uncached memory so may be slow to do anything other
+// than copy into. (See drmu_dmabuf_ if you want cached data)
+drmu_pool_t * drmu_pool_new_dumb(struct drmu_env_s * const du, unsigned int total_fbs_max);
+
+// Allocate a fb from the pool
+// Allocations need not be all of the same size but no guarantees are made about
+// efficient memory use if this is the case
+struct drmu_fb_s * drmu_pool_fb_new(drmu_pool_t * const pool, uint32_t w, uint32_t h, const uint32_t format, const uint64_t mod);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/modules/video_output/drmu/drmu_scan.c
@@ -0,0 +1,60 @@
+#include "drmu_scan.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+
+#include "drmu.h"
+#include "drmu_log.h"
+#include "drmu_output.h"
+
+#define CARD_MAX 16
+
+
+int
+drmu_scan_output(const char * const cname, const drmu_log_env_t * const dlog,
+                 drmu_env_t ** const pDu, drmu_output_t ** const pDoutput)
+{
+    static const char * card_prefix = "/dev/dri/card";
+    unsigned int i;
+
+    *pDu = NULL;
+    *pDoutput = NULL;
+
+    for (i = 0; i != CARD_MAX; ++i) {
+        drmu_env_t * du;
+        drmu_output_t * dout = NULL;
+        char fname[32];
+        int fd;
+
+        drmu_debug_log(dlog, "Try card %d", i);
+
+        sprintf(fname, "%s%d", card_prefix, i);
+        while ((fd = open(fname, O_RDWR | O_CLOEXEC)) == -1 && errno == EINTR)
+            /* Loop */;
+        if (fd == -1) {
+            if (errno == ENOENT)
+                break;
+            continue;
+        }
+
+        // Have FD
+        if ((du = drmu_env_new_fd(fd, dlog)) == NULL)
+            continue;
+
+        if ((dout = drmu_output_new(du)) == NULL)
+            goto loop1;
+
+        if (drmu_output_add_output(dout, cname) == 0) {
+            *pDu = du;
+            *pDoutput = dout;
+            return 0;
+        }
+
+        drmu_output_unref(&dout);
+loop1:
+        drmu_env_unref(&du);
+    }
+    return -ENOENT;
+}
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_scan.h
@@ -0,0 +1,20 @@
+#ifndef _DRMU_DRMU_SCAN_H
+#define _DRMU_DRMU_SCAN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct drmu_log_env_s;
+struct drmu_env_s;
+struct drmu_output_s;
+
+int
+drmu_scan_output(const char * const cname, const struct drmu_log_env_s * const dlog,
+                 struct drmu_env_s ** const pDu, struct drmu_output_s ** const pDoutput);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_util.c
@@ -0,0 +1,199 @@
+#include "drmu_util.h"
+
+#include "drmu.h"
+
+#include <ctype.h>
+#include <error.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <libdrm/drm_mode.h>
+
+static unsigned long
+h_to_w(const unsigned long h)
+{
+    switch (h) {
+        case 480:
+        case 576:
+            return 720;
+        case 720:
+            return 1280;
+        case 1080:
+            return 1920;
+        case 2160:
+            return 3840;
+        default:
+            break;
+    }
+    return 0;
+}
+
+char *
+drmu_util_parse_mode_simple_params(const char * s, drmu_mode_simple_params_t * const p)
+{
+    unsigned long w = 0, h = 0, hz = 0;
+    bool il = false;
+    bool drmhz = false;
+
+    memset(p , 0, sizeof(*p));
+
+    if (isdigit(*s)) {
+        h = strtoul(s, (char **)&s, 10);
+
+        if (*s == 'p' || *s == 'i') {
+            w = h_to_w(h);
+        }
+        else if (*s == 'x') {
+            w = h;
+            h = strtoul(s + 1, (char **)&s, 10);
+        }
+        else {
+            return (char *)s;
+        }
+    }
+
+    // Consume 'i' or 'p'
+    // Can still have (now) optional hz separator after
+    if (*s == 'p') {
+        ++s;
+    }
+    else if (*s == 'i') {
+        il = true;
+        ++s;
+    }
+
+    // I've used '@' in the past to separate size from hz
+    // DRM uses '-' in modetest so accept that
+    if (*s == '@') {
+        ++s;
+    }
+    else if (*s == '-') {
+        drmhz = true;
+        ++s;
+    }
+
+    if (isdigit(*s)) {
+        hz = strtoul(s, (char **)&s, 10) * 1000;
+
+        if (*s == '.') {
+            unsigned int m = 100;
+            while (isdigit(*++s)) {
+                hz += (*s - '0') * m;
+                m /= 10;
+            }
+        }
+    }
+
+    // DRM thinks in frame rate, rest of the world specifies as field rate
+    if (il && !drmhz)
+        hz /= 2;
+
+    p->width  = (unsigned int)w;
+    p->height = (unsigned int)h;
+    p->hz_x_1000 = (unsigned int)hz;
+    p->flags = !il ? 0 : DRM_MODE_FLAG_INTERLACE;
+
+    return (char *)s;
+}
+
+char *
+drmu_util_simple_param_to_mode_str(char * buf, size_t buflen, const drmu_mode_simple_params_t * const p)
+{
+    int hz = p->hz_x_1000;
+
+    if ((p->flags & DRM_MODE_FLAG_INTERLACE))
+        hz *= 2;
+
+    snprintf(buf, buflen, "%dx%d%c%d.%03d",
+             p->width, p->height,
+             (p->flags & DRM_MODE_FLAG_INTERLACE) ? 'i' : 'p',
+             hz / 1000, hz % 1000);
+    return buf;
+}
+
+char *
+drmu_util_parse_mode(const char * s, unsigned int * pw, unsigned int * ph, unsigned int * phz)
+{
+    drmu_mode_simple_params_t p;
+    char * r = drmu_util_parse_mode_simple_params(s, &p);
+    *pw = p.width;
+    *ph = p.height;
+    *phz = p.hz_x_1000;
+    return r;
+}
+
+unsigned int
+drmu_util_str_to_rotation(const char * s, char ** peos)
+{
+    static const struct {
+        const char * str;
+        unsigned int rot;
+    } str_to_rot[] = {
+        {"0", DRMU_ROTATION_0},
+        {"H_FLIP", DRMU_ROTATION_H_FLIP},
+        {"H", DRMU_ROTATION_H_FLIP},
+        {"V_FLIP", DRMU_ROTATION_V_FLIP},
+        {"V", DRMU_ROTATION_V_FLIP},
+        {"180T", DRMU_ROTATION_180_TRANSPOSE},
+        {"180_TRANSPOSE", DRMU_ROTATION_180_TRANSPOSE},
+        {"180", DRMU_ROTATION_180},
+        {"TRANSPOSE", DRMU_ROTATION_TRANSPOSE},
+        {"T", DRMU_ROTATION_TRANSPOSE},
+        {"90", DRMU_ROTATION_90},
+        {"270", DRMU_ROTATION_270},
+        {NULL, 0},
+    };
+    unsigned int i;
+
+    for (i = 0; str_to_rot[i].str != NULL; ++i) {
+        size_t n = strlen(str_to_rot[i].str);
+        if (strncasecmp(s, str_to_rot[i].str, n) == 0) {
+            if (peos != NULL)
+                *peos = (char*)(s + n);
+            return str_to_rot[i].rot;
+        }
+    }
+    if (peos != NULL)
+        *peos = (char*)s;
+    return DRMU_ROTATION_0;
+}
+
+drmu_ufrac_t
+drmu_util_guess_par(const unsigned int w, const unsigned int h)
+{
+    if (((w == 720 || w == 704) && (h == 480 || h == 576)) ||
+        ((w == 360 || w == 352) && (h == 240 || h == 288)))
+    {
+        return (drmu_ufrac_t){.num = 4, .den = 3};
+    }
+    return drmu_ufrac_reduce((drmu_ufrac_t){.num = w, .den = h});
+}
+
+drmu_ufrac_t
+drmu_util_guess_simple_mode_par(const drmu_mode_simple_params_t * const p)
+{
+    if (p->par.den != 0 && p->par.num != 0)
+        return p->par;
+    return drmu_util_guess_par(p->width, p->height);
+}
+
+void
+drmu_memcpy_2d(void * const dst_p, const size_t dst_stride,
+               const void * const src_p, const size_t src_stride,
+               const size_t width, const size_t height)
+{
+    if (dst_stride == src_stride && dst_stride == width) {
+        memcpy(dst_p, src_p, width * height);
+    }
+    else {
+        size_t i;
+        char * d = dst_p;
+        const char * s = src_p;
+        for (i = 0; i != height; ++i) {
+            memcpy(d, s, width);
+            d += dst_stride;
+            s += src_stride;
+        }
+    }
+}
--- /dev/null
+++ b/modules/video_output/drmu/drmu_util.h
@@ -0,0 +1,64 @@
+#ifndef _DRMU_DRMU_UTIL_H
+#define _DRMU_DRMU_UTIL_H
+
+#include <stddef.h>
+
+#include "drmu_math.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct drmu_mode_simple_params_s;
+
+// Parse a string of the form [<w>x<h>][i][@<hz>[.<mHz>]]
+// Returns pointer to terminating char
+// Missing fields are zero
+char * drmu_util_parse_mode(const char * s, unsigned int * pw, unsigned int * ph, unsigned int * pHzx1000);
+
+// As above but place results into a simple params structure
+// (Unused fields zeroed)
+// Also copes with interlace
+char * drmu_util_parse_mode_simple_params(const char * s, struct drmu_mode_simple_params_s * const p);
+
+// Simple params to mode string
+char * drmu_util_simple_param_to_mode_str(char * buf, size_t buflen, const struct drmu_mode_simple_params_s * const p);
+
+#define drmu_util_simple_mode(p) drmu_util_simple_param_to_mode_str((char[64]){0}, 64, (p))
+
+// Take a string and return a drmu rotation value (DRMU_ROTATION_xxx)
+// Returns pointer to char after parsed string in *peos (c.f. strtol)
+// peos may be NULL if not required
+// N.B. There is no invalid return, rubbish will return ROTATION_0, *peos = s
+unsigned int drmu_util_str_to_rotation(const char * s, char ** peos);
+
+// Given width & height guess par. Spots Likely SD and returns 4:3 otherwise reduced w:h
+drmu_ufrac_t drmu_util_guess_par(const unsigned int w, const unsigned int h);
+// Get a par from simple_params. par can be zero & if so then guess
+drmu_ufrac_t drmu_util_guess_simple_mode_par(const struct drmu_mode_simple_params_s * const p);
+
+// Misc memcpy util
+
+// Simple 2d memcpy
+void drmu_memcpy_2d(void * const dst_p, const size_t dst_stride,
+                    const void * const src_p, const size_t src_stride,
+                    const size_t width, const size_t height);
+// 'FB' copy
+static inline void
+drmu_memcpy_rect(void * const dst_p, const size_t dst_stride, const drmu_rect_t dst_rect,
+                 const void * const src_p, const size_t src_stride, const drmu_rect_t src_rect,
+                 const unsigned int pixel_stride)
+{
+    drmu_memcpy_2d((char *)dst_p + dst_rect.x * pixel_stride + dst_rect.y * dst_stride, dst_stride,
+                   (char *)src_p + src_rect.x * pixel_stride + src_rect.y * src_stride, src_stride,
+                   (src_rect.w < dst_rect.w ? src_rect.w : dst_rect.w) * pixel_stride,
+                   src_rect.h < dst_rect.h ? src_rect.h : dst_rect.h);
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_vlc.c
@@ -0,0 +1,381 @@
+#include "drmu_vlc.h"
+#include "drmu_fmts.h"
+#include "drmu_log.h"
+
+#if HAS_ZC_CMA
+#include "../../hw/mmal/mmal_cma_pic.h"
+#endif
+#if HAS_DRMPRIME
+#include "../../codec/avcodec/drm_pic.h"
+#endif
+
+#include <errno.h>
+
+#include <libavutil/buffer.h>
+#include <libavutil/hwcontext_drm.h>
+
+#include <libdrm/drm_fourcc.h>
+
+typedef struct fb_aux_pic_s {
+    picture_context_t * pic_ctx;
+} fb_aux_pic_t;
+
+static void
+pic_fb_delete_cb(void * v)
+{
+    fb_aux_pic_t * const aux = v;
+
+    aux->pic_ctx->destroy(aux->pic_ctx);
+    free(aux);
+}
+
+static int
+pic_hdr_metadata(struct hdr_output_metadata * const m, const struct video_format_t * const fmt)
+{
+    struct hdr_metadata_infoframe * const inf = &m->hdmi_metadata_type1;
+    unsigned int i;
+
+    memset(m, 0, sizeof(*m));
+    m->metadata_type = HDMI_STATIC_METADATA_TYPE1;
+    inf->metadata_type = HDMI_STATIC_METADATA_TYPE1;
+
+    switch (fmt->transfer) {
+        case TRANSFER_FUNC_SMPTE_ST2084:
+            inf->eotf = HDMI_EOTF_SMPTE_ST2084;
+            break;
+        case TRANSFER_FUNC_ARIB_B67:
+            inf->eotf = HDMI_EOTF_BT_2100_HLG;
+            break;
+        default:
+            // HDMI_EOTF_TRADITIONAL_GAMMA_HDR for 10bit?
+            inf->eotf = HDMI_EOTF_TRADITIONAL_GAMMA_SDR;
+            return -ENOENT;
+    }
+
+    // VLC & HDMI use the same scales for everything but max_luma
+    for (i = 0; i != 3; ++i) {
+        inf->display_primaries[i].x = fmt->mastering.primaries[i * 2 + 0];
+        inf->display_primaries[i].y = fmt->mastering.primaries[i * 2 + 1];
+    }
+    inf->white_point.x = fmt->mastering.white_point[0];
+    inf->white_point.y = fmt->mastering.white_point[1];
+    inf->max_display_mastering_luminance = (uint16_t)(fmt->mastering.max_luminance / 10000);
+    inf->min_display_mastering_luminance = (uint16_t)fmt->mastering.min_luminance;
+
+    inf->max_cll = fmt->lighting.MaxCLL;
+    inf->max_fall = fmt->lighting.MaxFALL;
+
+    return 0;
+}
+
+static drmu_color_encoding_t
+fb_vlc_color_encoding(const video_format_t * const fmt)
+{
+    switch (fmt->space)
+    {
+        case COLOR_SPACE_BT2020:
+            return DRMU_COLOR_ENCODING_BT2020;
+        case COLOR_SPACE_BT601:
+            return DRMU_COLOR_ENCODING_BT601;
+        case COLOR_SPACE_BT709:
+            return DRMU_COLOR_ENCODING_BT709;
+        case COLOR_SPACE_UNDEF:
+        default:
+            break;
+    }
+
+    return (fmt->i_visible_width > 1024 || fmt->i_visible_height > 600) ?
+        DRMU_COLOR_ENCODING_BT709 :
+        DRMU_COLOR_ENCODING_BT601;
+}
+
+static drmu_color_range_t
+fb_vlc_color_range(const video_format_t * const fmt)
+{
+#if HAS_VLC4
+    switch (fmt->color_range)
+    {
+        case COLOR_RANGE_FULL:
+            return DRMU_COLOR_RANGE_YCBCR_FULL_RANGE;
+        case COLOR_RANGE_UNDEF:
+        case COLOR_RANGE_LIMITED:
+        default:
+            break;
+    }
+#else
+    if (fmt->b_color_range_full)
+        return DRMU_COLOR_RANGE_YCBCR_FULL_RANGE;
+#endif
+    return DRMU_COLOR_RANGE_YCBCR_LIMITED_RANGE;
+}
+
+
+static const char *
+fb_vlc_colorspace(const video_format_t * const fmt)
+{
+    switch (fmt->space) {
+        case COLOR_SPACE_BT2020:
+            return DRMU_COLORSPACE_BT2020_RGB;
+        default:
+            break;
+    }
+    return DRMU_COLORSPACE_DEFAULT;
+}
+
+static drmu_chroma_siting_t
+fb_vlc_chroma_siting(const video_format_t * const fmt)
+{
+    switch (fmt->chroma_location) {
+        case CHROMA_LOCATION_LEFT:
+            return DRMU_CHROMA_SITING_LEFT;
+        case CHROMA_LOCATION_CENTER:
+            return DRMU_CHROMA_SITING_CENTER;
+        case CHROMA_LOCATION_TOP_LEFT:
+            return DRMU_CHROMA_SITING_TOP_LEFT;
+        case CHROMA_LOCATION_TOP_CENTER:
+            return DRMU_CHROMA_SITING_TOP;
+        case CHROMA_LOCATION_BOTTOM_LEFT:
+            return DRMU_CHROMA_SITING_BOTTOM_LEFT;
+        case CHROMA_LOCATION_BOTTOM_CENTER:
+            return DRMU_CHROMA_SITING_BOTTOM;
+        default:
+        case CHROMA_LOCATION_UNDEF:
+            break;
+    }
+    return DRMU_CHROMA_SITING_UNSPECIFIED;
+}
+
+static unsigned int
+fb_vlc_orientation(const video_format_t * const fmt)
+{
+    switch (fmt->orientation) {
+        case ORIENT_NORMAL:
+            return DRMU_ROTATION_0;
+        case ORIENT_HFLIPPED:
+            return DRMU_ROTATION_H_FLIP;
+        case ORIENT_VFLIPPED:
+            return DRMU_ROTATION_V_FLIP;
+        case ORIENT_ROTATED_180:
+            return DRMU_ROTATION_180;
+        case ORIENT_TRANSPOSED:
+            return DRMU_ROTATION_TRANSPOSE;
+        case ORIENT_ROTATED_270:
+            return DRMU_ROTATION_270;
+        case ORIENT_ROTATED_90:
+            return DRMU_ROTATION_90;
+        case ORIENT_ANTI_TRANSPOSED:
+            return DRMU_ROTATION_180_TRANSPOSE;
+        default:
+            break;
+    }
+    return DRMU_ROTATION_INVALID;
+}
+
+void
+drmu_fb_vlc_pic_set_metadata(drmu_fb_t * const dfb, const picture_t * const pic)
+{
+    struct hdr_output_metadata meta;
+
+    drmu_fb_color_set(dfb,
+                          fb_vlc_color_encoding(&pic->format),
+                          fb_vlc_color_range(&pic->format),
+                          fb_vlc_colorspace(&pic->format));
+
+    drmu_fb_chroma_siting_set(dfb, fb_vlc_chroma_siting(&pic->format));
+
+    drmu_fb_hdr_metadata_set(dfb, pic_hdr_metadata(&meta, &pic->format) == 0 ? &meta : NULL);
+
+    drmu_fb_orientation_set(dfb, fb_vlc_orientation(&pic->format));
+}
+
+#if HAS_DRMPRIME
+// Create a new fb from a VLC DRM_PRIME picture.
+// Picture is held reffed by the fb until the fb is deleted
+drmu_fb_t *
+drmu_fb_vlc_new_pic_attach(drmu_env_t * const du, picture_t * const pic)
+{
+    int i, j, n;
+    drmu_fb_t * const dfb = drmu_fb_int_alloc(du);
+    const AVDRMFrameDescriptor * const desc = drm_prime_get_desc(pic);
+    fb_aux_pic_t * aux = NULL;
+
+    if (dfb == NULL) {
+        drmu_err(du, "%s: Alloc failure", __func__);
+        return NULL;
+    }
+
+    if (desc == NULL) {
+        drmu_err(du, "%s: Missing descriptor", __func__);
+        goto fail;
+    }
+    if (desc->nb_objects > 4) {
+        drmu_err(du, "%s: Bad descriptor", __func__);
+        goto fail;
+    }
+
+    drmu_fb_int_fmt_size_set(dfb,
+                             desc->layers[0].format,
+                             pic->format.i_width,
+                             pic->format.i_height,
+                             drmu_rect_vlc_pic_crop(pic));
+
+
+    // Set delete callback & hold this pic
+    // Aux attached to dfb immediately so no fail cleanup required
+    if ((aux = calloc(1, sizeof(*aux))) == NULL) {
+        drmu_err(du, "%s: Aux alloc failure", __func__);
+        goto fail;
+    }
+    aux->pic_ctx = pic->context->copy(pic->context);
+    drmu_fb_int_on_delete_set(dfb, pic_fb_delete_cb, aux);
+
+    for (i = 0; i < desc->nb_objects; ++i)
+    {
+        drmu_bo_t * bo = drmu_bo_new_fd(du, desc->objects[i].fd);
+        if (bo == NULL)
+            goto fail;
+        drmu_fb_int_bo_set(dfb, i, bo);
+    }
+
+    n = 0;
+    for (i = 0; i < desc->nb_layers; ++i)
+    {
+        for (j = 0; j < desc->layers[i].nb_planes; ++j)
+        {
+            const AVDRMPlaneDescriptor *const p = desc->layers[i].planes + j;
+            const AVDRMObjectDescriptor *const obj = desc->objects + p->object_index;
+
+            drmu_fb_int_layer_mod_set(dfb, n++, p->object_index, p->pitch, p->offset, obj->format_modifier);
+        }
+    }
+
+    drmu_fb_vlc_pic_set_metadata(dfb, pic);
+
+    if (drmu_fb_int_make(dfb) != 0)
+        goto fail;
+    return dfb;
+
+fail:
+    drmu_fb_int_free(dfb);
+    return NULL;
+}
+#endif
+
+#if HAS_ZC_CMA
+drmu_fb_t *
+drmu_fb_vlc_new_pic_cma_attach(drmu_env_t * const du, picture_t * const pic)
+{
+    int i;
+    drmu_fb_t * const dfb = drmu_fb_int_alloc(du);
+    fb_aux_pic_t * aux = NULL;
+    uint64_t mod;
+    uint32_t fmt = drmu_format_vlc_to_drm_cma(&pic->format, &mod);
+    const bool is_sand = (pic->format.i_chroma == VLC_CODEC_MMAL_ZC_SAND8 ||
+                          pic->format.i_chroma == VLC_CODEC_MMAL_ZC_SAND30);
+    cma_buf_t * const cb = cma_buf_pic_get(pic);
+
+    if (dfb == NULL) {
+        drmu_err(du, "%s: Alloc failure", __func__);
+        return NULL;
+    }
+
+    if (fmt == 0) {
+        drmu_err(du, "Pic bad format for cma");
+        goto fail;
+    }
+
+    if (cb == NULL) {
+        drmu_err(du, "Pic missing cma block");
+        goto fail;
+    }
+
+    drmu_fb_int_fmt_size_set(dfb,
+                             fmt,
+                             pic->format.i_width,
+                             pic->format.i_height,
+                             drmu_rect_vlc_pic_crop(pic));
+
+    // Set delete callback & hold this pic
+    // Aux attached to dfb immediately so no fail cleanup required
+    if ((aux = calloc(1, sizeof(*aux))) == NULL) {
+        drmu_err(du, "%s: Aux alloc failure", __func__);
+        goto fail;
+    }
+    aux->pic_ctx = pic->context->copy(pic->context);
+    drmu_fb_int_on_delete_set(dfb, pic_fb_delete_cb, aux);
+
+    {
+        drmu_bo_t * bo = drmu_bo_new_fd(du, cma_buf_fd(cb));
+        if (bo == NULL)
+            goto fail;
+        drmu_fb_int_bo_set(dfb, 0, bo);
+    }
+
+    {
+        uint8_t * const base_addr = cma_buf_addr(cb);
+        for (i = 0; i < pic->i_planes; ++i) {
+            if (is_sand)
+                drmu_fb_int_layer_mod_set(dfb, i, 0, pic->format.i_width, pic->p[i].p_pixels - base_addr,
+                                          DRM_FORMAT_MOD_BROADCOM_SAND128_COL_HEIGHT(pic->p[i].i_pitch));
+            else
+                drmu_fb_int_layer_mod_set(dfb, i, 0, pic->p[i].i_pitch, pic->p[i].p_pixels - base_addr, mod);
+        }
+    }
+
+    drmu_fb_vlc_pic_set_metadata(dfb, pic);
+
+    if (drmu_fb_int_make(dfb) != 0)
+        goto fail;
+    return dfb;
+
+fail:
+    drmu_fb_int_free(dfb);
+    return NULL;
+}
+#endif
+
+plane_t
+drmu_fb_vlc_plane(drmu_fb_t * const dfb, const unsigned int plane_n)
+{
+    const drmu_fmt_info_t *const f = drmu_fb_format_info_get(dfb);
+    unsigned int hdiv = drmu_fmt_info_hdiv(f, plane_n);
+    unsigned int wdiv = drmu_fmt_info_wdiv(f, plane_n);
+    const unsigned int bypp = (drmu_fmt_info_pixel_bits(f) + 7) / 8;
+    const uint32_t pitch_n = drmu_fb_pitch(dfb, plane_n);
+    const drmu_rect_t crop = drmu_rect_shr16_rnd(drmu_fb_crop_frac(dfb));
+
+    if (pitch_n == 0) {
+        return (plane_t) {.p_pixels = NULL };
+    }
+
+    return (plane_t){
+        .p_pixels = (uint8_t *)drmu_fb_data(dfb, plane_n) +
+            pitch_n * (crop.y / hdiv) + (crop.x / wdiv) * bypp,
+        .i_lines = drmu_fb_height(dfb) / hdiv,
+        .i_pitch = pitch_n,
+        .i_pixel_pitch = bypp,
+        .i_visible_lines = crop.h / hdiv,
+        .i_visible_pitch = (crop.w / wdiv) * bypp
+    };
+}
+
+#if !HAS_VLC4
+#define vlc_object_vaLog vlc_vaLog
+#endif
+
+void
+drmu_log_vlc_cb(void * v, enum drmu_log_level_e level_drmu, const char * fmt, va_list vl)
+{
+    const char * const file_name = va_arg(vl, const char *);
+    const unsigned int line_no = va_arg(vl, unsigned int);
+    const char * const function_name = va_arg(vl, const char *);
+    const int level_vlc =
+        level_drmu <= DRMU_LOG_LEVEL_MESSAGE ? VLC_MSG_INFO :
+        level_drmu <= DRMU_LOG_LEVEL_ERROR   ? VLC_MSG_ERR :
+        level_drmu <= DRMU_LOG_LEVEL_WARNING ? VLC_MSG_WARN :
+            VLC_MSG_DBG;
+
+    vlc_object_vaLog((vlc_object_t *)v, level_vlc, vlc_module_name, file_name, line_no,
+                     function_name, fmt + DRMU_LOG_FMT_OFFSET_FMT, vl);
+}
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_vlc.h
@@ -0,0 +1,81 @@
+#ifndef _DRMU_DRMU_VLC_H
+#define _DRMU_DRMU_VLC_H
+
+#include "config.h"
+
+#ifndef HAS_VLC4
+#define HAS_VLC4     0
+#endif
+#ifndef HAS_ZC_CMA
+#define HAS_ZC_CMA   0
+#endif
+#define HAS_DRMPRIME 1
+
+#include <stdint.h>
+
+#include <vlc_common.h>
+#include <vlc_picture.h>
+#include <vlc_vout_display.h>
+
+#include "drmu.h"
+#include "drmu_vlc_fmts.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Get cropping rectangle from a vlc format
+static inline drmu_rect_t
+drmu_rect_vlc_format_crop(const video_frame_format_t * const format)
+{
+    return (drmu_rect_t){
+        .x = format->i_x_offset,
+        .y = format->i_y_offset,
+        .w = format->i_visible_width,
+        .h = format->i_visible_height};
+}
+
+// Get cropping rectangle from a vlc pic
+static inline drmu_rect_t
+drmu_rect_vlc_pic_crop(const picture_t * const pic)
+{
+    return drmu_rect_vlc_format_crop(&pic->format);
+}
+
+// Get rect from vlc place
+static inline drmu_rect_t
+drmu_rect_vlc_place(const vout_display_place_t * const place)
+{
+    return (drmu_rect_t){
+        .x = place->x,
+        .y = place->y,
+        .w = place->width,
+        .h = place->height
+    };
+}
+
+static inline vlc_rational_t
+drmu_ufrac_vlc_to_rational(const drmu_ufrac_t x)
+{
+    return (vlc_rational_t) {.num = x.num, .den = x.den};
+}
+
+drmu_fb_t * drmu_fb_vlc_new_pic_attach(drmu_env_t * const du, picture_t * const pic);
+plane_t drmu_fb_vlc_plane(drmu_fb_t * const dfb, const unsigned int plane_n);
+
+#if HAS_ZC_CMA
+drmu_fb_t * drmu_fb_vlc_new_pic_cma_attach(drmu_env_t * const du, picture_t * const pic);
+#endif
+
+// Copy properties like colour_space, hdr_metadata into the fb
+void drmu_fb_vlc_pic_set_metadata(drmu_fb_t * const dfb, const picture_t * const pic);
+
+// Logging function callback for VLC
+enum drmu_log_level_e;
+void drmu_log_vlc_cb(void * v, enum drmu_log_level_e level_drmu, const char * fmt, va_list vl);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_vlc_fmts.c
@@ -0,0 +1,258 @@
+#include "drmu_vlc_fmts.h"
+
+#include <vlc_picture.h>
+#include <libdrm/drm_fourcc.h>
+
+// These macros not in bullseye
+
+#ifndef fourcc_mod_get_vendor
+#define fourcc_mod_get_vendor(modifier) \
+	(((modifier) >> 56) & 0xff)
+#endif
+
+#ifndef fourcc_mod_is_vendor
+#define fourcc_mod_is_vendor(modifier, vendor) \
+	(fourcc_mod_get_vendor(modifier) == DRM_FORMAT_MOD_VENDOR_## vendor)
+#endif
+
+#ifndef DRM_FORMAT_P030
+#define DRM_FORMAT_P030 fourcc_code('P', '0', '3', '0')
+#endif
+
+#define DRMU_VLC_FMTS_FLAG_DRMP         1
+#define DRMU_VLC_FMTS_FLAG_ZC           2
+#define DRMU_VLC_FMTS_FLAG_FULL_RANGE   4
+
+struct drmu_vlc_fmt_info_ss {
+    vlc_fourcc_t vlc_chroma;
+    uint32_t drm_pixelformat;
+    uint32_t rmask;
+    uint32_t gmask;
+    uint32_t bmask;
+    uint64_t drm_modifier;
+    unsigned int flags;
+};
+
+// N.B. DRM seems to order its format descriptor names the opposite way round to VLC
+// DRM is hi->lo within a little-endian word, VLC is byte order
+
+#define I2(vlc, drm) {(vlc), (drm), 0, 0, 0, DRM_FORMAT_MOD_LINEAR, 0 }
+#define RM(vlc, drm, r, g, b) {(vlc), (drm), (r), (g), (b), DRM_FORMAT_MOD_LINEAR, 0 }
+#define R2(vlc, drm) RM((vlc), (drm), 0, 0, 0)
+
+static const drmu_vlc_fmt_info_t fmt_table[] = {
+    R2(VLC_CODEC_RGBA, DRM_FORMAT_ABGR8888),
+    R2(VLC_CODEC_BGRA, DRM_FORMAT_ARGB8888),
+    R2(VLC_CODEC_ARGB, DRM_FORMAT_BGRA8888),
+    // VLC_CODEC_ABGR does not exist in VLC
+    // AYUV appears to be the only DRM YUVA-like format
+    I2(VLC_CODEC_VUYA, DRM_FORMAT_AYUV),
+    I2(VLC_CODEC_VYUY, DRM_FORMAT_YUYV),
+    I2(VLC_CODEC_UYVY, DRM_FORMAT_YVYU),
+    I2(VLC_CODEC_YUYV, DRM_FORMAT_VYUY),
+    I2(VLC_CODEC_YVYU, DRM_FORMAT_UYVY),
+    I2(VLC_CODEC_NV12, DRM_FORMAT_NV12),
+    I2(VLC_CODEC_NV21, DRM_FORMAT_NV21),
+    I2(VLC_CODEC_NV16, DRM_FORMAT_NV16),
+    I2(VLC_CODEC_NV61, DRM_FORMAT_NV61),
+    I2(VLC_CODEC_NV24, DRM_FORMAT_NV24),
+    I2(VLC_CODEC_NV42, DRM_FORMAT_NV42),
+    I2(VLC_CODEC_P010, DRM_FORMAT_P010),
+    I2(VLC_CODEC_I420, DRM_FORMAT_YUV420),
+    { VLC_CODEC_J420, DRM_FORMAT_YUV420, 0, 0, 0, DRM_FORMAT_MOD_LINEAR, DRMU_VLC_FMTS_FLAG_FULL_RANGE },
+    I2(VLC_CODEC_YV12, DRM_FORMAT_YVU420),
+    I2(VLC_CODEC_I422, DRM_FORMAT_YUV422),
+    { VLC_CODEC_J422, DRM_FORMAT_YUV422, 0, 0, 0, DRM_FORMAT_MOD_LINEAR, DRMU_VLC_FMTS_FLAG_FULL_RANGE },
+    I2(VLC_CODEC_I444, DRM_FORMAT_YUV444),
+    { VLC_CODEC_J444, DRM_FORMAT_YUV444, 0, 0, 0, DRM_FORMAT_MOD_LINEAR, DRMU_VLC_FMTS_FLAG_FULL_RANGE },
+#if HAS_DRMPRIME
+    { VLC_CODEC_DRM_PRIME_I420,   DRM_FORMAT_YUV420,   0, 0, 0, DRM_FORMAT_MOD_LINEAR,           DRMU_VLC_FMTS_FLAG_DRMP },
+    { VLC_CODEC_DRM_PRIME_NV12,   DRM_FORMAT_NV12,     0, 0, 0, DRM_FORMAT_MOD_LINEAR,           DRMU_VLC_FMTS_FLAG_DRMP },
+    { VLC_CODEC_DRM_PRIME_SAND8,  DRM_FORMAT_NV12,     0, 0, 0, DRM_FORMAT_MOD_BROADCOM_SAND128, DRMU_VLC_FMTS_FLAG_DRMP },
+    { VLC_CODEC_DRM_PRIME_SAND30, DRM_FORMAT_P030,     0, 0, 0, DRM_FORMAT_MOD_BROADCOM_SAND128, DRMU_VLC_FMTS_FLAG_DRMP },
+    { VLC_CODEC_DRM_PRIME_RGB32,  DRM_FORMAT_XRGB8888, 0, 0, 0, DRM_FORMAT_MOD_LINEAR,           DRMU_VLC_FMTS_FLAG_DRMP },
+#endif
+#if HAS_ZC_CMA
+    { VLC_CODEC_MMAL_ZC_I420,     DRM_FORMAT_YUV420,   0, 0, 0, DRM_FORMAT_MOD_LINEAR,           DRMU_VLC_FMTS_FLAG_ZC },
+    { VLC_CODEC_MMAL_ZC_SAND8,    DRM_FORMAT_NV12,     0, 0, 0, DRM_FORMAT_MOD_BROADCOM_SAND128, DRMU_VLC_FMTS_FLAG_ZC },
+    { VLC_CODEC_MMAL_ZC_SAND30,   DRM_FORMAT_P030,     0, 0, 0, DRM_FORMAT_MOD_BROADCOM_SAND128, DRMU_VLC_FMTS_FLAG_ZC },
+    { VLC_CODEC_MMAL_ZC_RGB32,    DRM_FORMAT_RGBX8888, 0, 0, 0, DRM_FORMAT_MOD_LINEAR,           DRMU_VLC_FMTS_FLAG_ZC },
+#endif
+
+    RM(VLC_CODEC_RGB32, DRM_FORMAT_XRGB8888, 0xff0000, 0xff00, 0xff),
+    RM(VLC_CODEC_RGB32, DRM_FORMAT_XBGR8888, 0xff, 0xff00, 0xff0000),
+    RM(VLC_CODEC_RGB32, DRM_FORMAT_RGBX8888, 0xff000000, 0xff0000, 0xff00),
+    RM(VLC_CODEC_RGB32, DRM_FORMAT_BGRX8888, 0xff00, 0xff0000, 0xff000000),
+    // The 24-bit versions seem to have BE masks?!
+    RM(VLC_CODEC_RGB24, DRM_FORMAT_BGR888,   0xff0000, 0xff00, 0xff),
+    RM(VLC_CODEC_RGB24, DRM_FORMAT_RGB888,   0xff, 0xff00, 0xff0000),
+    RM(VLC_CODEC_RGB16, DRM_FORMAT_RGB565,   0xf800, 0x7e0, 0x1f),
+    RM(VLC_CODEC_RGB16, DRM_FORMAT_BGR565,   0x1f, 0x7e0, 0xf800),
+
+    I2(0, 0)
+};
+#undef I2
+#undef RM
+#undef R2
+
+// *** Sorted lookups?
+
+const drmu_vlc_fmt_info_t *
+drmu_vlc_fmt_info_find_vlc_next(const video_frame_format_t * const vf_vlc, const drmu_vlc_fmt_info_t * f)
+{
+    f = (f == NULL) ? fmt_table : f + 1;
+
+    for (; f->vlc_chroma != 0; ++f)
+    {
+        if (f->vlc_chroma != vf_vlc->i_chroma)
+            continue;
+        if (f->rmask != 0 && vf_vlc->i_rmask != 0 &&
+            (f->rmask != vf_vlc->i_rmask || f->gmask != vf_vlc->i_gmask || f->bmask != vf_vlc->i_bmask))
+            continue;
+        return f;
+    }
+    return NULL;
+}
+
+const drmu_vlc_fmt_info_t *
+drmu_vlc_fmt_info_find_vlc(const video_frame_format_t * const vf_vlc)
+{
+    return drmu_vlc_fmt_info_find_vlc_next(vf_vlc, NULL);
+}
+
+// Remove any params from a modifier
+static inline uint64_t canon_mod(const uint64_t m)
+{
+    return fourcc_mod_is_vendor(m, BROADCOM) ? fourcc_mod_broadcom_mod(m) : m;
+}
+
+const drmu_vlc_fmt_info_t *
+drmu_vlc_fmt_info_find_drm_next(const uint32_t pixelformat, const uint64_t modifier, const drmu_vlc_fmt_info_t * f)
+{
+    const uint64_t cmod = canon_mod(modifier);
+
+    f = (f == NULL) ? fmt_table : f + 1;
+
+    for (; f->vlc_chroma != 0; ++f)
+    {
+        if (f->drm_pixelformat != pixelformat || f->drm_modifier != cmod)
+            continue;
+        // Only return the "base" version
+        if (f->flags != 0)
+            continue;
+        return f;
+    }
+    return NULL;
+}
+
+const drmu_vlc_fmt_info_t *
+drmu_vlc_fmt_info_find_drm(const uint32_t pixelformat, const uint64_t modifier)
+{
+    return drmu_vlc_fmt_info_find_drm_next(pixelformat, modifier, NULL);
+}
+
+vlc_fourcc_t
+drmu_vlc_fmt_info_vlc_chroma(const drmu_vlc_fmt_info_t * const f)
+{
+    return f == NULL ? 0 : f->vlc_chroma;
+}
+
+void
+drmu_vlc_fmt_info_vlc_rgb_masks(const drmu_vlc_fmt_info_t * const f, uint32_t * r, uint32_t * g, uint32_t * b)
+{
+    if (f == NULL)
+    {
+        *r = 0;
+        *g = 0;
+        *b = 0;
+        return;
+    }
+    *r = f->rmask;
+    *g = f->gmask;
+    *b = f->bmask;
+}
+
+uint32_t
+drmu_vlc_fmt_info_drm_pixelformat(const drmu_vlc_fmt_info_t * const f)
+{
+    return f == NULL ? 0 : f->drm_pixelformat;
+}
+
+uint64_t
+drmu_vlc_fmt_info_drm_modifier(const drmu_vlc_fmt_info_t * const f)
+{
+    return f == NULL ? DRM_FORMAT_MOD_INVALID : f->drm_modifier;
+}
+
+bool
+drmu_vlc_fmt_info_is_drmprime(const drmu_vlc_fmt_info_t * const f)
+{
+#if HAS_DRMPRIME
+    return f != NULL && (f->flags & DRMU_VLC_FMTS_FLAG_DRMP);
+#else
+    (void)f;
+    return false;
+#endif
+}
+
+bool
+drmu_vlc_fmt_info_is_zc_cma(const drmu_vlc_fmt_info_t * const f)
+{
+#if HAS_ZC_CMA
+    return f != NULL && (f->flags & DRMU_VLC_FMTS_FLAG_ZC);
+#else
+    (void)f;
+    return false;
+#endif
+}
+
+
+uint32_t
+drmu_format_vlc_to_drm(const video_frame_format_t * const vf_vlc, uint64_t * const pMod)
+{
+    const drmu_vlc_fmt_info_t * const f = drmu_vlc_fmt_info_find_vlc(vf_vlc);
+
+    if (pMod)
+        *pMod = drmu_vlc_fmt_info_drm_modifier(f);
+    return drmu_vlc_fmt_info_drm_pixelformat(f);
+}
+
+#if HAS_ZC_CMA
+uint32_t
+drmu_format_vlc_to_drm_cma(const video_frame_format_t * const vf_vlc, uint64_t * const pMod)
+{
+    const drmu_vlc_fmt_info_t * f = drmu_vlc_fmt_info_find_vlc(vf_vlc);
+
+    if (!drmu_vlc_fmt_info_is_zc_cma(f))
+        f = NULL;
+
+    if (pMod)
+        *pMod = drmu_vlc_fmt_info_drm_modifier(f);
+    return drmu_vlc_fmt_info_drm_pixelformat(f);
+}
+#endif
+
+#if HAS_DRMPRIME
+uint32_t
+drmu_format_vlc_to_drm_prime(const video_frame_format_t * const vf_vlc, uint64_t * const pMod)
+{
+    const drmu_vlc_fmt_info_t * f = drmu_vlc_fmt_info_find_vlc(vf_vlc);
+
+    if (!drmu_vlc_fmt_info_is_drmprime(f))
+        f = NULL;
+
+    if (pMod)
+        *pMod = drmu_vlc_fmt_info_drm_modifier(f);
+    return drmu_vlc_fmt_info_drm_pixelformat(f);
+}
+#endif
+
+// Convert chroma to drm - can't cope with RGB32 or RGB16 as they require
+// more info
+uint32_t
+drmu_format_vlc_chroma_to_drm(const vlc_fourcc_t chroma)
+{
+    const drmu_vlc_fmt_info_t * f = drmu_vlc_fmt_info_find_vlc(&(const video_frame_format_t){.i_chroma = chroma});
+    return drmu_vlc_fmt_info_drm_pixelformat(f);
+}
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_vlc_fmts.h
@@ -0,0 +1,57 @@
+#ifndef _DRMU_DRMU_VLC_FMTS_H
+#define _DRMU_DRMU_VLC_FMTS_H
+
+#include "config.h"
+
+#ifndef HAS_ZC_CMA
+#define HAS_ZC_CMA   0
+#endif
+#define HAS_DRMPRIME 1
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <vlc_common.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct drmu_vlc_fmt_info_ss;
+typedef struct drmu_vlc_fmt_info_ss drmu_vlc_fmt_info_t;
+
+const drmu_vlc_fmt_info_t * drmu_vlc_fmt_info_find_vlc(const video_frame_format_t * const vf_vlc);
+// f == NULL => start at the beginning
+const drmu_vlc_fmt_info_t * drmu_vlc_fmt_info_find_vlc_next(const video_frame_format_t * const vf_vlc, const drmu_vlc_fmt_info_t * f);
+const drmu_vlc_fmt_info_t * drmu_vlc_fmt_info_find_drm(const uint32_t pixelformat, const uint64_t modifier);
+// f == NULL => start at the beginning
+const drmu_vlc_fmt_info_t * drmu_vlc_fmt_info_find_drm_next(const uint32_t pixelformat, const uint64_t modifier, const drmu_vlc_fmt_info_t * f);
+
+vlc_fourcc_t drmu_vlc_fmt_info_vlc_chroma(const drmu_vlc_fmt_info_t * const f);
+void drmu_vlc_fmt_info_vlc_rgb_masks(const drmu_vlc_fmt_info_t * const f, uint32_t * r, uint32_t * g, uint32_t * b);
+uint32_t drmu_vlc_fmt_info_drm_pixelformat(const drmu_vlc_fmt_info_t * const f);
+uint64_t drmu_vlc_fmt_info_drm_modifier(const drmu_vlc_fmt_info_t * const f);
+
+bool drmu_vlc_fmt_info_is_zc_cma(const drmu_vlc_fmt_info_t * const f);
+bool drmu_vlc_fmt_info_is_drmprime(const drmu_vlc_fmt_info_t * const f);
+
+
+// Convert chroma to drm - can't cope with RGB32 or RGB16 as they require
+// more info. returns 0 if unknown.
+uint32_t drmu_format_vlc_chroma_to_drm(const vlc_fourcc_t chroma);
+// Convert format to drm fourcc - does cope with RGB32 & RGB16
+// pMod receives modifier - may be null
+uint32_t drmu_format_vlc_to_drm(const video_frame_format_t * const vf_vlc, uint64_t * const pMod);
+
+#if HAS_DRMPRIME
+// pmod may be NULL
+uint32_t drmu_format_vlc_to_drm_prime(const video_frame_format_t * const vf_vlc, uint64_t * const pmod);
+#endif
+#if HAS_ZC_CMA
+uint32_t drmu_format_vlc_to_drm_cma(const video_frame_format_t * const vf_vlc, uint64_t * const pMod);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
--- /dev/null
+++ b/modules/video_output/drmu/drmu_writeback.c
@@ -0,0 +1,429 @@
+#include "drmu_writeback.h"
+
+#include <drm_fourcc.h>
+#include <errno.h>
+#include <semaphore.h>
+#include <stdatomic.h>
+#include <stdint.h>
+#include <unistd.h>
+
+#include "drmu.h"
+#include "drmu_log.h"
+#include "drmu_output.h"
+#include "drmu_pool.h"
+#include "pollqueue.h"
+
+#include <assert.h>
+
+struct drmu_writeback_env_s {
+    atomic_int ref_count;
+
+    drmu_env_t * du;
+    drmu_output_t * dout;
+    drmu_queue_t * dq;
+    struct pollqueue * pq;
+
+    // Find the primary plane for use with writeback_fb
+    // We will want something more complex/comprehensive for general render ops
+    drmu_plane_t * plane_pri;
+
+    atomic_int tag_n;
+
+    sem_t * finish_sem;
+};
+
+static void
+writeback_env_free(drmu_writeback_env_t * const wbe)
+{
+    sem_t * const finish_sem = wbe->finish_sem;
+
+    drmu_queue_finish(&wbe->dq);
+    pollqueue_finish(&wbe->pq);
+    drmu_plane_unref(&wbe->plane_pri);
+    drmu_output_unref(&wbe->dout);
+    drmu_env_unref(&wbe->du);
+    free(wbe);
+
+    if (finish_sem != NULL)
+        sem_post(finish_sem);
+}
+
+// Get a "unique" non-zero tag no
+static unsigned int
+writeback_env_tag_new(drmu_writeback_env_t * const wbe)
+{
+    unsigned int n;
+    while ((n = atomic_fetch_add(&wbe->tag_n, 1)) == 0)
+        /* Loop */;
+    return n;
+}
+
+drmu_writeback_env_t *
+drmu_writeback_env_new(struct drmu_env_s * const du)
+{
+    drmu_writeback_env_t * wbe = calloc(1, sizeof(*wbe));
+
+    if (wbe == NULL)
+        return NULL;
+
+    wbe->du = drmu_env_ref(du);
+
+    if ((wbe->dq = drmu_queue_new(du)) == NULL) {
+        drmu_err(du, "Cannot allocate queue");
+        goto fail;
+    }
+    drmu_queue_keep_last_set(wbe->dq, false);
+    drmu_queue_lock_on_commit_set(wbe->dq, true);
+
+    if ((wbe->dout = drmu_output_new(du)) == NULL) {
+        drmu_err(du, "Cannot allocate output");
+        goto fail;
+    }
+
+    if (drmu_output_modeset_allow(wbe->dout, true) != 0) {
+        drmu_err(du, "Failed to allow modeset");
+        goto fail;
+    }
+
+    if (drmu_output_add_writeback(wbe->dout) != 0) {
+        drmu_err(du, "Failed to add writeback");
+        goto fail;
+    }
+
+    if ((wbe->plane_pri = drmu_output_plane_ref_primary(wbe->dout)) == NULL) {
+        drmu_err(du, "Failed to find prmary plane");
+        goto fail;
+    }
+
+    if ((wbe->pq = pollqueue_new()) == NULL) {
+        drmu_err(du, "Failed to get pollqueue");
+        goto fail;
+    }
+
+    return wbe;
+
+fail:
+    writeback_env_free(wbe);
+    return NULL;
+}
+
+drmu_writeback_env_t *
+drmu_writeback_env_ref(drmu_writeback_env_t * const wbe)
+{
+    if (wbe != NULL)
+        atomic_fetch_add(&wbe->ref_count, 1);
+    return wbe;
+}
+
+void
+drmu_writeback_env_unref(drmu_writeback_env_t ** const ppwbe)
+{
+    drmu_writeback_env_t * const wbe = *ppwbe;
+    int n;
+
+    if (wbe == NULL)
+        return;
+    n = atomic_fetch_sub(&wbe->ref_count, 1);
+    if (n != 0)
+        return;
+
+    writeback_env_free(wbe);
+}
+
+void
+drmu_writeback_env_finish(drmu_writeback_env_t ** const ppwbe)
+{
+    sem_t sem;
+
+    if (*ppwbe == NULL)
+        return;
+
+    sem_init(&sem, 0, 0);
+    (*ppwbe)->finish_sem = &sem;
+    drmu_writeback_env_unref(ppwbe);
+    while (sem_wait(&sem) != 0 && errno == EINTR)
+        /* Loop */;
+    sem_destroy(&sem);
+}
+
+struct drmu_output_s *
+drmu_writeback_env_output(const drmu_writeback_env_t * const wbe)
+{
+    return wbe == NULL ? NULL : wbe->dout;
+}
+
+drmu_plane_t *
+drmu_writeback_env_fmt_plane(drmu_writeback_env_t * const wbe,
+                             drmu_output_t * const dest_dout, const unsigned int types,
+                             uint32_t * const pFmt)
+{
+    size_t fmt_count = 1;
+    const uint32_t * fmts = drmu_conn_writeback_formats(drmu_output_conn(wbe->dout, 0), &fmt_count);
+
+    // This is a simple & stupid search.
+    // We expect the 1st format we try to be both "good enough" and compatible with the dest dout
+    for (size_t i = 0; i != fmt_count; ++i) {
+        const uint32_t fmt = fmts[i];
+
+        // *** Kludge for Pi not supporting rotation on this
+        if (fmt == DRM_FORMAT_BGR888 || fmt == DRM_FORMAT_RGB888)
+            continue;
+
+        drmu_plane_t * const dp = drmu_output_plane_ref_format(dest_dout, types, fmt, 0);
+
+        if (dp != NULL) {
+            *pFmt = fmts[i];
+            return dp;
+        }
+    }
+    *pFmt = 0;
+    return NULL;
+}
+
+//-----------------------------------------------------------------------------
+
+typedef struct wbq_ent_s {
+    atomic_int ref_count;
+
+    drmu_fb_t * fb;
+    bool done;
+    struct pollqueue * pq;
+    struct polltask * pt;
+    drmu_writeback_fb_done_fn * done_fn;
+    void * done_v;
+    drmu_queue_t * dqueue;
+} wbq_ent_t;
+
+static void
+wbq_ent_free(wbq_ent_t * const ent)
+{
+    if (ent == NULL)
+        return;
+
+    if (!ent->done)
+        ent->done_fn(ent->done_v, NULL);
+
+    drmu_fb_unref(&ent->fb);
+    // In normal useg these two should already be unreffed
+    polltask_delete(&ent->pt);
+    pollqueue_unref(&ent->pq);
+    drmu_queue_unref(&ent->dqueue);
+    free(ent);
+}
+
+static wbq_ent_t *
+wbq_ent_ref(wbq_ent_t * const ent)
+{
+    if (ent == NULL)
+        return NULL;
+    atomic_fetch_add(&ent->ref_count, 1);
+    return ent;
+}
+
+static void
+wbq_ent_unref(wbq_ent_t ** const ppent)
+{
+    wbq_ent_t * const ent = *ppent;
+    int n;
+
+    if (ent == NULL)
+        return;
+    *ppent = NULL;
+
+    n = atomic_fetch_sub(&ent->ref_count, 1);
+    if (n != 0)
+        return;
+
+    wbq_ent_free(ent);
+}
+
+static void
+writeback_fb_ent_polltask_done(void * v, short revents)
+{
+    wbq_ent_t * ent = v;
+
+    drmu_queue_unlock(ent->dqueue);
+
+    close(drmu_fb_out_fence_take_fd(ent->fb));
+    if (revents != 0) {
+        ent->done_fn(ent->done_v, ent->fb);
+        ent->done = true;
+    }
+    polltask_delete(&ent->pt);
+    drmu_fb_unref(&ent->fb);
+    wbq_ent_unref(&ent);
+}
+
+static void
+writeback_fb_ent_commit_cb(void * v, int fd, drmu_fb_t * dfb)
+{
+    wbq_ent_t * ent = v;
+
+    if (fd != -1 && dfb != NULL) {
+        ent->pt = polltask_new(ent->pq, fd, POLLIN, writeback_fb_ent_polltask_done, wbq_ent_ref(ent));
+        pollqueue_add_task(ent->pt, 1000);
+        pollqueue_unref(&ent->pq);
+    }
+    else {
+        wbq_ent_unref(&ent);
+    }
+}
+
+struct drmu_writeback_fb_s {
+    atomic_int ref_count;
+
+    drmu_writeback_env_t * wbe;
+    drmu_pool_t * pool;
+
+    unsigned int q_tag;
+    drmu_queue_merge_t q_merge;
+};
+
+static void
+writeback_fb_free(drmu_writeback_fb_t * const wbq)
+{
+    drmu_writeback_env_unref(&wbq->wbe);
+    drmu_pool_unref(&wbq->pool);
+    free(wbq);
+}
+
+drmu_writeback_fb_t *
+drmu_writeback_fb_new(drmu_writeback_env_t * const wbe, drmu_pool_t * const fb_pool)
+{
+    drmu_writeback_fb_t * const wbq = calloc(1, sizeof(*wbq));
+
+    if (wbq == NULL)
+        return NULL;
+
+    wbq->wbe = drmu_writeback_env_ref(wbe);
+    wbq->pool = drmu_pool_ref(fb_pool);
+    wbq->q_tag = writeback_env_tag_new(wbe);
+    wbq->q_merge = DRMU_QUEUE_MERGE_REPLACE;
+
+    return wbq;
+}
+
+drmu_writeback_fb_t *
+drmu_writeback_fb_ref(drmu_writeback_fb_t * const wbq)
+{
+    if (wbq == NULL)
+        return NULL;
+    atomic_fetch_add(&wbq->ref_count, 1);
+    return wbq;
+}
+
+void
+drmu_writeback_fb_unref(drmu_writeback_fb_t ** const ppwbq)
+{
+    drmu_writeback_fb_t * const wbq = *ppwbq;
+    int n;
+
+    if (wbq == NULL)
+        return;
+    *ppwbq = NULL;
+
+    n = atomic_fetch_sub(&wbq->ref_count, 1);
+    if (n != 0)
+        return;
+
+    writeback_fb_free(wbq);
+}
+
+static drmu_rect_t
+limit_rect(const drmu_rect_t dest_rect, const unsigned int rot_conn)
+{
+    drmu_rect_t r = dest_rect;
+
+    // Pi has a max input width -> output height if transposed
+    if (r.h > 1920 && drmu_rotation_is_transposed(rot_conn))
+        r.h = 1920;
+
+    r.x = 0;
+    r.y = 0;
+    return r;
+}
+
+
+int
+drmu_writeback_fb_queue(drmu_writeback_fb_t * wbq,
+                        const drmu_rect_t dest_rect, const unsigned int dest_rot, const uint32_t fmt,
+                        drmu_writeback_fb_done_fn * const done_fn, void * const v,
+                        drmu_fb_t * const fb)
+{
+    wbq_ent_t * ent = calloc(1, sizeof(*ent));
+    drmu_writeback_env_t * const wbe = wbq->wbe;
+    drmu_env_t * const du = wbe->du;
+    drmu_atomic_t * da = drmu_atomic_new(du);
+    unsigned int rot_total;
+    unsigned int rot_plane;
+    unsigned int rot_conn;
+    drmu_rect_t r;
+    int rv;
+
+    if (ent == NULL) {
+        done_fn(v, NULL);
+        rv = -ENOMEM;
+        goto fail;
+    }
+
+    ent->done_fn = done_fn;
+    ent->done_v = v;
+    ent->pq = pollqueue_ref(wbe->pq);
+    ent->dqueue = drmu_queue_ref(wbe->dq);
+
+    if (da == NULL) {
+        rv = -ENOMEM;
+        goto fail;
+    }
+
+    rot_total = drmu_fb_rotation(fb, dest_rot);
+
+    rot_plane = drmu_rotation_find(rot_total, drmu_plane_rotation_mask(wbe->plane_pri),
+                                   drmu_conn_rotation_mask(drmu_output_conn(wbe->dout, 0)));
+    if (rot_plane == DRMU_ROTATION_INVALID) {
+        drmu_err(du, "Cannot find combination of rotations for %d", rot_total);
+        rv = -EINVAL;
+        goto fail;
+    }
+    rot_conn = drmu_rotation_subb(rot_plane, rot_total);
+
+    r = limit_rect(dest_rect, rot_conn);
+
+    if ((rv = drmu_atomic_plane_add_fb(da, wbe->plane_pri, fb,
+                                 drmu_rotation_is_transposed(rot_conn) ? drmu_rect_transpose(r) : r)) != 0)
+    {
+        drmu_err(du, "Failed atomic add fb");
+        goto fail;
+    }
+    drmu_atomic_plane_add_rotation(da, wbe->plane_pri, rot_plane);
+
+    ent->fb = (wbq->pool == NULL) ?
+        drmu_fb_new_dumb(du, r.w, r.h, fmt) :
+        drmu_pool_fb_new(wbq->pool, r.w, r.h, fmt, 0);
+
+    if (ent->fb == NULL) {
+        drmu_err(du, "Failed to create fb");
+        rv = -ENOMEM;
+        goto fail;
+    }
+
+    rv = drmu_atomic_output_add_writeback_fb_callback(da, wbe->dout, ent->fb, rot_conn, writeback_fb_ent_commit_cb, ent);
+    ent = NULL; // Ownership taken by call
+    if (rv != 0) {
+        drmu_err(du, "Failed to add writeback fb\n");
+        goto fail;
+    }
+
+    if ((rv = drmu_queue_queue_tagged(wbe->dq, wbq->q_tag, wbq->q_merge, &da)) != 0) {
+        drmu_err(du, "Failed merge");
+        goto fail;
+    }
+
+    return 0;
+
+fail:
+    drmu_atomic_unref(&da);
+    wbq_ent_unref(&ent);
+    return rv;
+}
+
--- /dev/null
+++ b/modules/video_output/drmu/drmu_writeback.h
@@ -0,0 +1,64 @@
+#ifndef _DRMU_WRITEBACK_H
+#define _DRMU_WRITEBACK_H
+
+#include <stdint.h>
+
+#include "drmu_math.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct drmu_env_s;
+struct drmu_fb_s;
+struct drmu_output_s;
+struct drmu_plane_s;
+struct drmu_pool_s;
+
+struct drmu_writeback_env_s;
+typedef struct drmu_writeback_env_s drmu_writeback_env_t;
+
+drmu_writeback_env_t * drmu_writeback_env_new(struct drmu_env_s * const du);
+drmu_writeback_env_t * drmu_writeback_env_ref(drmu_writeback_env_t * const wbe);
+void drmu_writeback_env_unref(drmu_writeback_env_t ** const ppwbe);
+
+void drmu_writeback_env_finish(drmu_writeback_env_t ** const ppwbe);
+
+// Output associated with Q (and therefore conn & crtc)
+struct drmu_output_s * drmu_writeback_env_output(const drmu_writeback_env_t * const wbe);
+
+// Find and ref a plane in dest_dout that is compatible with a format that the
+// writeback connector can produce. The format is returned in *pFmt
+// Types is a bit field of acceptable plane types (DRMU_PLANE_TYPE_xxx), 0 => any
+// cf. drmu_output_plane_ref_format
+// Returns NULL if nothing compatible found
+struct drmu_plane_s * drmu_writeback_env_fmt_plane(drmu_writeback_env_t * const wbe,
+                                                   struct drmu_output_s * const dest_dout, const unsigned int types,
+                                                   uint32_t * const pFmt);
+
+struct drmu_writeback_fb_s;
+typedef struct drmu_writeback_fb_s drmu_writeback_fb_t;
+
+// fb_pool is the pool to alloc wb fbs from
+drmu_writeback_fb_t * drmu_writeback_fb_new(drmu_writeback_env_t * const wbe, struct drmu_pool_s * const fb_pool);
+drmu_writeback_fb_t * drmu_writeback_fb_ref(drmu_writeback_fb_t * const wbq);
+void drmu_writeback_fb_unref(drmu_writeback_fb_t ** const ppwbq);
+
+// dfb NULL if writeback failed or abandoned
+// BEWARE: As it stands this is called inside a Q lock so any queue operations
+// to the same (writeback) Q from here will deadlock. Queue ops to another Q
+// (say display) are fine.
+// * It would be good to fix this
+typedef void drmu_writeback_fb_done_fn(void * v, struct drmu_fb_s * dfb);
+
+int drmu_writeback_fb_queue(drmu_writeback_fb_t * wbq,
+                            const drmu_rect_t dest_rect, const unsigned int rot, const uint32_t fmt,
+                            drmu_writeback_fb_done_fn * const done_fn, void * const v,
+                            struct drmu_fb_s * const fb);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/modules/video_output/drmu/drmu_xlease.c
@@ -0,0 +1,143 @@
+#include "drmu.h"
+#include "drmu_log.h"
+
+#include <xcb/xcb.h>
+#include <xcb/randr.h>
+
+static int
+get_lease_fd(const drmu_log_env_t * const log)
+{
+    xcb_generic_error_t *xerr;
+
+    int screen = 0;
+    xcb_connection_t * const connection = xcb_connect(NULL, &screen);
+    if (!connection) {
+        drmu_warn_log(log, "Connection to X server failed");
+        return -1;
+    }
+
+    {
+        xcb_randr_query_version_cookie_t rqv_c = xcb_randr_query_version(connection,
+                                                                         XCB_RANDR_MAJOR_VERSION,
+                                                                         XCB_RANDR_MINOR_VERSION);
+        xcb_randr_query_version_reply_t *rqv_r = xcb_randr_query_version_reply(connection, rqv_c, NULL);
+
+        if (!rqv_r) {
+            drmu_warn_log(log, "Failed to get XCB RandR version");
+            return -1;
+        }
+
+        uint32_t major = rqv_r->major_version;
+        uint32_t minor = rqv_r->minor_version;
+        free(rqv_r);
+
+        if (minor < 6) {
+            drmu_warn_log(log, "XCB RandR version %d.%d too low for lease support", major, minor);
+            return -1;
+        }
+    }
+
+    xcb_window_t root;
+
+    {
+        xcb_screen_iterator_t s_i = xcb_setup_roots_iterator(xcb_get_setup(connection));
+        int i;
+
+        for (i = 0; i != screen && s_i.rem != 0; ++i) {
+             xcb_screen_next(&s_i);
+        }
+
+        if (s_i.rem == 0) {
+            drmu_err_log(log, "Failed to get root for screen %d", screen);
+            return -1;
+        }
+
+        drmu_debug_log(log, "index %d screen %d rem %d", s_i.index, screen, s_i.rem);
+        root = s_i.data->root;
+    }
+
+    xcb_randr_output_t output = 0;
+    xcb_randr_crtc_t crtc = 0;
+
+    /* Find a connected in-use output */
+    {
+        xcb_randr_get_screen_resources_cookie_t gsr_c = xcb_randr_get_screen_resources(connection, root);
+
+        xcb_randr_get_screen_resources_reply_t *gsr_r = xcb_randr_get_screen_resources_reply(connection, gsr_c, NULL);
+        int o;
+
+        if (!gsr_r) {
+            drmu_err_log(log, "get_screen_resources failed");
+            return -1;
+        }
+
+        xcb_randr_output_t * const ro = xcb_randr_get_screen_resources_outputs(gsr_r);
+
+        for (o = 0; output == 0 && o < gsr_r->num_outputs; o++) {
+            xcb_randr_get_output_info_cookie_t goi_c = xcb_randr_get_output_info(connection, ro[o], gsr_r->config_timestamp);
+
+            xcb_randr_get_output_info_reply_t *goi_r = xcb_randr_get_output_info_reply(connection, goi_c, NULL);
+
+            drmu_debug_log(log, "output[%d/%d] %d: conn %d/%d crtc %d", o, gsr_r->num_outputs, ro[o], goi_r->connection, XCB_RANDR_CONNECTION_CONNECTED, goi_r->crtc);
+
+            /* Find the first connected and used output */
+            if (goi_r->connection == XCB_RANDR_CONNECTION_CONNECTED &&
+                goi_r->crtc != 0) {
+                output = ro[o];
+                crtc = goi_r->crtc;
+            }
+
+            free(goi_r);
+        }
+
+        free(gsr_r);
+
+        if (output == 0) {
+            drmu_warn_log(log, "Failed to find active output (outputs=%d)", o);
+            return -1;
+        }
+    }
+
+    int fd = -1;
+
+    {
+        xcb_randr_lease_t lease = xcb_generate_id(connection);
+
+        xcb_randr_create_lease_cookie_t rcl_c = xcb_randr_create_lease(connection,
+                                                                       root,
+                                                                       lease,
+                                                                       1,
+                                                                       1,
+                                                                       &crtc,
+                                                                       &output);
+        xcb_randr_create_lease_reply_t *rcl_r = xcb_randr_create_lease_reply(connection, rcl_c, &xerr);
+
+        if (!rcl_r) {
+            drmu_err_log(log, "create_lease failed: Xerror %d", xerr->error_code);
+            return -1;
+        }
+
+        int *rcl_f = xcb_randr_create_lease_reply_fds(connection, rcl_r);
+
+        fd = rcl_f[0];
+
+        free(rcl_r);
+    }
+
+    drmu_debug_log(log, "%s OK: fd=%d", __func__, fd);
+    return fd;
+}
+
+drmu_env_t *
+drmu_env_new_xlease(const drmu_log_env_t * const log2)
+{
+    const struct drmu_log_env_s * const log = (log2 == NULL) ? &drmu_log_env_none : log2;
+    const int fd = get_lease_fd(log);
+
+    if (fd == -1) {
+        drmu_err_log(log, "Failed to get xlease");
+        return NULL;
+    }
+    return drmu_env_new_fd(fd, log);
+}
+
--- /dev/null
+++ b/modules/video_output/drmu/pollqueue.c
@@ -0,0 +1,716 @@
+#include "pollqueue.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+#include <poll.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <stdatomic.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/eventfd.h>
+
+#define request_log(...) fprintf(stderr, __VA_ARGS__)
+
+struct pollqueue;
+
+enum polltask_state {
+    POLLTASK_UNQUEUED = 0,
+    POLLTASK_QUEUED,
+    POLLTASK_RUNNING,
+    POLLTASK_Q_KILL,
+    POLLTASK_Q_DEAD,
+    POLLTASK_RUN_KILL,
+    POLLTASK_EXIT,
+};
+
+// Run this task once and auto delete it once run
+#define POLLTASK_FLAG_ONCE      1
+// This polltask does not keep a ref to its Q
+// This means that it does not block queue deletion and will run on thread
+// exit with revents = -1. Caller is reponsible for ensuring that the queue
+// is valid for the duration of the tasks existence.
+#define POLLTASK_FLAG_NO_REF    2
+
+struct polltask {
+    struct polltask *next;
+    struct polltask *prev;
+    struct pollqueue *q;
+    enum polltask_state state;
+
+    int fd;
+    short events;
+    unsigned short flags;
+
+    void (*fn)(void *v, short revents);
+    void * v;
+
+    uint64_t timeout; /* CLOCK_MONOTONIC time, 0 => never */
+};
+
+struct pollqueue {
+    atomic_int ref_count;
+    pthread_mutex_t lock;
+    pthread_cond_t cond;
+
+    struct polltask *head;
+    struct polltask *tail;
+
+    struct prepost_ss {
+        void (*pre)(void *v, struct pollfd *pfd);
+        void (*post)(void *v, short revents);
+        void *v;
+    } prepost;
+
+    void (* exit_fn)(void * v);
+    void * exit_v;
+
+    // On thread exit do not detach - counted value allows us to cope with
+    // multiple simultainious finish calls. Only poked from poll_thread so
+    // no need to lock.
+    int join_req;
+
+    bool kill;
+    bool no_prod;
+
+    bool sig_seq; // Signal cond when seq incremented
+    uint32_t seq;
+
+    int prod_fd;
+    struct polltask *prod_pt;
+    pthread_t worker;
+};
+
+static struct polltask *
+polltask_new2(struct pollqueue *const pq,
+              const int fd, const short events,
+              void (*const fn)(void *v, short revents),
+              void *const v,
+              const unsigned short flags)
+{
+    struct polltask *pt;
+
+    if (!events && fd != -1)
+        return NULL;
+
+    pt = malloc(sizeof(*pt));
+    if (!pt)
+        return NULL;
+
+    *pt = (struct polltask){
+        .next = NULL,
+        .prev = NULL,
+        .q = (flags & POLLTASK_FLAG_NO_REF) != 0 ? pq : pollqueue_ref(pq),
+        .fd = fd,
+        .events = events,
+        .flags = flags,
+        .fn = fn,
+        .v = v
+    };
+
+    return pt;
+}
+
+struct polltask *
+polltask_new(struct pollqueue *const pq,
+             const int fd, const short events,
+             void (*const fn)(void *v, short revents),
+             void *const v)
+{
+    return polltask_new2(pq, fd, events, fn, v, 0);
+}
+
+struct polltask *polltask_new_timer(struct pollqueue *const pq,
+                  void (*const fn)(void *v, short revents),
+                  void *const v)
+{
+    return polltask_new(pq, -1, 0, fn, v);
+}
+
+int pollqueue_timer_once(struct pollqueue *const pq,
+                         void (*const fn)(void *v, short revents),
+                         void *const v,
+                         const int timeout_ms)
+{
+    struct polltask * const pt = polltask_new2(pq, -1, 0, fn, v, POLLTASK_FLAG_ONCE);
+    if (pt == NULL)
+        return -EINVAL;
+    pollqueue_add_task(pt, timeout_ms);
+    return 0;
+}
+
+int
+pollqueue_callback_once(struct pollqueue *const pq,
+                        void (*const fn)(void *v, short revents),
+                        void *const v)
+{
+    return pollqueue_timer_once(pq, fn, v, 0);
+}
+
+static void pollqueue_rem_task(struct pollqueue *const pq, struct polltask *const pt)
+{
+    if (pt->prev)
+        pt->prev->next = pt->next;
+    else
+        pq->head = pt->next;
+    if (pt->next)
+        pt->next->prev = pt->prev;
+    else
+        pq->tail = pt->prev;
+    pt->next = NULL;
+    pt->prev = NULL;
+}
+
+static void polltask_free(struct polltask * const pt)
+{
+    free(pt);
+}
+
+static void polltask_kill(struct polltask * const pt)
+{
+    struct pollqueue * pq = (pt->flags & POLLTASK_FLAG_NO_REF) != 0 ? NULL : pt->q;
+    polltask_free(pt);
+    pollqueue_unref(&pq);
+}
+
+static void polltask_dead(struct polltask * const pt)
+{
+    pt->state = POLLTASK_Q_DEAD;
+    pthread_cond_broadcast(&pt->q->cond);
+}
+
+static void pollqueue_prod(const struct pollqueue *const pq)
+{
+    static const uint64_t one = 1;
+    int rv;
+    while ((rv = write(pq->prod_fd, &one, sizeof(one))) != sizeof(one)) {
+        if (!(rv == -1 && errno == EINTR))
+            break;
+    }
+}
+
+static bool am_in_thread(const struct pollqueue * const pq)
+{
+    return pthread_equal(pthread_self(), pq->worker);
+}
+
+void polltask_delete(struct polltask **const ppt)
+{
+    struct polltask *const pt = *ppt;
+    struct pollqueue * pq;
+    enum polltask_state state;
+    bool prodme;
+    bool inthread;
+
+    if (!pt)
+        return;
+
+    pq = pt->q;
+    inthread = am_in_thread(pq);
+
+    pthread_mutex_lock(&pq->lock);
+    state = pt->state;
+    pt->state = inthread ? POLLTASK_RUN_KILL : POLLTASK_Q_KILL;
+    prodme = !pq->no_prod;
+    pthread_mutex_unlock(&pq->lock);
+
+    switch (state) {
+        case POLLTASK_UNQUEUED:
+            *ppt = NULL;
+            polltask_kill(pt);
+            break;
+
+        case POLLTASK_QUEUED:
+        case POLLTASK_RUNNING:
+        {
+            int rv = 0;
+
+            if (inthread) {
+                // We are in worker thread - kill in main loop to avoid confusion or deadlock
+                *ppt = NULL;
+                break;
+            }
+
+            if (prodme)
+                pollqueue_prod(pq);
+
+            pthread_mutex_lock(&pq->lock);
+            while (rv == 0 && pt->state != POLLTASK_Q_DEAD)
+                rv = pthread_cond_wait(&pq->cond, &pq->lock);
+            pthread_mutex_unlock(&pq->lock);
+
+            // Leave zapping the ref until we have DQed the PT as might well be
+            // legitimately used in it
+            *ppt = NULL;
+            polltask_kill(pt);
+            break;
+        }
+        default:
+            request_log("%s: Unexpected task state: %d\n", __func__, state);
+            *ppt = NULL;
+            break;
+    }
+}
+
+static uint64_t pollqueue_now(int timeout)
+{
+    struct timespec now;
+    uint64_t now_ms;
+
+    if (clock_gettime(CLOCK_MONOTONIC, &now))
+        return 0;
+    now_ms = (now.tv_nsec / 1000000) + (uint64_t)now.tv_sec * 1000 + timeout;
+    return now_ms ? now_ms : (uint64_t)1;
+}
+
+void pollqueue_add_task(struct polltask *const pt, const int timeout)
+{
+    bool prodme = false;
+    struct pollqueue * const pq = pt->q;
+    const uint64_t timeout_time = timeout < 0 ? 0 : pollqueue_now(timeout);
+
+    pthread_mutex_lock(&pq->lock);
+    if (pt->state == POLLTASK_UNQUEUED || pt->state == POLLTASK_RUNNING) {
+        if (pq->tail)
+            pq->tail->next = pt;
+        else
+            pq->head = pt;
+        pt->prev = pq->tail;
+        pt->next = NULL;
+        pt->state = POLLTASK_QUEUED;
+        pt->timeout = timeout_time;
+        pq->tail = pt;
+        prodme = !pq->no_prod;
+    }
+    pthread_mutex_unlock(&pq->lock);
+    if (prodme)
+        pollqueue_prod(pq);
+}
+
+static void *poll_thread(void *v)
+{
+    struct pollqueue *const pq = v;
+
+    pthread_mutex_lock(&pq->lock);
+    do {
+        struct pollfd a[POLLQUEUE_MAX_QUEUE];
+        unsigned int i, j;
+        unsigned int nall = 0;
+        unsigned int npoll = 0;
+        struct polltask *pt;
+        struct polltask *pt_next;
+        struct prepost_ss prepost;
+        uint64_t timeout0 = 0;
+        int rv;
+
+        for (pt = pq->head; pt; pt = pt_next) {
+            pt_next = pt->next;
+
+            if (pt->state == POLLTASK_Q_KILL) {
+                pollqueue_rem_task(pq, pt);
+                polltask_dead(pt);
+                continue;
+            }
+            if (pt->state == POLLTASK_RUN_KILL) {
+                pollqueue_rem_task(pq, pt);
+                polltask_kill(pt);
+                continue;
+            }
+
+            if (pt->fd != -1) {
+                assert(npoll < POLLQUEUE_MAX_QUEUE - 1); // Allow for pre/post
+                a[npoll++] = (struct pollfd){
+                    .fd = pt->fd,
+                    .events = pt->events
+                };
+            }
+
+            // Get earliest timeout
+            if (pt->timeout != 0 &&
+                (timeout0 == 0 || (int64_t)(pt->timeout - timeout0) < 0))
+                timeout0 = pt->timeout;
+
+            ++nall;
+        }
+        prepost = pq->prepost;
+        pthread_mutex_unlock(&pq->lock);
+
+        a[npoll] = (struct pollfd){.fd=-1, .events=0, .revents=0};
+        if (prepost.pre)
+            prepost.pre(prepost.v, a + npoll);
+
+        do {
+            const int64_t diff = (int64_t)(timeout0 - pollqueue_now(0));
+            const int timeout = timeout0 == 0 ? -1 :
+                                diff <= 0 ? 0 :
+                                diff >= INT_MAX ? INT_MAX : (int)diff;
+
+            rv = poll(a, npoll + (a[npoll].fd != -1), timeout);
+        } while (rv == -1 && errno == EINTR);
+
+        // Only do timeouts if nothing polled
+        if (rv > 0)
+            timeout0 = 0;
+
+        if (prepost.post)
+            prepost.post(prepost.v, a[npoll].revents);
+
+        if (rv == -1) {
+            request_log("Poll error: %s\n", strerror(errno));
+            goto fail_unlocked;
+        }
+
+        pthread_mutex_lock(&pq->lock);
+        /* Prodding in this loop is pointless and might lead to
+         * infinite looping
+        */
+        pq->no_prod = true;
+
+        // Sync for prepost changes
+        ++pq->seq;
+        if (pq->sig_seq) {
+            pq->sig_seq = false;
+            pthread_cond_broadcast(&pq->cond);
+        }
+
+        for (i = 0, j = 0, pt = pq->head; i < nall; ++i, pt = pt_next) {
+            const short r = pt->fd == -1 ? 0 : a[j++].revents;
+            pt_next = pt->next;
+
+            if (pt->state != POLLTASK_QUEUED)
+                continue;
+
+            /* Pending?
+             * Take time as intended time rather than actual time.
+             * probably makes no actual difference and saves us a call
+             */
+            if (r || (pt->timeout != 0 && timeout0 != 0 &&
+                      (int64_t)(timeout0 - pt->timeout) >= 0)) {
+                pollqueue_rem_task(pq, pt);
+                pt->state = POLLTASK_RUNNING;
+                pthread_mutex_unlock(&pq->lock);
+
+                /* This can add new entries to the Q but as
+                 * those are added to the tail our existing
+                 * chain remains intact
+                */
+                pt->fn(pt->v, r);
+
+                pthread_mutex_lock(&pq->lock);
+                if (pt->state == POLLTASK_Q_KILL)
+                    polltask_dead(pt);
+                else if (pt->state == POLLTASK_RUN_KILL ||
+                    (pt->flags & POLLTASK_FLAG_ONCE) != 0)
+                    polltask_kill(pt);
+                else if (pt->state == POLLTASK_RUNNING)
+                    pt->state = POLLTASK_UNQUEUED;
+            }
+        }
+        pq->no_prod = false;
+
+    } while (!pq->kill);
+
+    {
+        struct polltask * pt;
+        for (pt = pq->head; pt != NULL; pt = pt->next)
+            pt->state = POLLTASK_EXIT;
+    }
+    pthread_mutex_unlock(&pq->lock);
+fail_unlocked:
+
+    {
+        struct polltask *pt = pq->head;
+
+        pthread_cond_destroy(&pq->cond);
+        pthread_mutex_destroy(&pq->lock);
+        close(pq->prod_fd);
+        if (!pq->join_req != 0)
+            pthread_detach(pthread_self());
+        free(pq);
+
+        // **** Think harder about freeing non-single use PTs
+        // prod may be special?
+        while (pt != NULL) {
+            struct polltask * const next = pt->next;
+            pt->fn(pt->v, -1);
+            polltask_free(pt);
+            pt = next;
+        }
+    }
+
+    return NULL;
+}
+
+static void prod_fn(void *v, short revents)
+{
+    struct pollqueue *const pq = v;
+    char buf[8];
+    if (revents == -1)
+        return;
+    if (revents != 0) {
+        int rv;
+        while ((rv = read(pq->prod_fd, buf, 8)) != 8) {
+            if (!(rv == -1 && errno == EINTR))
+                break;
+        }
+    }
+    pollqueue_add_task(pq->prod_pt, -1);
+}
+
+struct pollqueue * pollqueue_new(void)
+{
+    struct pollqueue *pq = malloc(sizeof(*pq));
+    if (!pq)
+        return NULL;
+    *pq = (struct pollqueue){
+        .ref_count = ATOMIC_VAR_INIT(0),
+        .lock = PTHREAD_MUTEX_INITIALIZER,
+        .cond = PTHREAD_COND_INITIALIZER,
+        .head = NULL,
+        .tail = NULL,
+        .kill = false,
+        .prod_fd = -1
+    };
+
+    pq->prod_fd = eventfd(0, EFD_NONBLOCK);
+    if (pq->prod_fd == -1)
+        goto fail1;
+    pq->prod_pt = polltask_new2(pq, pq->prod_fd, POLLIN, prod_fn, pq, POLLTASK_FLAG_NO_REF);
+    if (!pq->prod_pt)
+        goto fail2;
+    pollqueue_add_task(pq->prod_pt, -1);
+    if (pthread_create(&pq->worker, NULL, poll_thread, pq))
+        goto fail3;
+    return pq;
+
+fail3:
+    polltask_free(pq->prod_pt);
+fail2:
+    close(pq->prod_fd);
+fail1:
+    free(pq);
+    return NULL;
+}
+
+static void pollqueue_free(struct pollqueue *const pq)
+{
+    if (am_in_thread(pq)) {
+        pq->kill = true;
+        if (!pq->no_prod)
+            pollqueue_prod(pq);
+    }
+    else
+    {
+        pthread_mutex_lock(&pq->lock);
+        pq->kill = true;
+        // Must prod inside lock here as otherwise there is a potential race
+        // where the worker terminates and pq is freed before the prod
+        if (!pq->no_prod)
+            pollqueue_prod(pq);
+        pthread_mutex_unlock(&pq->lock);
+    }
+}
+
+struct pollqueue * pollqueue_ref(struct pollqueue *const pq)
+{
+    atomic_fetch_add(&pq->ref_count, 1);
+    return pq;
+}
+
+void pollqueue_unref(struct pollqueue **const ppq)
+{
+    struct pollqueue * const pq = *ppq;
+
+    if (!pq)
+        return;
+    *ppq = NULL;
+
+    if (atomic_fetch_sub(&pq->ref_count, 1) != 0)
+        return;
+
+    pollqueue_free(pq);
+}
+
+//----------------------------------------------------------------------------
+//
+// Finish code.
+// Most of the complexity is in ensuring that timeouts are raceless
+// Try to keep everything that might error in the calling thread so
+// the error can be signalled easily
+
+struct finish_timeout_ss {
+    bool timed_out;
+    int timeout_ms;
+    struct pollqueue * pq;
+    struct polltask * pt;
+    sem_t sem;
+};
+
+// Inc ref_count iff it hasn't gone -ve i.e. _free has not been called
+// If we inc from -ve then there is always a race that might end up with
+// freeing twice
+static bool
+unfinish(struct pollqueue * const pq)
+{
+    int n = atomic_load(&pq->ref_count);
+    while (n >= 0 && !atomic_compare_exchange_weak(&pq->ref_count, &n, n + 1))
+        /* loop */;
+    return n >= 0;
+}
+
+static void
+finish_timeout_cb2(void *v, short revents)
+{
+    struct finish_timeout_ss * const ft = v;
+    struct pollqueue * const pq = ft->pq;
+
+    if (revents != -1 && unfinish(pq))
+    {
+        --pq->join_req;
+        ft->timed_out = true;
+    }
+
+    sem_post(&ft->sem);
+}
+
+static void
+finish_timeout_cb1(void *v, short revents)
+{
+    struct finish_timeout_ss * const ft = v;
+    struct pollqueue * pq = ft->pq;
+    (void)revents;
+
+    ++pq->join_req;
+    pollqueue_add_task(ft->pt, ft->timeout_ms);
+    pollqueue_unref(&pq);
+}
+
+int
+pollqueue_finish_timeout(struct pollqueue **const ppq, int timeout_ms)
+{
+    struct pollqueue * pq = *ppq;
+    pthread_t worker;
+    struct finish_timeout_ss ft;
+    int rv;
+
+    if (!pq)
+        return 0;
+
+    ft.timed_out = false;
+    ft.timeout_ms = timeout_ms;
+    ft.pq = pq;
+    ft.pt = polltask_new2(pq, -1, 0, finish_timeout_cb2, &ft,
+                          POLLTASK_FLAG_ONCE | POLLTASK_FLAG_NO_REF);
+    if (ft.pt == NULL)
+        return -ENOMEM;
+
+    sem_init(&ft.sem, 0, 0);
+
+    worker = pq->worker;
+
+    // Kick execution into poll thread as otherwise there are races
+    // between the execution of _cb2 and the unref
+    if ((rv = pollqueue_callback_once(pq, finish_timeout_cb1, &ft)) != 0)
+    {
+        polltask_delete(&ft.pt);
+        sem_destroy(&ft.sem);
+        return rv;
+    }
+
+    while (sem_wait(&ft.sem) == -1 && errno == EINTR)
+        /* loop */;
+    sem_destroy(&ft.sem);
+
+    if (ft.timed_out)
+        return 1;
+
+    pthread_join(worker, NULL);
+
+    // Delay zapping the ref until after the join as it is legit for the
+    // remaining active polltasks to use it.
+    *ppq = NULL;
+    return 0;
+}
+
+void
+pollqueue_finish(struct pollqueue **const ppq)
+{
+    // Whilst it is possible to write a simpler non-timeout version
+    // of the finish code it is a better idea to keep the code common
+    // given that performance is not important.
+    pollqueue_finish_timeout(ppq, -1);
+}
+
+//----------------------------------------------------------------------------
+
+void pollqueue_set_pre_post(struct pollqueue *const pq,
+                            void (*fn_pre)(void *v, struct pollfd *pfd),
+                            void (*fn_post)(void *v, short revents),
+                            void *v)
+{
+    const bool in_thread = am_in_thread(pq);
+
+    pthread_mutex_lock(&pq->lock);
+    pq->prepost.pre = fn_pre;
+    pq->prepost.post = fn_post;
+    pq->prepost.v = v;
+
+    if (!pq->no_prod && !in_thread) {
+        const uint32_t seq = pq->seq;
+        int rv = 0;
+
+        pollqueue_prod(pq);
+
+        pq->sig_seq = true;
+        while (rv == 0 && pq->seq == seq)
+            rv = pthread_cond_wait(&pq->cond, &pq->lock);
+    }
+    pthread_mutex_unlock(&pq->lock);
+}
+
+//----------------------------------------------------------------------------
+//
+// On exit fn
+// Would have been simpler if it took a standard callback
+
+struct exit_env_ss {
+    void (* fn)(void * v);
+    void * v;
+};
+
+static void exit_cb(void * v, short revents)
+{
+    struct exit_env_ss * ee = v;
+    assert(revents == -1);
+
+    ee->fn(ee->v);
+    free(ee);
+}
+
+void pollqueue_set_exit(struct pollqueue *const pq,
+                        void (* const exit_fn)(void * v), void * v)
+{
+    struct exit_env_ss * ee = malloc(sizeof(*ee));
+    struct polltask * pt;
+
+    if (ee == NULL)
+        return;
+
+    ee->fn = exit_fn;
+    ee->v = v;
+
+    pt = polltask_new2(pq, -1, 0, exit_cb, ee, POLLTASK_FLAG_ONCE | POLLTASK_FLAG_NO_REF);
+    if (pt == NULL)
+        goto fail;
+
+    pollqueue_add_task(pt, -1);
+    return;
+
+fail:
+    free(ee);
+}
--- /dev/null
+++ b/modules/video_output/drmu/pollqueue.h
@@ -0,0 +1,101 @@
+#ifndef POLLQUEUE_H_
+#define POLLQUEUE_H_
+
+#include <poll.h>
+
+struct polltask;
+struct pollqueue;
+
+// Max number of tasks that can be Qed
+#define POLLQUEUE_MAX_QUEUE 128
+
+// Create a new polltask
+// Holds a reference on the pollqueue until the polltask is deleted
+//
+// pq       pollqueue this task belongs to
+// fd       fd to poll
+// events   Events to wait for (POLLxxx)
+// revents  Event that triggered the callback
+//          0 => timeout
+// v        User pointer to callback
+struct polltask *polltask_new(struct pollqueue *const pq,
+                              const int fd, const short events,
+                              void (*const fn)(void *v, short revents),
+                              void *const v);
+// polltask suitable for timing (i.e. has no trigger event)
+struct polltask *polltask_new_timer(struct pollqueue *const pq,
+                              void (*const fn)(void *v, short revents),
+                              void *const v);
+
+// deletes the task
+// Safe to call if *ppt == NULL
+// It is safe to call whilst a polltask is queued (and may be triggered)
+// Callback may occur whilst this is in progress but will not occur
+// once it is done. (*ppt is nulled only once the callback can not occur)
+// May be called in a polltask callback
+// If called from outside the polltask thread and this causes the pollqueue
+// to be deleted then it will wait for the polltask thread to terminate
+// before returning.
+void polltask_delete(struct polltask **const ppt);
+
+// Queue a polltask
+// timeout_ms == -1 => never
+// May be called from the polltask callback
+// May only be added once (currently)
+void pollqueue_add_task(struct polltask *const pt, const int timeout);
+
+// Run a callback once on the poll thread
+int pollqueue_callback_once(struct pollqueue *const pq,
+                            void (*const fn)(void *v, short revents),
+                            void *const v);
+
+// Run a timer once on the poll thread
+int pollqueue_timer_once(struct pollqueue *const pq,
+                         void (*const fn)(void *v, short revents),
+                         void *const v,
+                         const int timeout_ms);
+
+// Create a pollqueue
+// Generates a new thread to do the polltask callbacks
+struct pollqueue * pollqueue_new(void);
+
+// Unref a pollqueue
+// Will be deleted once all polltasks (Qed or otherwise) are deleted too
+// Will not wait for polltask termination whether or not this is the last
+// ref.
+void pollqueue_unref(struct pollqueue **const ppq);
+
+// Unrefs a pollqueue and then waits for the polltask thread to terminate
+// before returning. *ppq is not set to NULL until after the polltask thread
+// has terminated so it is safe for use by any remaining polltasks (e.g. for
+// creating other tasks that need to complete before finishing.)
+void pollqueue_finish(struct pollqueue **const ppq);
+
+// As pollqueue_finish but with timeout
+// Returns:
+//  -ve Error
+//   0  Pollqueue finished within timeout. As pollqueue_finish
+//   1  Timeout. *ppq is left unchanged is still a reference to the Q
+//      i.e. another _unref or _finish call is required to shutdown
+int pollqueue_finish_timeout(struct pollqueue **const ppq, int timeout_ms);
+
+// Add a reference to a pollqueue
+struct pollqueue * pollqueue_ref(struct pollqueue *const pq);
+
+// Set pre & post poll functions
+// Both set s.t. there is always matched pre - poll - post even when
+// changing the fns.
+// pollfd will be added to polls if *pfd set (leave unset if not wanted)
+// One or both of pre/post may be 0 (uncalled)
+// Will wait if needed until the poll thread is not in the old pre/poll/post
+// sequence
+void pollqueue_set_pre_post(struct pollqueue *const pq,
+                            void (*fn_pre)(void *v, struct pollfd *pfd),
+                            void (*fn_post)(void *v, short revents),
+                            void *v);
+
+// Set callback to execture on the poll thread when it exits
+void pollqueue_set_exit(struct pollqueue *const pq,
+                        void (* const exit_fn)(void * v), void * v);
+
+#endif /* POLLQUEUE_H_ */
