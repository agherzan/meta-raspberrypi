From dccb02593a433ee8b2c44359ec1f2897b624a5d7 Mon Sep 17 00:00:00 2001
From: John Cox <jc@kynesim.co.uk>
Date: Wed, 12 Jun 2024 10:59:10 +0100
Subject: [PATCH 35/41] video_output/wayland: Add dmabuf output

Previously all output was via shm which can be inefficient.
Depends on some files from drmu for DRM format info.


Upstream-Status: Inappropriate

RPI-Distro repo forks original vlc and applies patches

to enable raspiberry pi support.
---

 configure.ac                                  |    9 +
 modules/video_output/Makefile.am              |   73 +-
 modules/video_output/wayland/dmabuf_alloc.c   |  516 +++
 modules/video_output/wayland/dmabuf_alloc.h   |   59 +
 modules/video_output/wayland/picpool.c        |  369 +++
 modules/video_output/wayland/picpool.h        |   24 +
 modules/video_output/wayland/rgba_premul.c    |  243 ++
 modules/video_output/wayland/rgba_premul.h    |   18 +
 .../wayland/rgba_premul_aarch64.S             |  170 +
 .../wayland/rgba_premul_aarch64.h             |    9 +
 modules/video_output/wayland/wl_dmabuf.c      | 2885 +++++++++++++++++
 11 files changed, 4374 insertions(+), 1 deletion(-)
 create mode 100644 modules/video_output/wayland/dmabuf_alloc.c
 create mode 100644 modules/video_output/wayland/dmabuf_alloc.h
 create mode 100644 modules/video_output/wayland/picpool.c
 create mode 100644 modules/video_output/wayland/picpool.h
 create mode 100644 modules/video_output/wayland/rgba_premul.c
 create mode 100644 modules/video_output/wayland/rgba_premul.h
 create mode 100644 modules/video_output/wayland/rgba_premul_aarch64.S
 create mode 100644 modules/video_output/wayland/rgba_premul_aarch64.h
 create mode 100644 modules/video_output/wayland/wl_dmabuf.c

--- a/configure.ac
+++ b/configure.ac
@@ -3288,6 +3288,7 @@ AC_ARG_ENABLE(wayland,
 have_wayland="no"
 have_wayland_egl="no"
 have_wayland_single_pixel_buffer="no"
+have_wayland_color_representation="no"
 
 AS_IF([test "${enable_wayland}" = "yes"], [
   PKG_CHECK_MODULES([WAYLAND_CLIENT], [wayland-client >= 1.5.91], [
@@ -3302,6 +3303,13 @@ AS_IF([test "${enable_wayland}" = "yes"]
       ], [
          AC_MSG_RESULT([no])
       ])
+      AC_MSG_CHECKING([for Wayland protocols color representation])
+      PKG_CHECK_EXISTS([wayland-protocols >= 1.44], [
+         AC_MSG_RESULT([yes])
+         have_wayland_color_representation="yes"
+      ], [
+         AC_MSG_RESULT([no])
+      ])
     ], [
       AC_MSG_RESULT([not found])
       AC_MSG_ERROR([$(${PKG_CONFIG} --print-errors 'wayland-protocols >= 1.4')])
@@ -3336,6 +3344,7 @@ AC_SUBST([WAYLAND_SCANNER])
 AM_CONDITIONAL([HAVE_WAYLAND], [test "${have_wayland}" = "yes"])
 AM_CONDITIONAL([HAVE_WAYLAND_EGL], [test "${have_wayland_egl}" = "yes"])
 AM_CONDITIONAL([HAVE_WAYLAND_SINGLE_PIXEL_BUFFER], [test "${have_wayland_single_pixel_buffer}" = "yes"])
+AM_CONDITIONAL([HAVE_WAYLAND_COLOR_REPRESENTATION], [test "${have_wayland_color_representation}" = "yes"])
 
 
 dnl
--- a/modules/video_output/Makefile.am
+++ b/modules/video_output/Makefile.am
@@ -238,7 +238,76 @@ video_output/wayland/viewporter-client-p
 
 video_output/wayland/viewporter-protocol.c: \
 		$(WAYLAND_PROTOCOLS)/stable/viewporter/viewporter.xml
-	$(AM_V_GEN)$(WAYLAND_SCANNER) code $< $@
+	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code $< $@
+
+video_output/wayland/presentation-time-client-protocol.h: \
+		$(WAYLAND_PROTOCOLS)/stable/presentation-time/presentation-time.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header $< $@
+
+video_output/wayland/presentation-time-protocol.c: \
+		$(WAYLAND_PROTOCOLS)/stable/presentation-time/presentation-time.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code $< $@
+
+video_output/wayland/linux-dmabuf-unstable-v1-client-protocol.h: \
+		$(WAYLAND_PROTOCOLS)/unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header $< $@
+
+video_output/wayland/linux-dmabuf-unstable-v1-protocol.c: \
+		$(WAYLAND_PROTOCOLS)/unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code $< $@
+
+video_output/wayland/single-pixel-buffer-v1-client-protocol.h: \
+		$(WAYLAND_PROTOCOLS)/staging/single-pixel-buffer/single-pixel-buffer-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header $< $@
+
+video_output/wayland/color-representation-v1-client-protocol.h: \
+		$(WAYLAND_PROTOCOLS)/staging/color-representation/color-representation-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header $< $@
+
+libwl_dmabuf_plugin_la_SOURCES = video_output/wayland/wl_dmabuf.c\
+	video_output/wayland/picpool.c video_output/wayland/picpool.h\
+	video_output/wayland/dmabuf_alloc.c video_output/wayland/dmabuf_alloc.h\
+	video_output/wayland/rgba_premul.c video_output/wayland/rgba_premul.h\
+	video_output/drmu/pollqueue.c video_output/drmu/pollqueue.h\
+	video_output/drmu/drmu_vlc_fmts.c video_output/drmu/drmu_vlc_fmts.h
+nodist_libwl_dmabuf_plugin_la_SOURCES = \
+	video_output/wayland/viewporter-client-protocol.h \
+	video_output/wayland/viewporter-protocol.c \
+	video_output/wayland/presentation-time-client-protocol.h \
+	video_output/wayland/presentation-time-protocol.c \
+	video_output/wayland/linux-dmabuf-unstable-v1-client-protocol.h \
+	video_output/wayland/linux-dmabuf-unstable-v1-protocol.c
+
+libwl_dmabuf_plugin_la_CPPFLAGS = $(AM_CPPFLAGS) \
+	-I$(builddir)/video_output/wayland -pthread
+libwl_dmabuf_plugin_la_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) -pthread
+libwl_dmabuf_plugin_la_LIBADD = $(WAYLAND_CLIENT_LIBS)
+libwl_dmabuf_plugin_la_LDFLAGS = $(AM_LDFLAGS) -pthread
+if HAVE_ARM64
+libwl_dmabuf_plugin_la_SOURCES += video_output/wayland/rgba_premul_aarch64.S\
+	video_output/wayland/rgba_premul_aarch64.h
+libwl_dmabuf_plugin_la_CFLAGS += -DHAVE_AARCH64_ASM=1
+endif
+if HAVE_WAYLAND_SINGLE_PIXEL_BUFFER
+video_output/wayland/single-pixel-buffer-v1-protocol.c: \
+		$(WAYLAND_PROTOCOLS)/staging/single-pixel-buffer/single-pixel-buffer-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code $< $@
+nodist_libwl_dmabuf_plugin_la_SOURCES +=\
+	video_output/wayland/single-pixel-buffer-v1-client-protocol.h \
+	video_output/wayland/single-pixel-buffer-v1-protocol.c
+libwl_dmabuf_plugin_la_CFLAGS += -DHAVE_WAYLAND_SINGLE_PIXEL_BUFFER=1
+endif
+if HAVE_WAYLAND_COLOR_REPRESENTATION
+video_output/wayland/color-representation-v1-protocol.c: \
+		$(WAYLAND_PROTOCOLS)/staging/color-representation/color-representation-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code $< $@
+nodist_libwl_dmabuf_plugin_la_SOURCES +=\
+	video_output/wayland/color-representation-v1-client-protocol.h \
+	video_output/wayland/color-representation-v1-protocol.c
+libwl_dmabuf_plugin_la_CFLAGS += -DHAVE_WAYLAND_COLOR_REPRESENTATION=1
+endif
+
+CLEANFILES += $(nodist_libwl_dmabuf_plugin_la_SOURCES)
 
 libwl_shell_plugin_la_SOURCES = video_output/wayland/shell.c
 libwl_shell_plugin_la_CFLAGS = $(WAYLAND_CLIENT_CFLAGS)
@@ -277,6 +346,8 @@ libegl_wl_plugin_la_LIBADD = $(EGL_LIBS)
 if HAVE_WAYLAND
 BUILT_SOURCES += $(nodist_libwl_shm_plugin_la_SOURCES)
 vout_LTLIBRARIES += libwl_shm_plugin.la
+BUILT_SOURCES += $(nodist_libwl_dmabuf_plugin_la_SOURCES)
+vout_LTLIBRARIES += libwl_dmabuf_plugin.la
 vout_LTLIBRARIES += libwl_shell_plugin.la
 BUILT_SOURCES += $(nodist_libxdg_shell_plugin_la_SOURCES)
 vout_LTLIBRARIES += libxdg_shell_plugin.la
--- /dev/null
+++ b/modules/video_output/wayland/dmabuf_alloc.c
@@ -0,0 +1,516 @@
+#define _GNU_SOURCE 1
+#include <stdatomic.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <inttypes.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <linux/dma-buf.h>
+#include <linux/dma-heap.h>
+
+#include "dmabuf_alloc.h"
+
+#define DMABUF_NAME1  "/dev/dma_heap/linux,cma"
+#define DMABUF_NAME2  "/dev/dma_heap/reserved"
+
+#define TRACE_ALLOC 0
+
+#define request_log(...)
+#define request_debug(...)
+
+struct dmabufs_ctl;
+struct dmabuf_h;
+
+struct dmabuf_fns {
+    int (*buf_alloc)(struct dmabufs_ctl * dbsc, struct dmabuf_h * dh, size_t size);
+    void (*buf_free)(struct dmabuf_h * dh);
+    int (*ctl_new)(struct dmabufs_ctl * dbsc);
+    void (*ctl_free)(struct dmabufs_ctl * dbsc);
+};
+
+struct dmabufs_ctl {
+    atomic_int ref_count;
+    int fd;
+    size_t page_size;
+    void * v;
+    const struct dmabuf_fns * fns;
+};
+
+#define DH_FLAG_FAKE 1
+
+struct dmabuf_h {
+    atomic_int ref_count;
+    int fd;
+    size_t size;
+    size_t len;
+    void * mapptr;
+    void * v;
+    const struct dmabuf_fns * fns;
+    unsigned int flags;
+
+    void * predel_v;
+    int (* predel_fn)(struct dmabuf_h * dh, void * v);
+};
+
+#if TRACE_ALLOC
+static unsigned int total_bufs = 0;
+static size_t total_size = 0;
+#endif
+
+struct dmabuf_h * dmabuf_import_mmap(void * mapptr, size_t size)
+{
+    struct dmabuf_h *dh;
+
+    if (mapptr == MAP_FAILED)
+        return NULL;
+
+    dh = malloc(sizeof(*dh));
+    if (!dh)
+        return NULL;
+
+    *dh = (struct dmabuf_h) {
+        .fd = -1,
+        .size = size,
+        .mapptr = mapptr,
+        .flags = DH_FLAG_FAKE,
+    };
+
+    return dh;
+}
+
+struct dmabuf_h * dmabuf_import(int fd, size_t size)
+{
+    struct dmabuf_h *dh;
+
+    fd = dup(fd);
+    if (fd < 0  || size == 0)
+        return NULL;
+
+    dh = malloc(sizeof(*dh));
+    if (!dh) {
+        close(fd);
+        return NULL;
+    }
+
+    *dh = (struct dmabuf_h) {
+        .fd = fd,
+        .size = size,
+        .mapptr = MAP_FAILED
+    };
+
+#if TRACE_ALLOC
+    ++total_bufs;
+    total_size += dh->size;
+    request_log("%s: Import: %zd, total=%zd, bufs=%d\n", __func__, dh->size, total_size, total_bufs);
+#endif
+
+    return dh;
+}
+
+void dmabuf_free(struct dmabuf_h * dh)
+{
+    if (!dh)
+        return;
+
+#if TRACE_ALLOC
+    --total_bufs;
+    total_size -= dh->size;
+    request_log("%s: Free: %zd, total=%zd, bufs=%d\n", __func__, dh->size, total_size, total_bufs);
+#endif
+
+    dh->fns->buf_free(dh);
+
+    if (dh->mapptr != MAP_FAILED && dh->mapptr != NULL)
+        munmap(dh->mapptr, dh->size);
+    if (dh->fd != -1)
+        while (close(dh->fd) == -1 && errno == EINTR)
+            /* loop */;
+    free(dh);
+}
+
+void dmabuf_unref(struct dmabuf_h ** const ppdh)
+{
+    struct dmabuf_h * dh = *ppdh;
+    int n;
+
+    if (dh == NULL)
+        return;
+    *ppdh = NULL;
+
+    n = atomic_fetch_sub(&dh->ref_count, 1);
+//    fprintf(stderr, "%s[%p]: Ref: %d\n", __func__, dh, n);
+    if (n != 0)
+        return;
+
+    if (dh->predel_fn && dh->predel_fn(dh, dh->predel_v) != 0)
+        return;
+
+    dmabuf_free(dh);
+}
+
+struct dmabuf_h * dmabuf_ref(struct dmabuf_h * const dh)
+{
+    if (dh != NULL)
+    {
+        int n = atomic_fetch_add(&dh->ref_count, 1);
+//        fprintf(stderr, "%s[%p]: Ref: %d\n", __func__, dh, n);
+        (void)n;
+    }
+    return dh;
+}
+
+void dmabuf_predel_cb_set(struct dmabuf_h * const dh,
+                          int (* const predel_fn)(struct dmabuf_h * dh, void * v), void * const predel_v)
+{
+    dh->predel_fn = predel_fn;
+    dh->predel_v  = predel_v;
+}
+
+struct dmabuf_h * dmabuf_realloc(struct dmabufs_ctl * dbsc, struct dmabuf_h * old, size_t size)
+{
+    struct dmabuf_h * dh;
+    if (old != NULL) {
+        if (old->size >= size) {
+            return old;
+        }
+        dmabuf_free(old);
+    }
+
+    if (size == 0 ||
+        (dh = malloc(sizeof(*dh))) == NULL)
+        return NULL;
+
+    *dh = (struct dmabuf_h){
+        .fd = -1,
+        .mapptr = MAP_FAILED,
+        .fns = dbsc->fns
+    };
+
+    if (dh->fns->buf_alloc(dbsc, dh, size) != 0)
+        goto fail;
+
+
+#if TRACE_ALLOC
+    ++total_bufs;
+    total_size += dh->size;
+    request_log("%s: Alloc: %zd, total=%zd, bufs=%d\n", __func__, dh->size, total_size, total_bufs);
+#endif
+
+    return dh;
+
+fail:
+    free(dh);
+    return NULL;
+}
+
+int dmabuf_sync(struct dmabuf_h * const dh, unsigned int flags)
+{
+    struct dma_buf_sync sync = {
+        .flags = flags
+    };
+    if ((dh->flags & DH_FLAG_FAKE) != 0)
+        return 0;
+    while (ioctl(dh->fd, DMA_BUF_IOCTL_SYNC, &sync) == -1) {
+        const int err = errno;
+        if (errno == EINTR)
+            continue;
+        request_log("%s: ioctl failed: flags=%#x\n", __func__, flags);
+        return -err;
+    }
+    return 0;
+}
+
+int dmabuf_write_start(struct dmabuf_h * const dh)
+{
+    return dmabuf_sync(dh, DMA_BUF_SYNC_START | DMA_BUF_SYNC_WRITE);
+}
+
+int dmabuf_write_end(struct dmabuf_h * const dh)
+{
+    return dmabuf_sync(dh, DMA_BUF_SYNC_END | DMA_BUF_SYNC_WRITE);
+}
+
+int dmabuf_read_start(struct dmabuf_h * const dh)
+{
+    if (!dmabuf_map(dh))
+        return -1;
+    return dmabuf_sync(dh, DMA_BUF_SYNC_START | DMA_BUF_SYNC_READ);
+}
+
+int dmabuf_read_end(struct dmabuf_h * const dh)
+{
+    return dmabuf_sync(dh, DMA_BUF_SYNC_END | DMA_BUF_SYNC_READ);
+}
+
+
+void * dmabuf_map(struct dmabuf_h * const dh)
+{
+    if (!dh)
+        return NULL;
+    if (dh->mapptr != MAP_FAILED)
+        return dh->mapptr;
+    dh->mapptr = mmap(NULL, dh->size,
+              PROT_READ | PROT_WRITE,
+              MAP_SHARED | MAP_POPULATE,
+              dh->fd, 0);
+    if (dh->mapptr == MAP_FAILED) {
+        request_log("%s: Map failed\n", __func__);
+        return NULL;
+    }
+//    fprintf(stderr, "map to %p\n", dh->mapptr);
+    return dh->mapptr;
+}
+
+int dmabuf_fd(const struct dmabuf_h * const dh)
+{
+    if (!dh)
+        return -1;
+    return dh->fd;
+}
+
+size_t dmabuf_size(const struct dmabuf_h * const dh)
+{
+    if (!dh)
+        return 0;
+    return dh->size;
+}
+
+size_t dmabuf_len(const struct dmabuf_h * const dh)
+{
+    if (!dh)
+        return 0;
+    return dh->len;
+}
+
+void dmabuf_len_set(struct dmabuf_h * const dh, const size_t len)
+{
+    dh->len = len;
+}
+
+bool dmabuf_is_fake(const struct dmabuf_h * const dh)
+{
+    return (dh->flags & DH_FLAG_FAKE) != 0;
+}
+
+static struct dmabufs_ctl * dmabufs_ctl_new2(const struct dmabuf_fns * const fns)
+{
+    struct dmabufs_ctl * dbsc = calloc(1, sizeof(*dbsc));
+
+    if (!dbsc)
+        return NULL;
+
+    dbsc->fd = -1;
+    dbsc->fns = fns;
+
+    dbsc->page_size = (size_t)sysconf(_SC_PAGE_SIZE);
+    // Check page size for plausability & power of 2 - set to 4k if not
+    if (dbsc->page_size < 0x1000 || dbsc->page_size > 0x1000000 ||
+        (dbsc->page_size & (dbsc->page_size - 1)) != 0)
+        dbsc->page_size = 0x1000;
+
+    if (fns->ctl_new(dbsc) != 0)
+        goto fail;
+
+    return dbsc;
+
+fail:
+    free(dbsc);
+    return NULL;
+}
+
+static void dmabufs_ctl_free(struct dmabufs_ctl * const dbsc)
+{
+    request_debug(NULL, "Free dmabuf ctl\n");
+
+    dbsc->fns->ctl_free(dbsc);
+
+    free(dbsc);
+}
+
+void dmabufs_ctl_unref(struct dmabufs_ctl ** const pDbsc)
+{
+    struct dmabufs_ctl * const dbsc = *pDbsc;
+
+    if (!dbsc)
+        return;
+    *pDbsc = NULL;
+
+    if (atomic_fetch_sub(&dbsc->ref_count, 1) != 0)
+        return;
+
+    dmabufs_ctl_free(dbsc);
+}
+
+struct dmabufs_ctl * dmabufs_ctl_ref(struct dmabufs_ctl * const dbsc)
+{
+    atomic_fetch_add(&dbsc->ref_count, 1);
+    return dbsc;
+}
+
+//-----------------------------------------------------------------------------
+//
+// Alloc dmabuf via CMA
+
+static int ctl_cma_new2(struct dmabufs_ctl * dbsc, const char * const * names)
+{
+    for (; *names != NULL; ++names)
+    {
+        while ((dbsc->fd = open(*names, O_RDWR | __O_CLOEXEC)) == -1 &&
+               errno == EINTR)
+            /* Loop */;
+        if (dbsc->fd != -1)
+            return 0;
+    }
+    request_log("Unable to open any dma_heap device\n");
+    return -1;
+}
+
+static int ctl_cma_new(struct dmabufs_ctl * dbsc)
+{
+    static const char * const names[] = {
+        "/dev/dma_heap/vidbuf_cached",
+        "/dev/dma_heap/linux,cma",
+        "/dev/dma_heap/reserved",
+        NULL
+    };
+
+    return ctl_cma_new2(dbsc, names);
+}
+
+static void ctl_cma_free(struct dmabufs_ctl * dbsc)
+{
+    if (dbsc->fd != -1)
+        while (close(dbsc->fd) == -1 && errno == EINTR)
+            /* loop */;
+
+}
+
+static int buf_cma_alloc(struct dmabufs_ctl * const dbsc, struct dmabuf_h * dh, size_t size)
+{
+    struct dma_heap_allocation_data data = {
+        .len = (size + dbsc->page_size - 1) & ~(dbsc->page_size - 1),
+        .fd = 0,
+        .fd_flags = O_RDWR,
+        .heap_flags = 0
+    };
+
+    while (ioctl(dbsc->fd, DMA_HEAP_IOCTL_ALLOC, &data)) {
+        int err = errno;
+        request_log("Failed to alloc %" PRIu64 " from dma-heap(fd=%d): %d (%s)\n",
+                (uint64_t)data.len,
+                dbsc->fd,
+                err,
+                strerror(err));
+        if (err == EINTR)
+            continue;
+        return -err;
+    }
+
+    dh->fd = data.fd;
+    dh->size = (size_t)data.len;
+
+//    fprintf(stderr, "%s: size=%#zx, ftell=%#zx\n", __func__,
+//            dh->size, (size_t)lseek(dh->fd, 0, SEEK_END));
+
+    return 0;
+}
+
+static void buf_cma_free(struct dmabuf_h * dh)
+{
+    (void)dh;
+    // Nothing needed
+}
+
+static const struct dmabuf_fns dmabuf_cma_fns = {
+    .buf_alloc  = buf_cma_alloc,
+    .buf_free   = buf_cma_free,
+    .ctl_new    = ctl_cma_new,
+    .ctl_free   = ctl_cma_free,
+};
+
+struct dmabufs_ctl * dmabufs_ctl_new(void)
+{
+    request_debug(NULL, "Dmabufs using CMA\n");;
+    return dmabufs_ctl_new2(&dmabuf_cma_fns);
+}
+
+//-----------------------------------------------------------------------------
+//
+// Alloc "dmabuf" via shm (one file per alloc)
+
+static int ctl_shm_new(struct dmabufs_ctl * dbsc)
+{
+    (void)dbsc;
+    return 0;
+}
+
+static void ctl_shm_free(struct dmabufs_ctl * dbsc)
+{
+    (void)dbsc;
+}
+
+static int buf_shm_alloc(struct dmabufs_ctl * const dbsc, struct dmabuf_h * dh, size_t size)
+{
+    int fd;
+
+#if 0
+    const char * const tmpdir = "/tmp";
+    fd = open(tmpdir, __O_TMPFILE | O_RDWR, S_IRUSR | S_IWUSR);
+    if (fd == -1) {
+        const int err = errno;
+        request_log("Failed to open tmp file in %s: %s\n", tmpdir, strerror(err));
+        return -err;
+    }
+#else
+    fd = memfd_create("vlc/shm_buf", 0);
+    if (fd == -1) {
+        const int err = errno;
+        request_log("Failed to create memfd: %s\n", strerror(err));
+        return -err;
+    }
+#endif
+
+    // Round up to page size
+    size = (size + dbsc->page_size - 1) & ~(dbsc->page_size - 1);
+
+    if (ftruncate(fd, (off_t)size) != 0)
+    {
+        const int err = errno;
+        request_log("Failed to extend tmp file to %zd: %s\n", size, strerror(err));
+        return -err;
+    }
+
+    dh->fd = fd;
+    dh->size = size;
+    dh->flags = DH_FLAG_FAKE;
+
+//    fprintf(stderr, "%s: size=%#zx, ftell=%#zx\n", __func__,
+//            dh->size, (size_t)lseek(dh->fd, 0, SEEK_END));
+
+    return 0;
+}
+
+static void buf_shm_free(struct dmabuf_h * dh)
+{
+    (void)dh;
+    // Nothing needed
+}
+
+static const struct dmabuf_fns dmabuf_shm_fns = {
+    .buf_alloc  = buf_shm_alloc,
+    .buf_free   = buf_shm_free,
+    .ctl_new    = ctl_shm_new,
+    .ctl_free   = ctl_shm_free,
+};
+
+struct dmabufs_ctl * dmabufs_shm_new()
+{
+    request_debug(NULL, "Dmabufs using SHM\n");;
+    return dmabufs_ctl_new2(&dmabuf_shm_fns);
+}
+
+
--- /dev/null
+++ b/modules/video_output/wayland/dmabuf_alloc.h
@@ -0,0 +1,59 @@
+#ifndef _WAYLAND_DMABUF_ALLOC_H
+#define _WAYLAND_DMABUF_ALLOC_H
+
+#include <stdbool.h>
+#include <stddef.h>
+
+struct dmabufs_ctl;
+struct dmabuf_h;
+
+struct dmabufs_ctl * dmabufs_ctl_new(void);
+void dmabufs_ctl_unref(struct dmabufs_ctl ** const pdbsc);
+struct dmabufs_ctl * dmabufs_ctl_ref(struct dmabufs_ctl * const dbsc);
+
+// Build a "dmabuf" struct that uses ordinary shared memory
+struct dmabufs_ctl * dmabufs_shm_new(void);
+
+
+// Need not preserve old contents
+// On NULL return old buffer is freed
+struct dmabuf_h * dmabuf_realloc(struct dmabufs_ctl * dbsc, struct dmabuf_h *, size_t size);
+
+static inline struct dmabuf_h * dmabuf_alloc(struct dmabufs_ctl * dbsc, size_t size) {
+    return dmabuf_realloc(dbsc, NULL, size);
+}
+/* Create from existing fd - dups(fd) */
+struct dmabuf_h * dmabuf_import(int fd, size_t size);
+/* Import an MMAP - return NULL if mapptr = MAP_FAIL */
+struct dmabuf_h * dmabuf_import_mmap(void * mapptr, size_t size);
+
+void * dmabuf_map(struct dmabuf_h * const dh);
+
+/* flags from linux/dmabuf.h DMA_BUF_SYNC_xxx */
+int dmabuf_sync(struct dmabuf_h * const dh, unsigned int flags);
+
+int dmabuf_write_start(struct dmabuf_h * const dh);
+int dmabuf_write_end(struct dmabuf_h * const dh);
+int dmabuf_read_start(struct dmabuf_h * const dh);
+int dmabuf_read_end(struct dmabuf_h * const dh);
+
+int dmabuf_fd(const struct dmabuf_h * const dh);
+/* Allocated size */
+size_t dmabuf_size(const struct dmabuf_h * const dh);
+/* Bytes in use */
+size_t dmabuf_len(const struct dmabuf_h * const dh);
+/* Set bytes in use */
+void dmabuf_len_set(struct dmabuf_h * const dh, const size_t len);
+/* Are these real dmabufs (false) or is this just something else mmapable (true) */
+bool dmabuf_is_fake(const struct dmabuf_h * const dh);
+
+void dmabuf_predel_cb_set(struct dmabuf_h * const dh,
+                          int (* const predel_fn)(struct dmabuf_h * dh, void * v), void * const predel_v);
+static inline void dmabuf_predel_cb_unset(struct dmabuf_h * const dh) {dmabuf_predel_cb_set(dh, 0, NULL);}
+
+void dmabuf_unref(struct dmabuf_h ** const ppdh);
+struct dmabuf_h * dmabuf_ref(struct dmabuf_h * const dh);
+
+void dmabuf_free(struct dmabuf_h * dh);
+
+#endif
--- /dev/null
+++ b/modules/video_output/wayland/picpool.c
@@ -0,0 +1,369 @@
+#include <assert.h>
+#include <stdatomic.h>
+#include <stdlib.h>
+
+#include <vlc_common.h>
+#include <vlc_threads.h>
+
+#include "picpool.h"
+#include "dmabuf_alloc.h"
+
+// ===========================================================================
+
+typedef struct pool_ent_s
+{
+    struct pool_ent_s * next;
+    struct pool_ent_s * prev;
+
+    atomic_int ref_count;
+    unsigned int seq;
+
+    struct picpool_ctl_s * pc;
+    struct dmabuf_h * db;
+
+    size_t size;
+    unsigned int width;
+    unsigned int height;
+} pool_ent_t;
+
+
+typedef struct ent_list_hdr_s
+{
+    pool_ent_t * ents;
+    pool_ent_t * tail;
+    unsigned int n;
+} ent_list_hdr_t;
+
+#define ENT_LIST_HDR_INIT (ent_list_hdr_t){ \
+   .ents = NULL, \
+   .tail = NULL, \
+   .n = 0 \
+}
+
+struct picpool_ctl_s
+{
+    atomic_int ref_count;
+
+    ent_list_hdr_t ent_pool;
+    ent_list_hdr_t ents_cur;
+    ent_list_hdr_t ents_prev;
+
+    unsigned int max_n;
+    unsigned int seq;
+
+    vlc_mutex_t lock;
+    struct dmabufs_ctl * dbsc;
+};
+
+
+static pool_ent_t * ent_extract(ent_list_hdr_t * const elh, pool_ent_t * const ent)
+{
+//    printf("List %p [%d]: Ext %p\n", elh, elh->n, ent);
+
+    if (ent == NULL)
+        return NULL;
+
+    if (ent->next == NULL)
+        elh->tail = ent->prev;
+    else
+        ent->next->prev = ent->prev;
+
+    if (ent->prev == NULL)
+        elh->ents = ent->next;
+    else
+        ent->prev->next = ent->next;
+
+    ent->prev = ent->next = NULL;
+
+    --elh->n;
+
+    return ent;  // For convienience
+}
+
+static inline pool_ent_t * ent_extract_tail(ent_list_hdr_t * const elh)
+{
+    return ent_extract(elh, elh->tail);
+}
+
+static void ent_add_head(ent_list_hdr_t * const elh, pool_ent_t * const ent)
+{
+//    printf("List %p [%d]: Add %p\n", elh, elh->n, ent);
+
+    if ((ent->next = elh->ents) == NULL)
+        elh->tail = ent;
+    else
+        ent->next->prev = ent;
+
+    ent->prev = NULL;
+    elh->ents = ent;
+    ++elh->n;
+}
+
+static void ent_free(pool_ent_t * const ent)
+{
+//    printf("Free ent: %p\n", ent);
+    if (ent != NULL)
+    {
+        // If we still have a ref to a buffer - kill it now
+        dmabuf_free(ent->db);
+        free(ent);
+    }
+}
+
+static void ent_free_list(ent_list_hdr_t * const elh)
+{
+    pool_ent_t * ent = elh->ents;
+
+//    printf("Free list: %p [%d]\n", elh, elh->n);
+
+    *elh = ENT_LIST_HDR_INIT;
+
+    while (ent != NULL) {
+        pool_ent_t * const t = ent;
+        ent = t->next;
+        ent_free(t);
+    }
+}
+
+#if 0
+static void ent_list_move(ent_list_hdr_t * const dst, ent_list_hdr_t * const src)
+{
+//    printf("Move %p->%p\n", src, dst);
+
+    *dst = *src;
+    *src = ENT_LIST_HDR_INIT;
+}
+#endif
+
+#if 0
+// Scans "backwards" as that should give us the fastest match if we are
+// presented with pics in the same order each time
+static pool_ent_t * ent_list_extract_pic_ent(ent_list_hdr_t * const elh, picture_t * const pic)
+{
+    pool_ent_t *ent = elh->tail;
+
+//    printf("Find list: %p [%d]; pic:%p\n", elh, elh->n, pic);
+
+    while (ent != NULL) {
+//        printf("Check ent: %p, pic:%p\n", ent, ent->pic);
+
+        if (ent->pic == pic)
+            return ent_extract(elh, ent);
+        ent = ent->prev;
+    }
+    return NULL;
+}
+#endif
+
+#define POOL_ENT_ALLOC_BLOCK  0x10000
+
+static pool_ent_t * pool_ent_alloc_new(picpool_ctl_t * const pc, size_t req_size)
+{
+    pool_ent_t * ent = calloc(1, sizeof(*ent));
+    const size_t alloc_size = (req_size + POOL_ENT_ALLOC_BLOCK - 1) & ~(POOL_ENT_ALLOC_BLOCK - 1);
+
+    if (ent == NULL)
+        return NULL;
+
+    ent->next = ent->prev = NULL;
+
+    // Alloc
+    if ((ent->db = dmabuf_realloc(pc->dbsc, NULL, alloc_size)) == NULL)
+        goto fail1;
+//    fprintf(stderr, "%s: ent %p db %p req=%zd size=%zd\n", __func__, ent, ent->db, req_size, alloc_size);
+    ent->size = dmabuf_size(ent->db);
+    return ent;
+
+fail1:
+    free(ent);
+    return NULL;
+}
+
+static inline pool_ent_t * pool_ent_ref(pool_ent_t * const ent)
+{
+//    int n = atomic_fetch_add(&ent->ref_count, 1) + 1;
+//    printf("Ref: %p: %d\n", ent, n);
+    atomic_fetch_add(&ent->ref_count, 1);
+    return ent;
+}
+
+static void pool_recycle(picpool_ctl_t * const pc, pool_ent_t * const ent)
+{
+    pool_ent_t * xs = NULL;
+    int n;
+
+    if (ent == NULL)
+        return;
+
+    n = atomic_fetch_sub(&ent->ref_count, 1) - 1;
+
+//    fprintf(stderr, "%s: Pool: %p: Ent: %p: %d dh: %p\n", __func__, &pc->ent_pool, ent, n, ent->db);
+
+    if (n != 0)
+        return;
+
+    vlc_mutex_lock(&pc->lock);
+
+    // If we have a full pool then extract the LRU and free it
+    // Free done outside mutex
+    if (pc->ent_pool.n >= pc->max_n)
+        xs = ent_extract_tail(&pc->ent_pool);
+
+    ent_add_head(&pc->ent_pool, ent);
+
+    vlc_mutex_unlock(&pc->lock);
+
+    ent_free(xs);
+}
+
+// * This could be made more efficient, but this is easy
+static void pool_recycle_list(picpool_ctl_t * const pc, ent_list_hdr_t * const elh)
+{
+    pool_ent_t * ent;
+    while ((ent = ent_extract_tail(elh)) != NULL) {
+        pool_recycle(pc, ent);
+    }
+}
+
+static int pool_predel_cb(struct dmabuf_h * dh, void * v)
+{
+    pool_ent_t * const ent = v;
+    picpool_ctl_t * pc = ent->pc;
+
+    assert(ent->db == dh);
+
+    ent->pc = NULL;
+    dmabuf_ref(dh);
+    dmabuf_predel_cb_unset(dh);
+    pool_recycle(pc, ent);
+    picpool_unref(&pc);
+    return 1;  // Do not delete
+}
+
+struct dmabuf_h * picpool_get(picpool_ctl_t * const pc, size_t req_size)
+{
+    pool_ent_t * best = NULL;
+
+    vlc_mutex_lock(&pc->lock);
+
+    {
+        pool_ent_t * ent = pc->ent_pool.ents;
+
+        // Simple scan
+        while (ent != NULL) {
+            if (ent->size >= req_size && ent->size <= req_size * 2 + POOL_ENT_ALLOC_BLOCK &&
+                    (best == NULL || best->size > ent->size))
+                best = ent;
+            ent = ent->next;
+        }
+
+        // extract best from chain if we've found it
+        ent_extract(&pc->ent_pool, best);
+    }
+
+    vlc_mutex_unlock(&pc->lock);
+
+    if (best == NULL) {
+        if ((best = pool_ent_alloc_new(pc, req_size)) == NULL)
+            return NULL;
+    }
+
+    if ((best->seq = ++pc->seq) == 0)
+        best->seq = ++pc->seq;  // Never allow to be zero
+
+    atomic_store(&best->ref_count, 1);
+    best->pc = picpool_ref(pc);
+    dmabuf_predel_cb_set(best->db, pool_predel_cb, best);
+//    fprintf(stderr, "%s: find ent %p db %p size %zd\n", __func__, best, best->db, best->size);
+    return best->db;
+}
+
+void picpool_flush(picpool_ctl_t * const pc)
+{
+    pool_recycle_list(pc, &pc->ents_prev);
+    pool_recycle_list(pc, &pc->ents_cur);
+}
+
+static void picpool_delete(picpool_ctl_t * const pc)
+{
+
+//    printf("<<< %s\n", __func__);
+
+    picpool_flush(pc);
+
+    ent_free_list(&pc->ent_pool);
+
+    dmabufs_ctl_unref(&pc->dbsc);
+
+    vlc_mutex_destroy(&pc->lock);
+
+//    memset(pc, 0xba, sizeof(*pc)); // Zap for (hopefully) faster crash
+    free (pc);
+
+    //    printf(">>> %s\n", __func__);
+}
+
+void picpool_unref(picpool_ctl_t ** const pppc)
+{
+    int n;
+    picpool_ctl_t * const pc = *pppc;
+
+    if (pc == NULL)
+        return;
+    *pppc = NULL;
+
+    n = atomic_fetch_sub(&pc->ref_count, 1) - 1;
+
+    if (n != 0)
+        return;
+
+    picpool_delete(pc);
+}
+
+picpool_ctl_t * picpool_ref(picpool_ctl_t * const pc)
+{
+    atomic_fetch_add(&pc->ref_count, 1);
+    return pc;
+}
+
+#if 0
+static MMAL_BOOL_T vcz_pool_release_cb(MMAL_POOL_T * buf_pool, MMAL_BUFFER_HEADER_T *buf, void *userdata)
+{
+    picpool_ctl_t * const pc = userdata;
+    vzc_subbuf_ent_t * const sb = buf->user_data;
+
+    VLC_UNUSED(buf_pool);
+
+//    printf("<<< %s\n", __func__);
+
+    if (sb != NULL) {
+        buf->user_data = NULL;
+        pool_recycle(pc, sb->ent);
+        picpool_release(pc);
+        free(sb);
+    }
+
+//    printf(">>> %s\n", __func__);
+
+    return MMAL_TRUE;
+}
+#endif
+
+picpool_ctl_t * picpool_new(struct dmabufs_ctl * dbsc)
+{
+    picpool_ctl_t * pc;
+
+    if (dbsc == NULL)
+        return NULL;
+
+    pc = calloc(1, sizeof(*pc));
+    if (pc == NULL)
+        return NULL;
+
+    pc->max_n = 8;
+    pc->dbsc = dmabufs_ctl_ref(dbsc);
+    atomic_store(&pc->ref_count, 1);
+    vlc_mutex_init(&pc->lock);
+
+    return pc;
+}
--- /dev/null
+++ b/modules/video_output/wayland/picpool.h
@@ -0,0 +1,24 @@
+#ifndef _WAYLAND_PICPOOL_H
+#define _WAYLAND_PICPOOL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct dmabuf_h;
+struct dmabufs_ctl;
+struct picpool_ctl_s;
+typedef struct picpool_ctl_s picpool_ctl_t;
+
+struct dmabuf_h * picpool_get(picpool_ctl_t * const pc, size_t req_size);
+
+void picpool_flush(picpool_ctl_t * const pc);
+void picpool_unref(picpool_ctl_t ** const pppc);
+picpool_ctl_t * picpool_ref(picpool_ctl_t * const pc);
+picpool_ctl_t * picpool_new(struct dmabufs_ctl * dbsc);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/modules/video_output/wayland/rgba_premul.c
@@ -0,0 +1,243 @@
+#include <stdint.h>
+
+#ifdef MAKE_TEST
+#define vlc_CPU_ARM64_NEON() (1)
+#define HAVE_AARCH64_ASM 1
+#else
+#include <vlc_common.h>
+#include <vlc_cpu.h>
+#endif
+
+#include "rgba_premul.h"
+
+#ifdef HAVE_AARCH64_ASM
+#include "rgba_premul_aarch64.h"
+#endif
+
+// x, y src offset, not dest
+// This won't be bit exact with aarch64 asm which has slightly different
+// rounding (this is faster when done in C)
+static void
+copy_xxxa_with_premul_c(void * restrict dst_data, int dst_stride,
+                      const void * restrict src_data, int src_stride,
+                      const unsigned int w, const unsigned int h,
+                      const unsigned int global_alpha)
+{
+    uint8_t * dst = (uint8_t*)dst_data;
+    const uint8_t * src = (uint8_t*)src_data;
+    const int src_inc = src_stride - (int)w * 4;
+    const int dst_inc = dst_stride - (int)w * 4;
+
+    for (unsigned int i = 0; i != h; ++i)
+    {
+        for (unsigned int j = 0; j != w; ++j, src+=4, dst += 4)
+        {
+            unsigned int a = src[3] * global_alpha * 258;
+            const unsigned int k = 0x800000;
+            dst[0] = (src[0] * a + k) >> 24;
+            dst[1] = (src[1] * a + k) >> 24;
+            dst[2] = (src[2] * a + k) >> 24;
+            dst[3] = (src[3] * global_alpha * 257 + 0x8000) >> 16;
+        }
+        src += src_inc;
+        dst += dst_inc;
+    }
+}
+
+void
+copy_xxxa_with_premul(void * dst_data, int dst_stride,
+                      const void * src_data, int src_stride,
+                      const unsigned int w, const unsigned int h,
+                      const unsigned int global_alpha)
+{
+#ifdef HAVE_AARCH64_ASM
+    if (vlc_CPU_ARM64_NEON())
+        copy_xxxa_with_premul_aarch64(dst_data, dst_stride, src_data, src_stride, w, h, global_alpha);
+    else
+#endif
+    copy_xxxa_with_premul_c(dst_data, dst_stride, src_data, src_stride, w, h, global_alpha);
+}
+
+// Has the optimization of copying as a single lump if strides are the same
+// and the width is fairly close to the stride
+// at the expense of possibly overwriting some bytes outside the active area
+// (but within the frame)
+void
+copy_frame_xxxa_with_premul(void * dst_data, int dst_stride,
+                      const void * src_data, int src_stride,
+                      const unsigned int w, const unsigned int h,
+                      const unsigned int global_alpha)
+{
+    if (dst_stride == src_stride && (dst_stride & 3) == 0 && (int)w * 4 <= dst_stride && (int)w * 4 + 64 >= dst_stride)
+        copy_xxxa_with_premul(dst_data, dst_stride, src_data, src_stride, h * dst_stride / 4, 1, global_alpha);
+    else
+        copy_xxxa_with_premul(dst_data, dst_stride, src_data, src_stride, w, h, global_alpha);
+}
+
+//============================================================================
+#ifdef MAKE_TEST
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+static bool verbose = false;
+static bool checkfail = false;
+
+static uint64_t
+utime(void)
+{
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    return ts.tv_nsec / 1000 + (uint64_t)ts.tv_sec * 1000000;
+}
+
+// What the ASM is meant to do exactly
+static void
+copy_xxxa_with_premul_c_asm(void * restrict dst_data, int dst_stride,
+                      const void * restrict src_data, int src_stride,
+                      const unsigned int w, const unsigned int h,
+                      const uint8_t global_alpha)
+{
+    uint8_t * dst = (uint8_t*)dst_data;
+    const uint8_t * src = (uint8_t*)src_data;
+    const int src_inc = src_stride - (int)w * 4;
+    const int dst_inc = dst_stride - (int)w * 4;
+
+    for (unsigned int i = 0; i != h; ++i)
+    {
+        for (unsigned int j = 0; j != w; ++j, src+=4, dst += 4)
+        {
+            // What the ASM is meant to do exactly
+            unsigned int a = global_alpha * 257;
+            const unsigned int k = 0x800000;
+            dst[0] = (((src[0] * src[3] * 257) >> 8) * a + k) >> 24;
+            dst[1] = (((src[1] * src[3] * 257) >> 8) * a + k) >> 24;
+            dst[2] = (((src[2] * src[3] * 257) >> 8) * a + k) >> 24;
+            dst[3] = (src[3] * global_alpha * 257 + 0x8000) >> 16;
+        }
+        src += src_inc;
+        dst += dst_inc;
+    }
+}
+
+#define ALIGN_SIZE 128
+#define ALIGN_PTR(p) ((uint8_t*)(((uintptr_t)p + (ALIGN_SIZE -1)) & ~(ALIGN_SIZE - 1)))
+
+static void
+timetest(const unsigned int w, const unsigned int h, const int stride, bool use_c)
+{
+    uint64_t now;
+    uint64_t done;
+    size_t dsize = h * stride + ALIGN_SIZE;
+
+    uint8_t * src = malloc(dsize);
+    uint8_t * dst = malloc(dsize);
+    uint8_t * s  = ALIGN_PTR(src);
+    uint8_t * d  = ALIGN_PTR(dst);
+
+    memset(src, 0x80, dsize);
+    memset(dst, 0xff, dsize);
+
+    now = utime();
+    for (unsigned int i = 0; i != 10; ++i)
+    {
+        if (use_c)
+            copy_xxxa_with_premul_c(d, stride, s, stride, w, h, 0xba);
+        else
+            copy_xxxa_with_premul(d, stride, s, stride, w, h, 0xba);
+    }
+    done = utime();
+
+    printf("Time %3s: %dx%d stride %d: %6dus\n", use_c ? "C" : "Asm", w, h, stride,
+           (int)((done - now)/10));
+
+    free(src);
+    free(dst);
+}
+
+static int
+docheck(const uint8_t * const a, const uint8_t * const b, const size_t n)
+{
+    int t = 0;
+
+    if (!verbose)
+        return memcmp(a, b, n);
+
+    for (size_t i = 0; i != n && t < 128; ++i)
+    {
+        if (a[i] != b[i])
+        {
+            printf("@ %zd: %02x %02x\n", i, a[i], b[i]);
+            ++t;
+        }
+    }
+    return t;
+}
+
+static void
+checktest(const unsigned int w, const unsigned int h, const int stride, const int offset)
+{
+    size_t dsize = ((h + 3) * stride + ALIGN_SIZE);
+
+    uint8_t * src = malloc(dsize);
+    uint8_t * dst = malloc(dsize);
+    uint8_t * dst2 = malloc(dsize);
+    uint8_t * s  = ALIGN_PTR(src + stride);
+    uint8_t * d  = ALIGN_PTR(dst + stride);
+    uint8_t * d2 = ALIGN_PTR(dst2 + stride);
+
+    for (unsigned int i = 0; i != dsize; ++i)
+        src[i] = rand();
+
+    memset(dst2, 0xff, dsize);
+    memset(dst,  0xff, dsize);
+
+    copy_xxxa_with_premul_c_asm(d + offset, stride, s, stride, w, h, 0xba);
+    copy_xxxa_with_premul(d2 + offset, stride, s, stride, w, h, 0xba);
+
+    if (docheck(d - stride, d2 - stride, (h + 2) * stride) != 0)
+    {
+        printf("Check: %dx%d stride %d offset %d: FAIL\n", w, h, stride, offset);
+        checkfail = true;
+    }
+    else if (verbose)
+    {
+        printf("Check: %dx%d stride %d offset %d: ok\n", w, h, stride, offset);
+    }
+
+    free(src);
+    free(dst);
+    free(dst2);
+}
+
+int
+main (int argc, char *argv[])
+{
+    if (argc >= 2 && strcmp(argv[1], "-v") == 0)
+        verbose = true;
+
+    timetest(1920, 1080, 1920 * 4, true);
+    timetest(1920, 1080, 1920 * 4, false);
+    timetest(1917, 1080, 1920 * 4, false);
+    timetest(1917, 1080, 1917 * 4, false);
+    timetest(1920 * 1080, 1, 1920 * 1080 * 4, false);
+
+    checktest(1920, 1080, 1920 * 4, 0);
+
+    // Stride of 65pel will rotate alignment vertically
+    for (unsigned int i = 1; i != 64; ++i)
+    {
+        checktest(i, 32, 65 * 4, 0);
+    }
+
+    if (!checkfail)
+    {
+        printf("All chacks passed\n");
+    }
+
+    return checkfail;
+}
+
+#endif
--- /dev/null
+++ b/modules/video_output/wayland/rgba_premul.h
@@ -0,0 +1,18 @@
+#ifndef _WAYLAND_RGBA_PREMUL_H
+#define _WAYLAND_RGBA_PREMUL_H
+
+void copy_xxxa_with_premul(void * dst_data, int dst_stride,
+                      const void * src_data, int src_stride,
+                      const unsigned int w, const unsigned int h,
+                      const unsigned int global_alpha);
+
+// Has the optimization of copying as a single lump if strides are the same
+// and the width is fairly close to the stride
+// at the expense of possibly overwriting some bytes outside the active area
+// (but within the frame)
+void copy_frame_xxxa_with_premul(void * dst_data, int dst_stride,
+                      const void * src_data, int src_stride,
+                      const unsigned int w, const unsigned int h,
+                      const unsigned int global_alpha);
+
+#endif
--- /dev/null
+++ b/modules/video_output/wayland/rgba_premul_aarch64.S
@@ -0,0 +1,170 @@
+#include "../../arm_neon/asm.S"
+
+// copy_xxxa_with_premul(
+//   void * dst_data,           // x0
+//   int dst_stride,            // w1
+//   const void * src_data,     // x2
+//   int src_stride,            // w3
+//   unsigned int w,            // w4
+//   unsigned int h,            // w5
+//   unsigned int global_alpha) // w6
+
+// rC   R, G or B In/Out
+// rA   A         In
+// sG   Global alpha *257 as h scalar (v7.h[1])  In
+// rT1  tmp
+// rT2  tmp
+//
+// vC = (vC * vA * 257/256 * sG + 0x800000) >> 24
+.macro  mul_rgb vC, vA, sG, vT1, vT2
+
+        umull           \vT2\().8h, \vC\().8b,  \vA\().8b
+        umull2          \vT1\().8h, \vC\().16b, \vA\().16b
+
+        usra            \vT2\().8h, \vT2\().8h, #8
+        usra            \vT1\().8h, \vT1\().8h, #8
+
+        umull           \vC\().4s,  \vT2\().4h, \sG
+        umull2          \vT2\().4s, \vT2\().8h, \sG
+	uzp2		\vC\().8h,  \vC\().8h,  \vT2\().8h
+
+        umull           \vT2\().4s, \vT1\().4h, \sG
+        umull2          \vT1\().4s, \vT1\().8h, \sG
+	uzp2		\vT2\().8h, \vT2\().8h, \vT1\().8h
+
+        uqrshrn         \vC\().8b,  \vC\().8h,  #8
+        uqrshrn2        \vC\().16b, \vT2\().8h, #8
+.endm
+
+// rA   A         In/Out
+// vG   Global alpha duped bytewise into vector  In
+// rT1  tmp
+//
+// vA = (vA * vG *257/256 + 0x80) >> 8
+.macro  mul_a vA, vG, vT1, vT2
+        umull           \vT1\().8h, \vA\().8b,  \vG\().8b           // Alpha
+        umull2          \vT2\().8h, \vA\().16b, \vG\().16b
+        usra            \vT1\().8h, \vT1\().8h, #8              // * 257/256
+        usra            \vT2\().8h, \vT2\().8h, #8
+        uqrshrn         \vA\().8b,  \vT1\().8h, #8
+        uqrshrn2        \vA\().16b, \vT2\().8h, #8
+.endm
+
+function copy_xxxa_with_premul_aarch64
+        mov             x15, lr         // Stash return addr
+        // Sanity check w & h
+        cbz             w4, 90f
+        cbz             w5, 90f
+
+        // Put alpha values somewhere we can use them
+        mov             w7, #257        // Would like 258 but 258*255 overflows h
+        mul             w7, w7, w6
+        dup             v6.16b,  w6
+        mov             v7.h[1], w7
+
+        // Calc EOL stride add
+        sub             w1, w1, w4, LSL #2
+        sub             w3, w3, w4, LSL #2
+
+        // Deal with very short stuff separately
+        // Saves annoying conditionals later
+        cmp             w4, #16
+        bge             22f
+
+        // Loop for w < 16
+        mov             w6, w4
+1:
+        bl              50f
+        add             x2, x2, w3, SXTW
+        add             x0, x0, w1, SXTW
+        subs            w5, w5, #1
+        bne             1b
+        b               90f
+
+        // Top of height loop
+20:
+        add             x2, x2, w3, SXTW
+        add             x0, x0, w1, SXTW
+        subs            w5, w5, #1
+        beq             90f
+
+22:
+        // Align destination before main loop
+        tst             x0, #63
+        mov             w6, w4
+        beq             1f
+
+        mov             w7, #16
+        ubfm            w6, w0, #2, #5
+        sub             w6, w7, w6
+        bl              50f
+        sub             w6, w4, w6
+1:
+        // If w % 16 != 0 then -16 so the main loop runs 1 fewer times with
+        // the remainder done in the tail
+        tst             w6, #15
+        bne             15f
+
+        // Top of width loop
+10:
+        ld4             {v0.16b, v1.16b, v2.16b, v3.16b}, [x2], #64
+
+        mul_rgb         v0, v3, v7.h[1], v16, v17
+        mul_rgb         v1, v3, v7.h[1], v16, v17
+        mul_rgb         v2, v3, v7.h[1], v16, v17
+        mul_a           v3, v6, v16, v17
+
+        st4             {v0.16b, v1.16b, v2.16b, v3.16b}, [x0], #64
+
+15:
+        subs            w6, w6, #16
+        bgt             10b
+        beq             20b             // No tail
+
+        // Tail
+        bl              50f
+        b               20b
+
+        // Return
+90:
+        mov             lr, x15
+        ret
+
+// Tail & Head core
+//
+// w6   Noof pixels to convert
+//      Only bottom 3 bits considered, left unchanged on exit
+50:
+        tbz             w6, #3, 1f
+        ld4             {v0.8b, v1.8b, v2.8b, v3.8b}, [x2], #32
+1:      tbz             w6, #2, 1f
+        ld4             {v0.b, v1.b, v2.b, v3.b}[8],  [x2], #4
+        ld4             {v0.b, v1.b, v2.b, v3.b}[9],  [x2], #4
+        ld4             {v0.b, v1.b, v2.b, v3.b}[10], [x2], #4
+        ld4             {v0.b, v1.b, v2.b, v3.b}[11], [x2], #4
+1:      tbz             w6, #1, 1f
+        ld4             {v0.b, v1.b, v2.b, v3.b}[12], [x2], #4
+        ld4             {v0.b, v1.b, v2.b, v3.b}[13], [x2], #4
+1:      tbz             w6, #0, 1f
+        ld4             {v0.b, v1.b, v2.b, v3.b}[14], [x2], #4
+1:
+
+        mul_rgb         v0, v3, v7.h[1], v16, v17
+        mul_rgb         v1, v3, v7.h[1], v16, v17
+        mul_rgb         v2, v3, v7.h[1], v16, v17
+        mul_a           v3, v6, v16, v17
+
+        tbz             w6, #3, 1f
+        st4             {v0.8b, v1.8b, v2.8b, v3.8b}, [x0], #32
+1:      tbz             w6, #2, 1f
+        st4             {v0.b, v1.b, v2.b, v3.b}[8],  [x0], #4
+        st4             {v0.b, v1.b, v2.b, v3.b}[9],  [x0], #4
+        st4             {v0.b, v1.b, v2.b, v3.b}[10], [x0], #4
+        st4             {v0.b, v1.b, v2.b, v3.b}[11], [x0], #4
+1:      tbz             w6, #1, 1f
+        st4             {v0.b, v1.b, v2.b, v3.b}[12], [x0], #4
+        st4             {v0.b, v1.b, v2.b, v3.b}[13], [x0], #4
+1:      tbz             w6, #0, 1f
+        st4             {v0.b, v1.b, v2.b, v3.b}[14], [x0], #4
+1:
+        ret
--- /dev/null
+++ b/modules/video_output/wayland/rgba_premul_aarch64.h
@@ -0,0 +1,9 @@
+#ifndef _WAYLAND_RGBA_PREMUL_AARCH64_H
+#define _WAYLAND_RGBA_PREMUL_AARCH64_H
+
+void copy_xxxa_with_premul_aarch64(void * dst_data, int dst_stride,
+                      const void * src_data, int src_stride,
+                      const unsigned int w, const unsigned int h,
+                      const unsigned int global_alpha);
+
+#endif
--- /dev/null
+++ b/modules/video_output/wayland/wl_dmabuf.c
@@ -0,0 +1,2885 @@
+/**
+ * @file shm.c
+ * @brief Wayland shared memory video output module for VLC media player
+ */
+/*****************************************************************************
+ * Copyright © 2014, 2017 Rémi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#ifndef HAVE_WAYLAND_SINGLE_PIXEL_BUFFER
+#define HAVE_WAYLAND_SINGLE_PIXEL_BUFFER 0
+#endif
+#ifndef HAVE_WAYLAND_COLOR_REPRESENTATION
+#define HAVE_WAYLAND_COLOR_REPRESENTATION 0
+#endif
+
+#include <assert.h>
+#include <stdatomic.h>
+#include <errno.h>
+#include <limits.h>
+#include <semaphore.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#include <wayland-client.h>
+#if HAVE_WAYLAND_SINGLE_PIXEL_BUFFER
+#include "single-pixel-buffer-v1-client-protocol.h"
+#endif
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+#include "color-representation-v1-client-protocol.h"
+#endif
+#include "viewporter-client-protocol.h"
+#include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "presentation-time-client-protocol.h"
+
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_vout_display.h>
+#include <vlc_picture_pool.h>
+#include <vlc_fs.h>
+
+// *** Avoid this include if possible
+#include <libdrm/drm_fourcc.h>
+
+#include "dmabuf_alloc.h"
+#include "picpool.h"
+#include "rgba_premul.h"
+#include "../drmu/drmu_log.h"
+#include "../drmu/drmu_vlc_fmts.h"
+#include "../drmu/pollqueue.h"
+#include "../../codec/avcodec/drm_pic.h"
+#include <libavutil/hwcontext_drm.h>
+
+#define TRACE_ALL 0
+#define CHECK_VDRE_COUNTS 0
+
+#define MAX_PICTURES 4
+#define MAX_SUBPICS  6
+
+#define WL_DMABUF_ENABLE_NAME "wl-dmabuf"
+#define WL_DMABUF_ENABLE_TEXT N_("Enable/Disable wl-dmabuf (default:enabled)")
+#define WL_DMABUF_ENABLE_LONGTEXT N_("Enable/Disable wl-dmabuf. Disable with --no-wl-dmabuf. Useful if auto selection is wanted but not wl-dmabuf")
+
+#define WL_DMABUF_USE_SHM_NAME "wl-dmabuf-use-shm"
+#define WL_DMABUF_USE_SHM_TEXT N_("Attempt to map via shm")
+#define WL_DMABUF_USE_SHM_LONGTEXT N_("Attempt to map via shm rather than linux_dmabuf")
+
+#define WL_DMABUF_CHEQUERBOARD_NAME "wl-dmabuf-chequerboard"
+#define WL_DMABUF_CHEQUERBOARD_TEXT N_("Chequerboard background")
+#define WL_DMABUF_CHEQUERBOARD_LONGTEXT N_("Fill unused window area with chequerboard rather than black")
+
+#define WL_DMABUF_STATS_NAME "wl-dmabuf-stats"
+#define WL_DMABUF_STATS_TEXT N_("Display some display stats")
+#define WL_DMABUF_STATS_LONGTEXT N_("When display is closed report frames displayed/discarded and avg fps. "\
+    "N.B. Unfortunately current implementation cannot track frames discarded by Wayland before display")
+
+typedef struct fmt_ent_s {
+    uint32_t fmt;
+    int32_t pri;
+    uint64_t mod;
+} fmt_ent_t;
+
+typedef struct fmt_list_s {
+    fmt_ent_t * fmts;
+    unsigned int size;
+    unsigned int len;
+} fmt_list_t;
+
+typedef struct eq_env_ss {
+    atomic_int eq_count;
+
+    struct wl_display *display;
+    struct pollqueue *pq;
+    struct wl_event_queue *q;
+    struct wl_display *wrapped_display;
+} eq_env_t;
+
+typedef struct video_dmabuf_release_env_ss
+{
+    void (* dma_rel_fn)(void *);
+    void * dma_rel_v;
+    eq_env_t * eq;
+    unsigned int rel_count;
+    unsigned int pt_count;
+    struct polltask * pt[AV_DRM_MAX_PLANES];
+#if CHECK_VDRE_COUNTS
+    atomic_int * vdre_check;
+#endif
+} video_dmabuf_release_env_t;
+
+typedef struct subpic_ent_s {
+    struct wl_buffer * wb;
+    struct dmabuf_h * dh;
+    video_dmabuf_release_env_t * vdre;
+    picture_t * pic;
+    int alpha;
+    enum wl_output_transform trans;
+    vout_display_place_t src_rect;
+    vout_display_place_t dst_rect;
+    vout_display_place_t orig_rect;
+
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+    // 0 invalid for all of these
+    enum wp_color_representation_surface_v1_chroma_location chroma_loc;
+    enum wp_color_representation_surface_v1_coefficients coefficients;
+    enum wp_color_representation_surface_v1_range range;
+    enum wp_color_representation_surface_v1_alpha_mode alpha_mode;
+#endif
+
+    atomic_int ready;
+
+    struct polltask * pt;
+    vout_display_t * vd;
+    vout_display_sys_t * sys;
+} subpic_ent_t;
+
+typedef struct subplane_s {
+    struct wl_surface * surface;
+    struct wl_subsurface * subsurface;
+    struct wp_viewport * viewport;
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+    struct wp_color_representation_surface_v1 * color_rep;
+#endif
+
+    bool buffer_attached;
+    bool commit_req;
+    int commit_parent;
+
+    enum wl_output_transform trans;
+    vout_display_place_t src_rect;
+    vout_display_place_t dst_rect;
+
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+    // 0 invalid for all of these
+    enum wp_color_representation_surface_v1_chroma_location chroma_loc;
+    enum wp_color_representation_surface_v1_coefficients coefficients;
+    enum wp_color_representation_surface_v1_range range;
+    enum wp_color_representation_surface_v1_alpha_mode alpha_mode;
+#endif
+
+    subpic_ent_t * spe_cur;
+    subpic_ent_t * spe_next;
+} subplane_t;
+
+typedef struct pres_stats_env_ss {
+    int ref_count;  // Protected by lock so not atomic
+    vlc_mutex_t lock;
+    vlc_cond_t cond;
+    eq_env_t * eq;
+
+    unsigned int w_display;
+    unsigned int w_discard;
+} pres_stats_env_t;
+
+typedef struct pres_cb_env_ss {
+    pres_stats_env_t * pse;
+    uint64_t pts;
+} pres_cb_env_t;
+
+typedef struct w_bound_ss
+{
+    struct wp_viewporter *viewporter;
+    struct zwp_linux_dmabuf_v1 * linux_dmabuf_v1;
+    struct wl_compositor *compositor;
+    struct wl_subcompositor *subcompositor;
+    struct wl_shm *shm;
+    struct wp_presentation *presentation;
+#if HAVE_WAYLAND_SINGLE_PIXEL_BUFFER
+    struct wp_single_pixel_buffer_manager_v1 *single_pixel_buffer_manager_v1;
+#endif
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+    struct wp_color_representation_manager_v1 *color_representation_manager_v1;
+#endif
+} w_bound_t;
+
+struct coeff_and_range
+{
+    unsigned int coeff;
+    bool full_range;
+};
+
+#define PLANE_BKG 0
+#define PLANE_VID 1
+#define PLANE_SUB 2
+
+struct vout_display_sys_t
+{
+    vout_window_t *embed; /* VLC window */
+
+    w_bound_t bound;
+
+    picture_pool_t *vlc_pic_pool; /* picture pool */
+
+    struct wl_surface * last_embed_surface;
+    unsigned int last_embed_seq;
+
+    int x;
+    int y;
+    bool use_shm;
+    bool chequerboard;
+    bool want_stats;
+    bool bkg_null;  // Bkg is known null - expect a lack of display (debug)
+
+    struct wp_viewport * bkg_viewport;
+    // Current size of background viewport if we have one
+    // If not created yet then the size that the viewport should be created
+    unsigned int bkg_w;
+    unsigned int bkg_h;
+
+    enum wl_output_transform video_trans;
+    vout_display_place_t video_src_rect;
+    vout_display_place_t video_dst_rect;
+
+#if CHECK_VDRE_COUNTS
+    atomic_int vdre_check_bkg;
+    atomic_int vdre_check_fg;
+#endif
+
+    eq_env_t * eq;
+
+    struct pollqueue * pollq;
+    struct pollqueue * speq;
+
+    picpool_ctl_t * subpic_pool;
+    subplane_t planes[MAX_SUBPICS + 2];
+    subpic_ent_t * video_spe_prep;
+    struct wl_callback * video_frame_callback;
+    vlc_fourcc_t * subpic_chromas;
+
+    struct wl_region * region_none;
+    struct wl_region * region_all;
+
+    fmt_list_t dmabuf_fmts;
+    fmt_list_t shm_fmts;
+
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+    bool has_straight_alpha;
+    struct {
+        enum wp_color_representation_surface_v1_coefficients coefficients;
+        unsigned int ranges; // b0 = full, b1 = restricted
+    }  primary_map[COLOR_PRIMARIES_MAX + 1];
+#endif
+
+    unsigned int presentation_clock_id;
+    pres_stats_env_t * pse;
+    struct display_stats_s {
+        unsigned int frame_n;
+        unsigned int frame_frame;
+        unsigned int frame_display;
+        unsigned int frame_discard;
+        unsigned int w_display;
+        unsigned int w_discard;
+        vlc_tick_t time_frame0;
+        vlc_tick_t time_frameN;
+    } stats;
+};
+
+
+static struct wl_surface * bkg_surface_get_lock(vout_display_t * const vd, vout_display_sys_t * const sys);
+static void bkg_surface_unlock(vout_display_t * const vd, vout_display_sys_t * const sys);
+
+static void
+msg_stats(vout_display_t * const vd, const struct display_stats_s * const s)
+{
+    unsigned int tframes = (s->frame_n + s->frame_discard);
+    unsigned int frx1000 = tframes < 2 ? 0 :
+            (unsigned int)((uint64_t)(tframes - 1) * 1000000000ULL / (s->time_frameN - s->time_frame0));
+    msg_Info(vd, "Frames: Total: %d, Discarded %d, Display %d: Presented %d, Dropped %d, FpS(total):%d.%03d",
+             tframes, s->frame_discard, s->frame_display,
+             s->w_display, s->w_discard,
+             frx1000 / 1000, frx1000 % 1000);
+}
+
+
+static inline struct wl_display *
+video_display(const vout_display_sys_t * const sys)
+{
+    return sys->embed->display.wl;
+}
+
+static inline struct wl_surface *
+video_surface(const vout_display_sys_t * const sys)
+{
+    return sys->planes[PLANE_VID].surface;
+}
+
+static inline struct wl_compositor *
+video_compositor(const vout_display_sys_t * const sys)
+{
+    return sys->bound.compositor;
+}
+
+static void
+buffer_destroy(struct wl_buffer ** ppbuffer)
+{
+    struct wl_buffer * const buffer = *ppbuffer;
+    if (buffer == NULL)
+        return;
+    *ppbuffer = NULL;
+    wl_buffer_destroy(buffer);
+}
+
+static void
+region_destroy(struct wl_region ** const ppregion)
+{
+    if (*ppregion == NULL)
+        return;
+    wl_region_destroy(*ppregion);
+    *ppregion = NULL;
+}
+
+static void
+subsurface_destroy(struct wl_subsurface ** const ppsubsurface)
+{
+    if (*ppsubsurface == NULL)
+        return;
+    wl_subsurface_destroy(*ppsubsurface);
+    *ppsubsurface = NULL;
+}
+
+static void
+surface_destroy(struct wl_surface ** const ppsurface)
+{
+    if (*ppsurface == NULL)
+        return;
+    wl_surface_destroy(*ppsurface);
+    *ppsurface = NULL;
+}
+
+static void
+viewport_destroy(struct wp_viewport ** const ppviewport)
+{
+    if (*ppviewport == NULL)
+        return;
+    wp_viewport_destroy(*ppviewport);
+    *ppviewport = NULL;
+}
+
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+static void
+color_representation_destroy(struct wp_color_representation_surface_v1 ** const ppcolor_rep)
+{
+    if (*ppcolor_rep == NULL)
+        return;
+    wp_color_representation_surface_v1_destroy(*ppcolor_rep);
+    *ppcolor_rep = NULL;
+}
+#endif
+
+static inline int
+scale_dst(const vout_display_sys_t * const sys, int x)
+{
+    if (sys->embed->scale_den == sys->embed->scale_num)
+        return x;
+    return (x * sys->embed->scale_den) / sys->embed->scale_num;
+}
+
+static inline int_fast32_t
+place_rescale_1s(int_fast32_t x, uint_fast32_t mul, uint_fast32_t div)
+{
+    const int_fast64_t m = x * (int_fast64_t)mul;
+    const uint_fast32_t d2 = div/2;
+    return div == 0 ? (int_fast32_t)m :
+        m >= 0 ? (int_fast32_t)(((uint_fast64_t)m + d2) / div) :
+            -(int_fast32_t)(((uint_fast64_t)(-m) + d2) / div);
+}
+
+static inline uint_fast32_t
+place_rescale_1u(uint_fast32_t x, uint_fast32_t mul, uint_fast32_t div)
+{
+    const uint_fast64_t m = x * (uint_fast64_t)mul;
+    return (uint_fast32_t)(div == 0 ? m : (m + div/2) / div);
+}
+
+static inline vout_display_place_t
+place_rescale(const vout_display_place_t s, const vout_display_place_t mul, const vout_display_place_t div)
+{
+    return (vout_display_place_t){
+        .x      = place_rescale_1s(s.x - div.x, mul.width,  div.width)  + mul.x,
+        .y      = place_rescale_1s(s.y - div.y, mul.height, div.height) + mul.y,
+        .width  = place_rescale_1u(s.width,     mul.width,  div.width),
+        .height = place_rescale_1u(s.height,    mul.height, div.height)
+    };
+}
+
+static inline vout_display_place_t
+place_zoffset(const vout_display_place_t s)
+{
+    return (vout_display_place_t){
+        .x      = 0,
+        .y      = 0,
+        .width  = s.width,
+        .height = s.height
+    };
+}
+
+static inline bool
+place_xy_eq(const vout_display_place_t a, const vout_display_place_t b)
+{
+    return a.x == b.x && a.y == b.y;
+}
+
+static inline bool
+place_wh_eq(const vout_display_place_t a, const vout_display_place_t b)
+{
+    return a.width == b.width && a.height == b.height;
+}
+
+static inline bool
+place_eq(const vout_display_place_t a, const vout_display_place_t b)
+{
+    return place_xy_eq(a, b) && place_wh_eq(a, b);
+}
+
+
+// MMAL headers comment these (getting 2 a bit wrong) but do not give
+// defines
+#define VXF_H_SHIFT 0  // Hflip
+#define VXF_V_SHIFT 1  // Vflip
+#define VXF_T_SHIFT 2  // Transpose
+#define VXF_H_BIT   (1 << VXF_H_SHIFT)
+#define VXF_V_BIT   (1 << VXF_V_SHIFT)
+#define VXF_T_BIT   (1 << VXF_T_SHIFT)
+
+static inline bool
+is_vxf_transpose(const video_transform_t t)
+{
+    return ((unsigned int)t & VXF_T_BIT) != 0;
+}
+
+static inline bool
+is_vxf_hflip(const video_transform_t t)
+{
+    return ((unsigned int)t & VXF_H_BIT) != 0;
+}
+
+static inline bool
+is_vxf_vflip(const video_transform_t t)
+{
+    return ((unsigned int)t & VXF_V_BIT) != 0;
+}
+
+static inline video_transform_t
+swap_vxf_hv(const video_transform_t x)
+{
+    return (((x >> VXF_H_SHIFT) & 1) << VXF_V_SHIFT) |
+           (((x >> VXF_V_SHIFT) & 1) << VXF_H_SHIFT) |
+           (x & VXF_T_BIT);
+}
+
+static inline video_transform_t
+vxf_inverse(const video_transform_t x)
+{
+    return is_vxf_transpose(x) ? swap_vxf_hv(x) : x;
+}
+
+// Transform generated by A then B
+// All ops are self inverse so can simply be XORed on their own
+// H & V flips after a transpose need to be swapped
+static inline video_transform_t
+combine_vxf(const video_transform_t a, const video_transform_t b)
+{
+    return a ^ (is_vxf_transpose(a) ? swap_vxf_hv(b) : b);
+}
+
+static inline vout_display_place_t
+vplace_transpose(const vout_display_place_t s)
+{
+    return (vout_display_place_t){
+        .x      = s.y,
+        .y      = s.x,
+        .width  = s.height,
+        .height = s.width
+    };
+}
+
+// hflip s in c
+static inline vout_display_place_t vplace_hflip(const vout_display_place_t s, const vout_display_place_t c)
+{
+    return (vout_display_place_t){
+        .x = c.x + (c.x + c.width) - (s.x + s.width),
+        .y = s.y,
+        .width = s.width,
+        .height = s.height
+    };
+}
+
+// vflip s in c
+static inline vout_display_place_t vplace_vflip(const vout_display_place_t s, const vout_display_place_t c)
+{
+    return (vout_display_place_t){
+        .x = s.x,
+        .y = (c.y + c.height) - (s.y - c.y) - s.height,
+        .width = s.width,
+        .height = s.height
+    };
+}
+
+static int
+fmt_list_add(fmt_list_t * const fl, uint32_t fmt, uint64_t mod, int32_t pri)
+{
+    if (fl->len >= fl->size)
+    {
+        unsigned int n = fl->len == 0 ? 64 : fl->len * 2;
+        fmt_ent_t * t = realloc(fl->fmts, n * sizeof(*t));
+        if (t == NULL)
+            return VLC_ENOMEM;
+        fl->fmts = t;
+        fl->size = n;
+    }
+    fl->fmts[fl->len++] = (fmt_ent_t){
+        .fmt = fmt,
+        .pri = pri,
+        .mod = mod
+    };
+    return 0;
+}
+
+static int
+fmt_sort_cb(const void * va, const void * vb)
+{
+    const fmt_ent_t * const a = va;
+    const fmt_ent_t * const b = vb;
+    return a->fmt < b->fmt ? -1 : a->fmt != b->fmt ? 1 :
+           a->mod < b->mod ? -1 : a->mod != b->mod ? 1 : 0;
+}
+
+static void
+fmt_list_sort(fmt_list_t * const fl)
+{
+    unsigned int n = 0;
+    if (fl->len <= 1)
+        return;
+    qsort(fl->fmts, fl->len, sizeof(*fl->fmts), fmt_sort_cb);
+    // Dedup - in case we have multiple working callbacks
+    for (unsigned int i = 1; i != fl->len; ++i)
+    {
+        if (fl->fmts[i].fmt != fl->fmts[n].fmt || fl->fmts[i].mod != fl->fmts[n].mod)
+            fl->fmts[n++] = fl->fmts[i];
+    }
+    fl->len = n + 1;
+}
+
+static int
+fmt_list_find(const fmt_list_t * const fl, const drmu_vlc_fmt_info_t * const fmti)
+{
+    if (fmti == NULL || fl->len == 0)
+    {
+        return -1;
+    }
+    else
+    {
+        const fmt_ent_t x = {
+            .fmt = drmu_vlc_fmt_info_drm_pixelformat(fmti),
+            .mod = drmu_vlc_fmt_info_drm_modifier(fmti),
+        };
+        const fmt_ent_t * const fe =
+            bsearch(&x, fl->fmts, fl->len, sizeof(x), fmt_sort_cb);
+        return fe == NULL ? -1 : fe->pri;
+    }
+}
+
+static void
+fmt_list_uninit(fmt_list_t * const fl)
+{
+    free(fl->fmts);
+    fl->fmts = NULL;
+    fl->size = 0;
+    fl->len = 0;
+}
+
+static int
+fmt_list_init(fmt_list_t * const fl, const size_t initial_size)
+{
+    fl->size = 0;
+    fl->len = 0;
+    if ((fl->fmts = malloc(initial_size * sizeof(*fl->fmts))) == NULL)
+        return VLC_ENOMEM;
+    fl->size = initial_size;
+    return VLC_SUCCESS;
+}
+
+// ----------------------------------------------------------------------------
+
+static struct wl_display *
+eq_wrapper(eq_env_t * const eq)
+{
+    return eq->wrapped_display;
+}
+
+static eq_env_t *
+eq_ref(eq_env_t * const eq)
+{
+    const int n = atomic_fetch_add(&eq->eq_count, 1);
+    (void)n;
+//    fprintf(stderr, "Ref: count=%d\n", n + 1);
+    return eq;
+}
+
+static void
+eq_unref(eq_env_t ** const ppeq)
+{
+    eq_env_t * eq = *ppeq;
+    if (eq != NULL)
+    {
+        int n;
+        *ppeq = NULL;
+        n = atomic_fetch_sub(&eq->eq_count, 1);
+        if (n == 0)
+        {
+            pollqueue_set_pre_post(eq->pq, 0, 0, NULL);
+            pollqueue_unref(&eq->pq);
+
+            wl_proxy_wrapper_destroy(eq->wrapped_display);
+            wl_event_queue_destroy(eq->q);
+
+            free(eq);
+        }
+    }
+}
+
+static void
+pollq_pre_cb(void * v, struct pollfd * pfd)
+{
+    eq_env_t * const eq = v;
+    struct wl_display *const display = eq->display;
+    int ferr;
+    int frv;
+
+//    fprintf(stderr, "Start Prepare\n");
+
+    while (wl_display_prepare_read_queue(display, eq->q) != 0) {
+        int n = wl_display_dispatch_queue_pending(display, eq->q);
+        (void)n;
+//        fprintf(stderr, "Dispatch=%d\n", n);
+    }
+    if ((frv = wl_display_flush(display)) >= 0) {
+        pfd->events = POLLIN;
+        ferr = 0;
+    }
+    else {
+        ferr = errno;
+        pfd->events = POLLOUT | POLLIN;
+    }
+    pfd->fd = wl_display_get_fd(display);
+(void)ferr;
+//    fprintf(stderr, "Done Prepare: fd=%d, evts=%#x, frv=%d, ferr=%s\n", pfd->fd, pfd->events, frv, ferr == 0 ? "ok" : strerror(ferr));
+}
+
+static void
+pollq_post_cb(void *v, short revents)
+{
+    eq_env_t * const eq = v;
+    struct wl_display *const display = eq->display;
+    int n;
+
+    if ((revents & POLLIN) == 0) {
+//        fprintf(stderr, "Cancel read: Events=%#x: IN=%#x, OUT=%#x, ERR=%#x\n", (int)revents, POLLIN, POLLOUT, POLLERR);
+        wl_display_cancel_read(display);
+    }
+    else {
+//        fprintf(stderr, "Read events: Events=%#x: IN=%#x, OUT=%#x, ERR=%#x\n", (int)revents, POLLIN, POLLOUT, POLLERR);
+        wl_display_read_events(display);
+    }
+
+//    fprintf(stderr, "Start Dispatch\n");
+    n = wl_display_dispatch_queue_pending(display, eq->q);
+    (void)n;
+//    fprintf(stderr, "Dispatch=%d\n", n);
+}
+
+static eq_env_t *
+eq_new(struct wl_display * const display, struct pollqueue * const pq)
+{
+    eq_env_t * eq = calloc(1, sizeof(*eq));
+
+    if (eq == NULL)
+        return NULL;
+
+    atomic_init(&eq->eq_count, 0);
+
+#if WAYLAND_VERSION_MAJOR > 1 ||\
+    (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR >= 23)
+    if ((eq->q = wl_display_create_queue_with_name(display, "vlc-wl-dmabuf")) == NULL)
+        goto err1;
+#else
+    if ((eq->q = wl_display_create_queue(display)) == NULL)
+        goto err1;
+#endif
+    if ((eq->wrapped_display = wl_proxy_create_wrapper(display)) == NULL)
+        goto err2;
+    wl_proxy_set_queue((struct wl_proxy *)eq->wrapped_display, eq->q);
+
+    eq->display = display;
+    eq->pq = pollqueue_ref(pq);
+
+    pollqueue_set_pre_post(eq->pq, pollq_pre_cb, pollq_post_cb, eq);
+
+    return eq;
+
+err2:
+    wl_event_queue_destroy(eq->q);
+err1:
+    free(eq);
+    return NULL;
+}
+
+static void eventq_sync_cb(void * data, struct wl_callback * cb, unsigned int cb_data)
+{
+    sem_t * const sem = data;
+    VLC_UNUSED(cb_data);
+    wl_callback_destroy(cb);
+    sem_post(sem);
+}
+
+static const struct wl_callback_listener eq_sync_listener = {.done = eventq_sync_cb};
+
+struct eq_sync_env_ss {
+    eq_env_t * eq;
+    sem_t sem;
+};
+
+static void
+eq_sync_pq_cb(void * v, short revents)
+{
+    struct eq_sync_env_ss * const eqs = v;
+    struct wl_callback * const cb = wl_display_sync(eq_wrapper(eqs->eq));
+    VLC_UNUSED(revents);
+    wl_callback_add_listener(cb, &eq_sync_listener, &eqs->sem);
+    // No flush needed as that will occur as part of the pollqueue loop
+}
+
+static int
+eventq_sync(eq_env_t * const eq)
+{
+    struct eq_sync_env_ss eqs = {.eq = eq};
+    int rv;
+
+    if (!eq)
+        return -1;
+
+    sem_init(&eqs.sem, 0, 0);
+    // Bounce execution to pollqueue to avoid race setting up listener
+    pollqueue_callback_once(eq->pq, eq_sync_pq_cb, &eqs);
+    while ((rv = sem_wait(&eqs.sem)) == -1 && errno == EINTR)
+        /* Loop */;
+    sem_destroy(&eqs.sem);
+    return rv;
+}
+
+// ----------------------------------------------------------------------------
+
+static void
+pres_stats_free(pres_stats_env_t * const pse)
+{
+    eq_unref(&pse->eq);
+    vlc_cond_destroy(&pse->cond);
+    vlc_mutex_destroy(&pse->lock);
+    free(pse);
+}
+
+static void
+pres_stats_unref(pres_stats_env_t ** const pppse)
+{
+    pres_stats_env_t * const pse = *pppse;
+    int n;
+    if (pse == NULL)
+        return;
+    *pppse = NULL;
+
+    vlc_mutex_lock(&pse->lock);
+    n = --pse->ref_count;
+    if (n == 0)
+        vlc_cond_broadcast(&pse->cond);
+    vlc_mutex_unlock(&pse->lock);
+
+    if (n >= 0)
+        return;
+
+    pres_stats_free(pse);
+}
+
+static pres_stats_env_t *
+pres_stats_ref(pres_stats_env_t * const pse)
+{
+    if (pse == NULL)
+        return NULL;
+
+    vlc_mutex_lock(&pse->lock);
+    ++pse->ref_count;
+    vlc_mutex_unlock(&pse->lock);
+    return pse;
+}
+
+// Wait for all other refs to pse to go away before freeing and returning
+static int
+pres_stats_finish(pres_stats_env_t ** const pppse, struct display_stats_s * const dstats)
+{
+    pres_stats_env_t * const pse = *pppse;
+    int rv = 0;
+    if (pse == NULL)
+        return 0;
+    *pppse = NULL;
+
+    vlc_mutex_lock(&pse->lock);
+    while (pse->ref_count != 0)
+        vlc_cond_wait(&pse->cond, &pse->lock);
+    vlc_mutex_unlock(&pse->lock);
+
+    if (dstats != NULL)
+    {
+        dstats->w_display += pse->w_display;
+        dstats->w_discard += pse->w_discard;
+    }
+    pres_stats_free(pse);
+    return rv;
+}
+
+static pres_stats_env_t *
+pres_stats_new(eq_env_t * const eq)
+{
+    pres_stats_env_t * const pse = calloc(1, sizeof(*pse));
+    if (pse == NULL)
+        return NULL;
+    vlc_mutex_init(&pse->lock);
+    vlc_cond_init(&pse->cond);
+    pse->eq = eq_ref(eq);
+    return pse;
+}
+
+// ----------------------------------------------------------------------------
+
+static void
+chequerboard(uint32_t *const data, unsigned int stride, const unsigned int width, const unsigned int height)
+{
+    stride /= sizeof(uint32_t);
+
+    /* Draw checkerboxed background */
+    for (unsigned int y = 0; y < height; ++y) {
+        for (unsigned int x = 0; x < width; ++x) {
+            if ((x + y / 8 * 8) % 16 < 8)
+                data[y * stride + x] = 0xFF666666;
+            else
+                data[y * stride + x] = 0xFFEEEEEE;
+        }
+    }
+}
+
+static void
+fill_uniform(uint32_t *const data, unsigned int stride, const unsigned int width, const unsigned int height, const uint32_t val)
+{
+    stride /= sizeof(uint32_t);
+
+    /* Draw solid background */
+    for (unsigned int y = 0; y < height; ++y) {
+        for (unsigned int x = 0; x < width; ++x)
+            data[y * stride + x] = val;
+    }
+}
+
+// ----------------------------------------------------------------------------
+
+static void
+vdre_free(video_dmabuf_release_env_t * const vdre)
+{
+    unsigned int i;
+    if (vdre->dma_rel_fn)
+        vdre->dma_rel_fn(vdre->dma_rel_v);
+    for (i = 0; i != vdre->pt_count; ++i)
+        polltask_delete(vdre->pt + i);
+    eq_unref(&vdre->eq);
+#if CHECK_VDRE_COUNTS
+    if (vdre->vdre_check != NULL)
+        atomic_fetch_sub(vdre->vdre_check, 1);
+#endif
+    free(vdre);
+}
+
+static video_dmabuf_release_env_t *
+vdre_new_null(void)
+{
+    video_dmabuf_release_env_t * const vdre = calloc(1, sizeof(*vdre));
+    return vdre;
+}
+
+static void
+vdre_dma_rel_cb(void * v)
+{
+    struct picture_context_t * ctx = v;
+    ctx->destroy(ctx);
+}
+
+static video_dmabuf_release_env_t *
+vdre_new_ctx(struct picture_context_t * ctx)
+{
+    video_dmabuf_release_env_t * const vdre = vdre_new_null();
+    if (vdre == NULL)
+        return NULL;
+    if ((vdre->dma_rel_v = ctx->copy(ctx)) == NULL)
+    {
+        free(vdre);
+        return NULL;
+    }
+    vdre->dma_rel_fn = vdre_dma_rel_cb;
+    return vdre;
+}
+
+static void
+vdre_delete(video_dmabuf_release_env_t ** const ppvdre)
+{
+    video_dmabuf_release_env_t * const vdre = *ppvdre;
+    if (vdre == NULL)
+        return;
+    *ppvdre = NULL;
+    vdre_free(vdre);
+}
+
+static void
+vdre_polltask_cb(void * v, short revents)
+{
+    video_dmabuf_release_env_t * const vdre = v;
+    VLC_UNUSED(revents);
+    // Wait for all callbacks to come back before releasing buffer
+    if (++vdre->rel_count >= vdre->pt_count)
+        vdre_free(vdre);
+}
+
+static void
+vdre_eq_ref(video_dmabuf_release_env_t * const vdre, eq_env_t * const eq)
+{
+    if (vdre == NULL)
+        return;
+    vdre->eq = eq_ref(eq);
+}
+
+#if CHECK_VDRE_COUNTS
+static void
+vdre_add_check(video_dmabuf_release_env_t * const vdre, atomic_int * const pa)
+{
+    vdre->vdre_check = pa;
+    atomic_fetch_add(pa, 1);
+}
+#endif
+
+static void
+vdre_add_pt(video_dmabuf_release_env_t * const vdre, struct pollqueue * pq, int fd)
+{
+    assert(vdre->pt_count < AV_DRM_MAX_PLANES);
+    vdre->pt[vdre->pt_count++] = polltask_new(pq, fd, POLLOUT, vdre_polltask_cb, vdre);
+}
+
+static void
+vdre_dh_rel_cb(void * v)
+{
+    struct dmabuf_h * dh = v;
+    dmabuf_unref(&dh);
+}
+
+static video_dmabuf_release_env_t *
+vdre_new_dh(struct dmabuf_h *const dh, struct pollqueue *const pq)
+{
+    video_dmabuf_release_env_t * const vdre = vdre_new_null();
+
+    vdre->dma_rel_fn = vdre_dh_rel_cb;
+    vdre->dma_rel_v = dh;
+
+    if (!dmabuf_is_fake(dh))
+        vdre_add_pt(vdre, pq, dmabuf_fd(dh));
+    return vdre;
+}
+
+// Avoid use of vd here as there's a possibility this will be called after
+// it has gone
+static void
+vdre_buffer_release_cb(void *data, struct wl_buffer *wl_buffer)
+{
+    video_dmabuf_release_env_t * const vdre = data;
+    unsigned int i = vdre->pt_count;
+
+    /* Sent by the compositor when it's no longer using this buffer */
+    buffer_destroy(&wl_buffer);
+
+    eq_unref(&vdre->eq);
+
+    if (i == 0)
+        vdre_free(vdre);
+    else
+    {
+        // Whilst we can happily destroy the buffer that doesn't mean we can reuse
+        // the dmabufs yet - we have to wait for them to be free of fences.
+        // We don't want to wait in this callback so do the waiting in pollqueue
+        while (i-- != 0)
+            pollqueue_add_task(vdre->pt[i], 1000);
+    }
+}
+
+static const struct wl_buffer_listener vdre_buffer_listener = {
+    .release = vdre_buffer_release_cb,
+};
+
+// ----------------------------------------------------------------------------
+
+static inline size_t cpypic_plane_alloc_size(const plane_t * const p)
+{
+    return p->i_pitch * p->i_lines;
+}
+
+static inline uint32_t
+drm_fmt_to_wl_shm(const uint32_t drm_fmt)
+{
+    return (drm_fmt == DRM_FORMAT_ARGB8888) ? WL_SHM_FORMAT_ARGB8888 :
+           (drm_fmt == DRM_FORMAT_XRGB8888) ? WL_SHM_FORMAT_XRGB8888 : drm_fmt;
+}
+
+static struct wl_buffer *
+dfd_make_buffer(vout_display_t * const vd, vout_display_sys_t * const sys,
+                const bool use_shm,
+                const AVDRMFrameDescriptor * const desc,
+                const unsigned int width, const unsigned int height,
+                const uint32_t flags)
+{
+    struct wl_buffer * w_buffer;
+
+    if (!sys->bound.linux_dmabuf_v1 || use_shm)
+    {
+        const AVDRMPlaneDescriptor *const p = desc->layers[0].planes + 0;
+        struct wl_shm_pool *pool = wl_shm_create_pool(sys->bound.shm, desc->objects[0].fd, desc->objects[0].size);
+        const uint32_t w_fmt = drm_fmt_to_wl_shm(desc->layers[0].format);
+
+        if (pool == NULL)
+        {
+            msg_Err(vd, "Failed to create pool from dmabuf");
+            return NULL;
+        }
+        w_buffer = wl_shm_pool_create_buffer(pool, p->offset, width, height, p->pitch, w_fmt);
+        wl_shm_pool_destroy(pool);
+        if (w_buffer == NULL)
+            msg_Err(vd, "Failed to create buffer from pool");
+    }
+    else
+    {
+        /* Creation and configuration of planes  */
+        int i;
+        unsigned int n = 0;
+        struct zwp_linux_buffer_params_v1 * const params = zwp_linux_dmabuf_v1_create_params(sys->bound.linux_dmabuf_v1);
+
+        if (!params)
+        {
+            msg_Err(vd, "zwp_linux_dmabuf_v1_create_params FAILED");
+            return NULL;
+        }
+
+        for (i = 0; i < desc->nb_layers; ++i)
+        {
+            int j;
+            for (j = 0; j < desc->layers[i].nb_planes; ++j)
+            {
+                const AVDRMPlaneDescriptor *const p = desc->layers[i].planes + j;
+                const AVDRMObjectDescriptor *const obj = desc->objects + p->object_index;
+
+                zwp_linux_buffer_params_v1_add(params, obj->fd, n++, p->offset, p->pitch,
+                                   (unsigned int)(obj->format_modifier >> 32),
+                                   (unsigned int)(obj->format_modifier & 0xFFFFFFFF));
+            }
+        }
+
+        /* Request buffer creation */
+        if ((w_buffer = zwp_linux_buffer_params_v1_create_immed(params, width, height, desc->layers[0].format, flags)) == NULL)
+            msg_Err(vd, "zwp_linux_buffer_params_v1_create_immed FAILED");
+        zwp_linux_buffer_params_v1_destroy(params);
+    }
+    return w_buffer;
+}
+
+static int
+copy_subpic_to_w_buffer(vout_display_t *vd, vout_display_sys_t * const sys, picture_t * const src,
+                        int alpha,
+                        video_dmabuf_release_env_t ** pVdre, struct wl_buffer ** pW_buffer)
+{
+    unsigned int w = src->format.i_width;
+    unsigned int h = src->format.i_height;
+    uint64_t mod;
+    const uint32_t drm_fmt = drmu_format_vlc_to_drm(&src->format, &mod);
+    struct dmabuf_h * dh = NULL;
+    int i;
+    AVDRMFrameDescriptor dfd = {
+        .nb_objects = 1,
+        .objects = {{
+            .fd = -1,
+            .size = 0,
+            .format_modifier = mod
+        }},
+        .nb_layers = 1,
+        .layers = {{
+            .format = drm_fmt,
+            .nb_planes = src->i_planes,
+        }}
+    };
+
+    for (i = 0; i != src->i_planes; ++i)
+    {
+        dfd.layers[0].planes[i].object_index = 0;
+        dfd.layers[0].planes[i].offset = dfd.objects[0].size;
+        dfd.layers[0].planes[i].pitch = src->p[i].i_pitch;
+        dfd.objects[0].size += cpypic_plane_alloc_size(src->p + i);
+    }
+
+    *pW_buffer = NULL;
+    *pVdre = NULL;
+
+    if ((dh = picpool_get(sys->subpic_pool, dfd.objects[0].size)) == NULL)
+    {
+        msg_Warn(vd, "Failed to alloc dmabuf for subpic");
+        goto error;
+    }
+    dfd.objects[0].fd = dmabuf_fd(dh);
+
+    if ((*pVdre = vdre_new_dh(dh, sys->pollq)) == NULL)
+    {
+        msg_Warn(vd, "Failed to alloc vdre for subpic");
+        dmabuf_unref(&dh);
+        goto error;
+    }
+
+    // Copy to dh
+    dmabuf_write_start(dh);
+    for (i = 0; i != dfd.layers[0].nb_planes; ++i)
+    {
+        const size_t stride = dfd.layers[0].planes[i].pitch;
+        const size_t offset = dfd.layers[0].planes[i].offset;
+        void * const dst_data = (char *)dmabuf_map(dh) + offset;
+
+        if (src->format.i_chroma == VLC_CODEC_RGBA ||
+            src->format.i_chroma == VLC_CODEC_BGRA)
+            copy_frame_xxxa_with_premul(dst_data, stride, src->p[i].p_pixels, stride, w, h, alpha);
+        else
+            memcpy(dst_data, src->p[i].p_pixels, cpypic_plane_alloc_size(src->p + i));
+    }
+    dmabuf_write_end(dh);
+
+    *pW_buffer = dfd_make_buffer(vd, sys, dmabuf_is_fake(dh), &dfd, w, h, 0);
+    if (*pW_buffer == NULL)
+        goto error;
+
+#if CHECK_VDRE_COUNTS
+    vdre_add_check(*pVdre, &sys->vdre_check_fg);
+#endif
+
+    return VLC_SUCCESS;
+
+error:
+    vdre_delete(pVdre);
+    return VLC_EGENERIC;
+}
+
+static void kill_pool(vout_display_sys_t * const sys)
+{
+    if (sys->vlc_pic_pool != NULL)
+    {
+        picture_pool_Release(sys->vlc_pic_pool);
+        sys->vlc_pic_pool = NULL;
+    }
+}
+
+// Actual picture pool for dmabufs is just a set of trivial containers
+static picture_pool_t *vd_dmabuf_pool(vout_display_t * const vd, unsigned count)
+{
+    vout_display_sys_t * const sys = vd->sys;
+
+    msg_Dbg(vd, "%s: fmt:%dx%d,sar:%d/%d; source:%dx%d, count=%u", __func__,
+            vd->fmt.i_width, vd->fmt.i_height, vd->fmt.i_sar_num, vd->fmt.i_sar_den,
+            vd->source.i_width, vd->source.i_height, count);
+
+    if (sys->vlc_pic_pool == NULL)
+        sys->vlc_pic_pool = picture_pool_NewFromFormat(&vd->fmt, count);
+    return sys->vlc_pic_pool;
+}
+
+static int
+do_display_dmabuf(vout_display_t * const vd, vout_display_sys_t * const sys, picture_t * const pic,
+                  video_dmabuf_release_env_t ** const pVdre, struct wl_buffer ** const pWbuffer)
+{
+    const AVDRMFrameDescriptor * const desc = drm_prime_get_desc(pic);
+    const unsigned int width = pic->format.i_width;
+    const unsigned int height = pic->format.i_height;
+    unsigned int flags = 0;
+    int i;
+    video_dmabuf_release_env_t * const vdre = vdre_new_ctx(pic->context);
+
+    assert(*pWbuffer == NULL);
+    assert(*pVdre == NULL);
+
+    if (vdre == NULL) {
+        msg_Err(vd, "Failed to create vdre");
+        return VLC_ENOMEM;
+    }
+
+    for (i = 0; i != desc->nb_objects; ++i)
+        vdre_add_pt(vdre, sys->pollq, desc->objects[i].fd);
+
+    if (!pic->b_progressive)
+    {
+        flags |= ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_INTERLACED;
+        if (!pic->b_top_field_first)
+            flags |= ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_BOTTOM_FIRST;
+    }
+
+    *pWbuffer = dfd_make_buffer(vd, sys, false, desc, width, height, flags);
+    if (*pWbuffer == NULL)
+        goto error;
+
+    *pVdre = vdre;
+    return VLC_SUCCESS;
+
+error:
+    vdre_free(vdre);
+    return VLC_EGENERIC;
+}
+
+static void
+subpic_ent_flush(subpic_ent_t * const spe)
+{
+    if (spe->pic != NULL) {
+        picture_Release(spe->pic);
+        spe->pic = NULL;
+    }
+    buffer_destroy(&spe->wb);
+    vdre_delete(&spe->vdre);
+    dmabuf_unref(&spe->dh);
+}
+
+static void
+subpic_ent_attach(subplane_t * const plane, subpic_ent_t * const spe, eq_env_t * const eq)
+{
+    struct wl_surface *const surface = plane->surface;
+
+    if (spe->wb == NULL)
+    {
+        vdre_delete(&spe->vdre);
+        if (plane->buffer_attached)
+        {
+            wl_surface_attach(surface, NULL, 0, 0);
+            plane->buffer_attached = false;
+            plane->commit_req = true;
+        }
+    }
+    else
+    {
+        vdre_eq_ref(spe->vdre, eq);
+        wl_buffer_add_listener(spe->wb, &vdre_buffer_listener, spe->vdre);
+        wl_surface_attach(surface, spe->wb, 0, 0);
+        spe->vdre = NULL;
+        spe->wb = NULL;
+        wl_surface_damage(surface, 0, 0, INT32_MAX, INT32_MAX);
+        plane->buffer_attached = true;
+        plane->commit_req = true;
+    }
+}
+
+static void
+spe_convert_cb(void * v, short revents)
+{
+    subpic_ent_t * const spe = v;
+    VLC_UNUSED(revents);
+
+    copy_subpic_to_w_buffer(spe->vd, spe->sys, spe->pic, spe->alpha, &spe->vdre, &spe->wb);
+    atomic_store(&spe->ready, 1);
+}
+
+static inline bool
+spe_no_pic(const subpic_ent_t * const spe)
+{
+    return spe == NULL || spe->pic == NULL;
+}
+
+static bool
+spe_changed(const subpic_ent_t * const spe, const subpicture_region_t * const sreg)
+{
+    const bool no_pic = (sreg == NULL || sreg->i_alpha == 0);
+    if (no_pic && spe_no_pic(spe))
+        return false;
+    return no_pic || spe_no_pic(spe) || spe->pic != sreg->p_picture || spe->alpha != sreg->i_alpha;
+}
+
+static void
+spe_update_rect(subpic_ent_t * const spe,
+                const subpicture_t * const spic,
+                const subpicture_region_t * const sreg)
+{
+    spe->src_rect = (vout_display_place_t) {
+        .x = sreg->fmt.i_x_offset,
+        .y = sreg->fmt.i_y_offset,
+        .width = sreg->fmt.i_visible_width,
+        .height = sreg->fmt.i_visible_height,
+    };
+    spe->dst_rect = (vout_display_place_t) {
+        .x = sreg->i_x,
+        .y = sreg->i_y,
+        .width = sreg->fmt.i_visible_width,
+        .height = sreg->fmt.i_visible_height,
+    };
+    spe->orig_rect = (vout_display_place_t) {
+        .x = 0,
+        .y = 0,
+        .width  = spic->i_original_picture_width,
+        .height = spic->i_original_picture_height,
+    };
+}
+
+static void
+spe_set_color_info(const vout_display_sys_t * const sys, subpic_ent_t * const spe, const video_format_t * const fmt)
+{
+#if !HAVE_WAYLAND_COLOR_REPRESENTATION
+    VLC_UNUSED(spe);
+    VLC_UNUSED(fmt);
+#else
+    static const enum wp_color_representation_surface_v1_chroma_location location_map[CHROMA_LOCATION_MAX + 1] = {
+        [CHROMA_LOCATION_LEFT] = WP_COLOR_REPRESENTATION_SURFACE_V1_CHROMA_LOCATION_TYPE_1,
+        [CHROMA_LOCATION_CENTER] = WP_COLOR_REPRESENTATION_SURFACE_V1_CHROMA_LOCATION_TYPE_2,
+        [CHROMA_LOCATION_TOP_LEFT] = WP_COLOR_REPRESENTATION_SURFACE_V1_CHROMA_LOCATION_TYPE_0,
+        [CHROMA_LOCATION_TOP_CENTER] = WP_COLOR_REPRESENTATION_SURFACE_V1_CHROMA_LOCATION_TYPE_3,
+        [CHROMA_LOCATION_BOTTOM_LEFT] = WP_COLOR_REPRESENTATION_SURFACE_V1_CHROMA_LOCATION_TYPE_4,
+        [CHROMA_LOCATION_BOTTOM_CENTER] = WP_COLOR_REPRESENTATION_SURFACE_V1_CHROMA_LOCATION_TYPE_5,
+    };
+
+    if (sys->bound.color_representation_manager_v1 == NULL)
+        return;
+
+    spe->coefficients = fmt->primaries < 0 || fmt->primaries >= ARRAY_SIZE(sys->primary_map) ? 0 :
+        sys->primary_map[fmt->primaries].coefficients;
+    spe->range = sys->primary_map[fmt->primaries].ranges == 1 ?
+            WP_COLOR_REPRESENTATION_SURFACE_V1_RANGE_FULL :
+        sys->primary_map[fmt->primaries].ranges == 2 ?
+            WP_COLOR_REPRESENTATION_SURFACE_V1_RANGE_LIMITED :
+        fmt->b_color_range_full ?
+            WP_COLOR_REPRESENTATION_SURFACE_V1_RANGE_FULL :
+            WP_COLOR_REPRESENTATION_SURFACE_V1_RANGE_LIMITED;
+    spe->chroma_loc = fmt->chroma_location < 0 || fmt->chroma_location >= ARRAY_SIZE(location_map) ? 0 :
+            location_map[fmt->chroma_location];
+#endif
+}
+
+static subpic_ent_t *
+spe_new_pic(vout_display_t * const vd, vout_display_sys_t * const sys,
+            picture_t * const pic)
+{
+    subpic_ent_t * const spe = calloc(1, sizeof(*spe));
+
+    if (spe == NULL)
+        return NULL;
+
+    atomic_init(&spe->ready, 0);
+    spe->vd = vd;
+    spe->sys = sys;
+
+    if (pic == NULL)
+    {
+        atomic_init(&spe->ready, 1);
+        return spe;
+    }
+
+    spe->pic = picture_Hold(pic);
+    spe->alpha = 0xff;
+    return spe;
+}
+
+
+static subpic_ent_t *
+spe_new(vout_display_t * const vd, vout_display_sys_t * const sys,
+        const subpicture_t * const spic,
+        const subpicture_region_t * const sreg)
+{
+    subpic_ent_t * const spe = spe_new_pic(vd, sys,
+        (sreg == NULL || sreg->i_alpha == 0) ? NULL : sreg->p_picture);
+
+    if (spe_no_pic(spe))
+        return spe;
+
+    spe->alpha = sreg->i_alpha;
+
+    spe_update_rect(spe, spic, sreg);
+
+    spe->pt = polltask_new_timer(sys->speq, spe_convert_cb, spe);
+
+    return spe;
+}
+
+static void
+spe_delete(subpic_ent_t ** const ppspe)
+{
+    subpic_ent_t * const spe = *ppspe;
+
+    if (spe == NULL)
+        return;
+    *ppspe = NULL;
+
+    polltask_delete(&spe->pt);
+    subpic_ent_flush(spe);
+    free(spe);
+}
+
+static int
+spe_convert(subpic_ent_t * const spe)
+{
+    if (spe->pt != NULL)
+        pollqueue_add_task(spe->pt, 0);
+    return 0;
+}
+
+static void
+commit_req(vout_display_sys_t * const sys, const unsigned int layer)
+{
+    sys->planes[layer].commit_req = true;
+}
+
+static void
+commit_do(vout_display_t * const vd, vout_display_sys_t * const sys)
+{
+    int i;
+    bool flush_req = false;
+
+    for (i = MAX_SUBPICS + PLANE_SUB - 1; i >= PLANE_VID; --i)
+    {
+        if (sys->planes[i].commit_req)
+        {
+            sys->planes[i].commit_req = false;
+            wl_surface_commit(sys->planes[i].surface);
+            flush_req = true;
+        }
+    }
+    if (sys->planes[PLANE_BKG].commit_req)
+    {
+        struct wl_surface * const bkg_surface = bkg_surface_get_lock(vd, sys);
+        if (bkg_surface != NULL)
+        {
+            if (sys->bkg_viewport)
+            {
+                wp_viewport_set_destination(sys->bkg_viewport,
+                                            scale_dst(sys, sys->bkg_w), scale_dst(sys, sys->bkg_h));
+                wl_surface_commit(bkg_surface);
+            }
+            bkg_surface_unlock(vd, sys);
+            flush_req = true;
+        }
+        sys->planes[PLANE_BKG].commit_req = false;
+    }
+    if (flush_req)
+        wl_display_flush(video_display(sys));
+}
+
+static void
+clear_surface_buffer(struct wl_surface * surface)
+{
+    if (surface == NULL)
+        return;
+    wl_surface_attach(surface, NULL, 0, 0);
+    wl_surface_commit(surface);
+}
+
+static void
+plane_clear(subplane_t * const plane)
+{
+    spe_delete(&plane->spe_next);
+    spe_delete(&plane->spe_cur);
+    plane->buffer_attached = false;
+    clear_surface_buffer(plane->surface);
+}
+
+static void
+clear_all_buffers(vout_display_sys_t * const sys, const bool bkg_valid)
+{
+    for (unsigned int i = MAX_SUBPICS + PLANE_SUB - 1; i >= PLANE_VID; --i)
+        plane_clear(sys->planes + i);
+    spe_delete(&sys->video_spe_prep);
+
+    if (bkg_valid)
+        clear_surface_buffer(sys->last_embed_surface);
+}
+
+static void
+plane_destroy(subplane_t * const spl)
+{
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+    color_representation_destroy(&spl->color_rep);
+#endif
+    viewport_destroy(&spl->viewport);
+    subsurface_destroy(&spl->subsurface);
+    surface_destroy(&spl->surface);
+    // Zap all tracking vars
+    spl->buffer_attached = false;
+    spl->trans = 0;
+    memset(&spl->src_rect, 0, sizeof(spl->src_rect));
+    memset(&spl->dst_rect, 0, sizeof(spl->dst_rect));
+}
+
+static int
+plane_create(vout_display_sys_t * const sys, subplane_t * const plane,
+             struct wl_surface * const parent,
+             const int commit_parent,
+             struct wl_surface * const above,
+             const bool sync)
+{
+    plane->commit_parent = commit_parent;
+    if ((plane->surface = wl_compositor_create_surface(video_compositor(sys))) == NULL ||
+        (plane->subsurface = wl_subcompositor_get_subsurface(sys->bound.subcompositor, plane->surface, parent)) == NULL ||
+        (plane->viewport = wp_viewporter_get_viewport(sys->bound.viewporter, plane->surface)) == NULL)
+        return VLC_EGENERIC;
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+    if (sys->bound.color_representation_manager_v1 != NULL)
+        plane->color_rep = wp_color_representation_manager_v1_get_surface(sys->bound.color_representation_manager_v1, plane->surface);
+#endif
+    wl_subsurface_place_above(plane->subsurface, above);
+    if (sync)
+        wl_subsurface_set_sync(plane->subsurface);
+    else
+        wl_subsurface_set_desync(plane->subsurface);
+    wl_surface_set_input_region(plane->surface, sys->region_none);
+    return 0;
+}
+
+static void
+unmap_all(vout_display_sys_t * const sys, const bool bkg_valid)
+{
+    clear_all_buffers(sys, bkg_valid);
+
+    pres_stats_finish(&sys->pse, &sys->stats);
+
+    // Free subpic resources
+    for (unsigned int i = MAX_SUBPICS + PLANE_SUB - 1; i >= PLANE_VID; --i)
+        plane_destroy(sys->planes + i);
+
+    viewport_destroy(&sys->bkg_viewport);
+}
+
+static struct wl_surface *
+bkg_surface_get_lock(vout_display_t * const vd, vout_display_sys_t * const sys)
+{
+    if (!sys->embed) {
+        msg_Err(vd, "%s: Embed NULL", __func__);
+        return NULL;
+    }
+
+    vlc_mutex_lock(&sys->embed->handle_lock);
+
+    if (sys->embed->handle.wl != sys->last_embed_surface || sys->embed->handle_seq != sys->last_embed_seq)
+    {
+        msg_Warn(vd, "%s: Embed surface changed %p (%u)->%p (%u)", __func__,
+                 sys->last_embed_surface, sys->last_embed_seq,
+                 sys->embed->handle.wl, sys->embed->handle_seq);
+
+        sys->last_embed_surface = sys->embed->handle.wl;
+        sys->last_embed_seq = sys->embed->handle_seq;
+        unmap_all(sys, false);
+    }
+
+    if (sys->last_embed_surface == NULL)
+        vlc_mutex_unlock(&sys->embed->handle_lock);
+
+    return sys->last_embed_surface;
+}
+
+static void
+bkg_surface_unlock(vout_display_t * const vd, vout_display_sys_t * const sys)
+{
+    VLC_UNUSED(vd);
+    vlc_mutex_unlock(&sys->embed->handle_lock);
+}
+
+static int
+make_subpic_surfaces(vout_display_t * const vd, vout_display_sys_t * const sys)
+{
+    unsigned int i;
+    subplane_t * const subplanes = sys->planes + PLANE_SUB;
+    struct wl_surface * const surface = video_surface(sys);
+    struct wl_surface * below = surface;
+    int rv;
+
+    if (subplanes[0].surface)
+        return VLC_SUCCESS;
+
+    for (i = 0; i != MAX_SUBPICS; ++i)
+    {
+        subplane_t * const plane = subplanes + i;
+        if ((rv = plane_create(sys, plane, surface, PLANE_VID, below, true)) != 0)
+        {
+            msg_Err(vd, "%s: Failed to create subpic plane %d", __func__, i);
+            return rv;
+        }
+        below = plane->surface;
+    }
+    return VLC_SUCCESS;
+}
+
+static int
+make_background_and_video(vout_display_t * const vd, vout_display_sys_t * const sys)
+{
+    // Build a background
+    // Use single_pixel_surface extension if we have it & want a simple
+    // single colour (black) patch
+    video_dmabuf_release_env_t * vdre = NULL;
+    struct wl_buffer * w_buffer = NULL;
+    struct wl_surface * bkg_surface = NULL;
+
+    if (sys->bkg_viewport)
+        return VLC_SUCCESS;
+
+#if HAVE_WAYLAND_SINGLE_PIXEL_BUFFER
+    if (sys->bound.single_pixel_buffer_manager_v1 && !sys->chequerboard)
+    {
+        w_buffer = wp_single_pixel_buffer_manager_v1_create_u32_rgba_buffer(
+            sys->bound.single_pixel_buffer_manager_v1,
+            0, 0, 0, UINT32_MAX);  // R, G, B, A
+        vdre = vdre_new_null();
+    }
+    else
+#endif
+    {
+        // Buffer width & height - not display
+        const unsigned int width = sys->chequerboard ? 640 : 32;
+        const unsigned int height = sys->chequerboard ? 480 : 32;
+        const unsigned int stride = width * 4;
+        struct dmabuf_h * const dh = picpool_get(sys->subpic_pool, stride * height);
+        const AVDRMFrameDescriptor dfd = {
+            .nb_objects = 1,
+            .objects = {{
+                .fd = dmabuf_fd(dh),
+                .size = dmabuf_size(dh)}},
+            .nb_layers = 1,
+            .layers = {{
+                .format = DRM_FORMAT_XRGB8888,
+                .nb_planes = 1,
+                .planes = {{.pitch = stride}}
+            }}
+        };
+
+        if (dh == NULL)
+        {
+            msg_Err(vd, "Failed to get DmaBuf for background");
+            goto error;
+        }
+
+        vdre = vdre_new_dh(dh, sys->pollq);
+
+        dmabuf_write_start(dh);
+        if (sys->chequerboard)
+            chequerboard(dmabuf_map(dh), stride, width, height);
+        else
+            fill_uniform(dmabuf_map(dh), stride, width, height, 0xff000000);
+        dmabuf_write_end(dh);
+
+        w_buffer = dfd_make_buffer(vd, sys, dmabuf_is_fake(dh), &dfd, width, height, 0);
+    }
+    if (!w_buffer || !vdre)
+    {
+        msg_Err(vd, "Failed to create background buffer");
+        goto error;
+    }
+
+    if ((bkg_surface = bkg_surface_get_lock(vd, sys)) == NULL)
+        goto error;
+
+    sys->bkg_viewport = wp_viewporter_get_viewport(sys->bound.viewporter, bkg_surface);
+    if (sys->bkg_viewport == NULL)
+    {
+        msg_Err(vd, "Failed to create background viewport");
+        goto err_unlock;
+    }
+
+#if CHECK_VDRE_COUNTS
+    vdre_add_check(vdre, &sys->vdre_check_bkg);
+#endif
+    vdre_eq_ref(vdre, sys->eq);
+    // Wayland will not commit a SPB to a scaled surface (not a multiple!)
+    // Qt sets buffer scale to output scale and we are told everything in 
+    // scaled units
+    wl_surface_set_buffer_scale(bkg_surface, 1);
+    wl_buffer_add_listener(w_buffer, &vdre_buffer_listener, vdre);
+    wl_surface_attach(bkg_surface, w_buffer, 0, 0);
+    vdre = NULL;
+    w_buffer = NULL;
+
+    wp_viewport_set_destination(sys->bkg_viewport,
+                                scale_dst(sys, sys->bkg_w), scale_dst(sys, sys->bkg_h));
+    wl_surface_set_opaque_region(bkg_surface, sys->region_all);
+
+    wl_surface_damage(bkg_surface, 0, 0, INT32_MAX, INT32_MAX);
+
+    if (plane_create(sys, sys->planes + PLANE_VID, bkg_surface, PLANE_BKG, bkg_surface, false) != 0)
+    {
+        msg_Err(vd, "Failed to create video plane");
+        goto err_unlock;
+    }
+
+    wl_surface_set_opaque_region(video_surface(sys), sys->region_all);
+
+    commit_req(sys, PLANE_BKG);
+
+    bkg_surface_unlock(vd, sys);
+
+    return VLC_SUCCESS;
+
+err_unlock:
+    bkg_surface_unlock(vd, sys);
+error:
+    buffer_destroy(&w_buffer);
+    vdre_delete(&vdre);
+    return VLC_ENOMEM;
+}
+
+// Get tranform & adjusted source coords for orientation
+static enum wl_output_transform
+transform_from_fmt(const video_format_t * const fmt, vout_display_place_t * const s)
+{
+    const int rx_offset = fmt->i_width - (fmt->i_visible_width + fmt->i_x_offset);
+    const int by_offset = fmt->i_height - (fmt->i_visible_height + fmt->i_y_offset);
+
+    switch (fmt->orientation)
+    {
+        case ORIENT_ROTATED_90:  // ORIENT_RIGHT_TOP,
+            *s = (vout_display_place_t){
+                .x      = by_offset,
+                .y      = fmt->i_x_offset,
+                .width  = fmt->i_visible_height,
+                .height = fmt->i_visible_width};
+            return WL_OUTPUT_TRANSFORM_90;
+
+        case ORIENT_ROTATED_180: // ORIENT_BOTTOM_RIGHT,
+            *s = (vout_display_place_t){
+                .x      = by_offset,
+                .y      = rx_offset,
+                .width  = fmt->i_visible_width,
+                .height = fmt->i_visible_height};
+            return WL_OUTPUT_TRANSFORM_180;
+
+        case ORIENT_ROTATED_270: // ORIENT_LEFT_BOTTOM,
+            *s = (vout_display_place_t){
+                .x      = fmt->i_y_offset,
+                .y      = rx_offset,
+                .width  = fmt->i_visible_height,
+                .height = fmt->i_visible_width};
+            return WL_OUTPUT_TRANSFORM_270;
+
+        case ORIENT_HFLIPPED:    // ORIENT_TOP_RIGHT,
+            *s = (vout_display_place_t){
+                .x      = rx_offset,
+                .y      = fmt->i_y_offset,
+                .width  = fmt->i_visible_width,
+                .height = fmt->i_visible_height};
+            return WL_OUTPUT_TRANSFORM_FLIPPED;
+
+        case ORIENT_VFLIPPED:    // ORIENT_BOTTOM_LEFT,
+            *s = (vout_display_place_t){
+                .x      = fmt->i_x_offset,
+                .y      = by_offset,
+                .width  = fmt->i_visible_width,
+                .height = fmt->i_visible_height};
+            return WL_OUTPUT_TRANSFORM_FLIPPED_180;
+
+        case ORIENT_TRANSPOSED:  // ORIENT_LEFT_TOP,
+            *s = (vout_display_place_t){
+                .x      = fmt->i_y_offset,
+                .y      = fmt->i_x_offset,
+                .width  = fmt->i_visible_height,
+                .height = fmt->i_visible_width};
+            return WL_OUTPUT_TRANSFORM_FLIPPED_90;
+
+        case ORIENT_ANTI_TRANSPOSED: // ORIENT_RIGHT_BOTTOM,
+            *s = (vout_display_place_t){
+                .x      = rx_offset,
+                .y      = by_offset,
+                .width  = fmt->i_visible_height,
+                .height = fmt->i_visible_width};
+            return WL_OUTPUT_TRANSFORM_FLIPPED_270;
+
+        case ORIENT_NORMAL:      // ORIENT_TOP_LEFT,
+        default:
+            *s = (vout_display_place_t){
+                .x      = fmt->i_x_offset,
+                .y      = fmt->i_y_offset,
+                .width  = fmt->i_visible_width,
+                .height = fmt->i_visible_height};
+            return WL_OUTPUT_TRANSFORM_NORMAL;
+    }
+}
+
+static void
+place_rects(vout_display_t * const vd,
+          const vout_display_cfg_t * const cfg)
+{
+    vout_display_sys_t * const sys = vd->sys;
+
+    vout_display_PlacePicture(&sys->video_dst_rect, &vd->source, cfg, true);
+    sys->video_trans = transform_from_fmt(&vd->source, &sys->video_src_rect);
+}
+
+static const drmu_vlc_fmt_info_t *
+find_fmt_fallback(vout_display_t * const vd, const fmt_list_t * const flist, const vlc_fourcc_t * fallback)
+{
+    const drmu_vlc_fmt_info_t * fmti_best = NULL;
+    int pri_best = INT_MAX;
+
+    for (; *fallback != 0; ++fallback)
+    {
+        const video_frame_format_t vf = {.i_chroma = *fallback};
+        const drmu_vlc_fmt_info_t * fmti = NULL;
+
+        msg_Dbg(vd, "Try %s", drmu_log_fourcc(*fallback));
+
+        for (fmti = drmu_vlc_fmt_info_find_vlc(&vf);
+             fmti != NULL;
+             fmti = drmu_vlc_fmt_info_find_vlc_next(&vf, fmti))
+        {
+            const int pri = fmt_list_find(flist, fmti);
+            msg_Dbg(vd, "Try %s -> %s %"PRIx64": %d", drmu_log_fourcc(*fallback),
+                    drmu_log_fourcc(drmu_vlc_fmt_info_drm_pixelformat(fmti)),
+                    drmu_vlc_fmt_info_drm_modifier(fmti), pri);
+            if (pri >= 0 && pri < pri_best)
+            {
+                fmti_best = fmti;
+                pri_best = pri;
+
+                // If we've got pri 0 then might as well stop now
+                if (pri == 0)
+                    return fmti_best;
+            }
+        }
+    }
+
+    return fmti_best;
+}
+
+static const drmu_vlc_fmt_info_t *
+get_usable_format(vout_display_t * const vd,
+                  const fmt_list_t * const flist,
+                  const video_format_t * const fmt)
+{
+    const drmu_vlc_fmt_info_t * pic_fmti;
+
+    // Check PIC DRM format here
+    if ((pic_fmti = drmu_vlc_fmt_info_find_vlc(fmt)) == NULL ||
+        fmt_list_find(flist, pic_fmti) < 0)
+    {
+        static const vlc_fourcc_t fallback2[] = {
+            VLC_CODEC_I420,
+            VLC_CODEC_RGB32,
+            0
+        };
+
+        msg_Warn(vd, "Could not find %s -> %s mod %#"PRIx64" in supported formats",
+                 drmu_log_fourcc(fmt->i_chroma),
+                 drmu_log_fourcc(drmu_vlc_fmt_info_drm_pixelformat(pic_fmti)),
+                 drmu_vlc_fmt_info_drm_modifier(pic_fmti));
+
+        if ((pic_fmti = find_fmt_fallback(vd, flist,
+                                          vlc_fourcc_IsYUV(fmt->i_chroma) ?
+                                              vlc_fourcc_GetYUVFallback(fmt->i_chroma) :
+                                              vlc_fourcc_GetRGBFallback(fmt->i_chroma))) == NULL &&
+            (pic_fmti = find_fmt_fallback(vd, flist, fallback2)) == NULL) {
+            msg_Warn(vd, "Failed to find any usable fallback format");
+        }
+    }
+    return pic_fmti;
+}
+
+static int
+set_req_format(vout_display_t * const vd, const vout_display_sys_t * const sys, video_format_t * const fmt)
+{
+    const video_format_t * const src_fmt = &vd->source;
+    const drmu_vlc_fmt_info_t * const fmti = get_usable_format(vd, sys->use_shm ? &sys->shm_fmts : &sys->dmabuf_fmts, src_fmt);
+
+    if (fmti == NULL)
+        return VLC_EGENERIC;
+
+    *fmt = *src_fmt;
+    fmt->i_chroma = drmu_vlc_fmt_info_vlc_chroma(fmti);
+    drmu_vlc_fmt_info_vlc_rgb_masks(fmti, &fmt->i_rmask, &fmt->i_gmask, &fmt->i_bmask);
+
+    return VLC_SUCCESS;
+}
+
+static void
+plane_set_rect(vout_display_sys_t * const sys, subplane_t * const plane, const subpic_ent_t * const spe)
+{
+    // Always called after the attach
+    if (!plane->buffer_attached || spe == NULL)
+        return;
+
+    const vout_display_place_t dst_rect = place_rescale(spe->dst_rect,
+                                                        plane->commit_parent == PLANE_VID ? place_zoffset(sys->video_dst_rect) : sys->video_dst_rect,
+                                                        spe->orig_rect);
+
+    if (spe->trans != plane->trans)
+    {
+        wl_surface_set_buffer_transform(plane->surface, spe->trans);
+        plane->commit_req = true;
+    }
+    if (!place_eq(spe->src_rect, plane->src_rect))
+    {
+        wp_viewport_set_source(plane->viewport,
+                               wl_fixed_from_int(spe->src_rect.x), wl_fixed_from_int(spe->src_rect.y),
+                               wl_fixed_from_int(spe->src_rect.width), wl_fixed_from_int(spe->src_rect.height));
+        plane->commit_req = true;
+    }
+    if (!place_xy_eq(dst_rect, plane->dst_rect))
+    {
+        wl_subsurface_set_position(plane->subsurface, scale_dst(sys, dst_rect.x), scale_dst(sys, dst_rect.y));
+        plane->commit_req = true;
+    }
+    if (!place_wh_eq(dst_rect, plane->dst_rect))
+    {
+        wp_viewport_set_destination(plane->viewport,
+                                    scale_dst(sys, dst_rect.width), scale_dst(sys, dst_rect.height));
+        commit_req(sys, plane->commit_parent); // Subsurface pos needs parent commit (video)
+    }
+
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+    if (plane->color_rep != NULL)
+    {
+        if (spe->alpha_mode && spe->alpha_mode != plane->alpha_mode)
+        {
+            wp_color_representation_surface_v1_set_alpha_mode(plane->color_rep, spe->alpha_mode);
+            plane->alpha_mode = spe->alpha_mode;
+            plane->commit_req = true;
+        }
+        if (spe->chroma_loc && spe->chroma_loc != plane->chroma_loc)
+        {
+            wp_color_representation_surface_v1_set_chroma_location(plane->color_rep, spe->chroma_loc);
+            plane->chroma_loc = spe->chroma_loc;
+            plane->commit_req = true;
+        }
+        if (spe->coefficients && (spe->coefficients != plane->coefficients || spe->range != plane->range))
+        {
+            wp_color_representation_surface_v1_set_coefficients_and_range(plane->color_rep, spe->coefficients, spe->range);
+            plane->coefficients = spe->coefficients;
+            plane->range = spe->range;
+            plane->commit_req = true;
+        }
+    }
+#endif
+
+    plane->trans = spe->trans;
+    plane->src_rect = spe->src_rect;
+    plane->dst_rect = dst_rect;
+}
+
+static void Prepare(vout_display_t *vd, picture_t *pic, subpicture_t *subpic)
+{
+    vout_display_sys_t * const sys = vd->sys;
+    unsigned int n = 0;
+
+#if TRACE_ALL
+    msg_Dbg(vd, "<<< %s: Surface: %p", __func__, sys->embed->handle.wl);
+#endif
+
+    {
+        subpic_ent_t * const spe = spe_new_pic(vd, sys, pic);
+        if (spe == NULL)
+        {
+            msg_Err(vd, "Failed to create new video spe");
+            return;
+        }
+        spe->trans = sys->video_trans;
+        spe->src_rect = sys->video_src_rect;
+        spe->dst_rect = sys->video_dst_rect;
+        spe->orig_rect = spe->dst_rect;
+
+        spe_set_color_info(sys, spe, &pic->format);
+
+        if (sys->video_spe_prep)
+        {
+            if (!sys->bkg_null)
+                msg_Err(vd, "Spe prep != NULL");
+            spe_delete(&sys->video_spe_prep);
+            ++sys->stats.frame_discard;
+        }
+        sys->video_spe_prep = spe;
+
+        if (drmu_format_vlc_to_drm_prime(&pic->format, NULL) == 0)
+            copy_subpic_to_w_buffer(vd, sys, pic, 0xff, &spe->vdre, &spe->wb);
+        else
+            do_display_dmabuf(vd, sys, pic, &spe->vdre, &spe->wb);
+        atomic_store(&spe->ready, 1);
+        wl_display_flush(video_display(sys)); // Kick off any work required by Wayland
+    }
+
+    // Attempt to import the subpics
+    for (const subpicture_t * spic = subpic; spic != NULL; spic = spic->p_next)
+    {
+        for (const subpicture_region_t *sreg = spic->p_region; sreg != NULL; sreg = sreg->p_next)
+        {
+            subplane_t * const plane = sys->planes + n + PLANE_SUB;
+
+            if (plane->spe_next != NULL)
+            {
+                if (!spe_changed(plane->spe_next, sreg))
+                    spe_update_rect(plane->spe_next, spic, sreg);
+                // else if changed ignore as we are already doing stuff
+            }
+            else
+            {
+                if (!spe_changed(plane->spe_cur, sreg))
+                    spe_update_rect(plane->spe_cur, spic, sreg);
+                else
+                {
+                    plane->spe_next = spe_new(vd, sys, spic, sreg);
+                    spe_convert(plane->spe_next);
+                }
+            }
+
+            if (++n == MAX_SUBPICS)
+                goto subpics_done;
+        }
+    }
+subpics_done:
+
+    // Clear any other entries
+    for (; n != MAX_SUBPICS; ++n) {
+        subplane_t * const plane = sys->planes + n + PLANE_SUB;
+        if (plane->spe_next == NULL && spe_changed(plane->spe_cur, NULL))
+            plane->spe_next = spe_new(vd, sys, NULL, NULL);
+    }
+
+#if TRACE_ALL
+    msg_Dbg(vd, ">>> %s: Surface: %p", __func__, sys->embed->handle.wl);
+#endif
+}
+
+static void
+do_resize(vout_display_t * const vd, vout_display_sys_t * const sys)
+{
+    if (!sys->bkg_viewport)
+        return;
+
+    for (unsigned int i = PLANE_VID; i != PLANE_SUB + MAX_SUBPICS; ++i)
+    {
+        subplane_t * const plane = sys->planes + i;
+        subpic_ent_t * spe = plane->spe_cur;
+
+        plane_set_rect(sys, plane, spe);
+    }
+
+    if (sys->bkg_viewport != NULL && (vd->cfg->display.width != sys->bkg_w || vd->cfg->display.height != sys->bkg_h))
+    {
+        msg_Dbg(vd, "Resize background: %dx%d", vd->cfg->display.width, vd->cfg->display.height);
+        commit_req(sys, PLANE_BKG);
+    }
+    sys->bkg_w = vd->cfg->display.width;
+    sys->bkg_h = vd->cfg->display.height;
+}
+
+static pres_cb_env_t *
+pce_new(pres_stats_env_t * const pse, const uint64_t pts)
+{
+    pres_cb_env_t * pce = malloc(sizeof(*pce));
+    if (pce == NULL)
+        return NULL;
+    pce->pse = pres_stats_ref(pse);
+    pce->pts = pts;
+    return pce;
+}
+
+static void
+pce_free(pres_cb_env_t * const pce)
+{
+    pres_stats_unref(&pce->pse);
+    free(pce);
+}
+
+static void
+presentation_sync_output_cb(void *data,
+            struct wp_presentation_feedback *wp_presentation_feedback,
+            struct wl_output *output)
+{
+    (void)data;
+    (void)wp_presentation_feedback;
+    (void)output;
+}
+
+// Presented/Discarded can occur after close has finished so need to
+static void
+presentation_presented_cb(void *data,
+          struct wp_presentation_feedback *wp_presentation_feedback,
+          uint32_t tv_sec_hi,
+          uint32_t tv_sec_lo,
+          uint32_t tv_nsec,
+          uint32_t refresh,
+          uint32_t seq_hi,
+          uint32_t seq_lo,
+          uint32_t flags)
+{
+    pres_cb_env_t * const pce = data;
+    pres_stats_env_t * const pse = pce->pse;
+    (void)tv_sec_hi;
+    (void)tv_sec_lo;
+    (void)tv_nsec;
+    (void)refresh;
+    (void)seq_hi;
+    (void)seq_lo;
+    (void)flags;
+
+    wp_presentation_feedback_destroy(wp_presentation_feedback);
+
+    ++pse->w_display;
+    pce_free(pce);
+}
+
+static void
+presentation_discarded_cb(void *data,
+          struct wp_presentation_feedback *wp_presentation_feedback)
+{
+    // feedback object implicitly destroyed
+    pres_cb_env_t * const pce = data;
+    pres_stats_env_t * const pse = pce->pse;
+
+    wp_presentation_feedback_destroy(wp_presentation_feedback);
+
+    ++pse->w_discard;
+    pce_free(pce);
+}
+
+static const struct wp_presentation_feedback_listener presentation_feedback_listener = {
+    .sync_output = presentation_sync_output_cb,
+    .presented = presentation_presented_cb,
+    .discarded = presentation_discarded_cb,
+};
+
+static void
+do_display(vout_display_t * const vd, vout_display_sys_t * const sys)
+{
+//    msg_Info(vd, "<<< %s: Surface: %p", __func__, sys->embed->handle.wl);
+
+    sys->stats.time_frameN = mdate();
+    if (!sys->stats.time_frame0)
+        sys->stats.time_frame0 = sys->stats.time_frameN;
+    ++sys->stats.frame_n;
+
+    if (spe_no_pic(sys->planes[PLANE_VID].spe_next))
+    {
+        msg_Warn(vd, "%s: No current pic", __func__);
+        return;
+    }
+
+    if (make_background_and_video(vd, sys) != 0)
+    {
+        msg_Warn(vd, "%s: Make background fail", __func__);
+        return;
+    }
+    make_subpic_surfaces(vd, sys);
+
+    for (unsigned int i = PLANE_VID; i != PLANE_SUB + MAX_SUBPICS; ++i)
+    {
+        subplane_t * const plane = sys->planes + i;
+        subpic_ent_t * spe = plane->spe_cur;
+
+        if (plane->spe_next && atomic_load(&plane->spe_next->ready))
+        {
+            spe_delete(&plane->spe_cur);
+            spe = plane->spe_cur = plane->spe_next;
+            plane->spe_next = NULL;
+            subpic_ent_attach(plane, spe, sys->eq);
+
+            if (i == PLANE_VID && sys->pse != NULL)
+            {
+                struct wp_presentation_feedback * feedback = wp_presentation_feedback(sys->bound.presentation, plane->surface);
+                wp_presentation_feedback_add_listener(feedback, &presentation_feedback_listener, pce_new(sys->pse, 0));
+                // * We unconditionally do a commit after this - if this is ever
+                // not the case we will need cleanup code for eq & feedback
+            }
+        }
+    }
+
+    do_resize(vd, sys);
+
+    commit_do(vd, sys);
+    return;
+}
+
+static void Display(vout_display_t *vd, picture_t *pic, subpicture_t *subpic)
+{
+    vout_display_sys_t * const sys = vd->sys;
+
+#if TRACE_ALL
+    msg_Dbg(vd, "<<< %s: Surface: %p", __func__, sys->embed->handle.wl);
+#endif
+
+    // Check we have a surface to put the video on
+    if (bkg_surface_get_lock(vd, sys) == NULL)
+    {
+        if (!sys->bkg_null) {
+            sys->bkg_null = true;
+            msg_Warn(vd, "%s: No background surface", __func__);
+        }
+        goto done;
+    }
+    sys->bkg_null = false;
+    bkg_surface_unlock(vd, sys);
+
+    if (!sys->video_spe_prep)
+    {
+        msg_Warn(vd, "No prepared video spe");
+        goto done;
+    }
+
+    if (sys->planes[PLANE_VID].spe_next)
+    {
+        msg_Warn(vd, "Current video spe discarded");
+        spe_delete(&sys->planes[PLANE_VID].spe_next);
+        ++sys->stats.frame_discard;
+    }
+    sys->planes[PLANE_VID].spe_next = sys->video_spe_prep;
+    sys->video_spe_prep = NULL;
+
+    ++sys->stats.frame_display;
+    do_display(vd, sys);
+
+done:
+    if (subpic)
+        subpicture_Delete(subpic);
+    picture_Release(pic);
+
+#if TRACE_ALL
+    msg_Dbg(vd, ">>> %s: Surface: %p", __func__, sys->embed->handle.wl);
+#endif
+}
+
+static int Control(vout_display_t *vd, int query, va_list ap)
+{
+    vout_display_sys_t * const sys = vd->sys;
+
+#if TRACE_ALL
+    msg_Dbg(vd, "<<< %s: Query=%d", __func__, query);
+#endif
+
+    switch (query)
+    {
+        case VOUT_DISPLAY_CHANGE_SOURCE_ASPECT:
+        case VOUT_DISPLAY_CHANGE_SOURCE_CROP:
+            place_rects(vd, vd->cfg);
+            do_resize(vd, sys);
+            commit_do(vd, sys);
+            break;
+
+        case VOUT_DISPLAY_CHANGE_DISPLAY_SIZE:
+        case VOUT_DISPLAY_CHANGE_DISPLAY_FILLED:
+        case VOUT_DISPLAY_CHANGE_ZOOM:
+        {
+            const vout_display_cfg_t * const cfg = va_arg(ap, const vout_display_cfg_t *);
+
+            place_rects(vd, cfg);
+            do_resize(vd, sys);
+            commit_do(vd, sys);
+            break;
+        }
+
+        case VOUT_DISPLAY_RESET_PICTURES:
+            msg_Err(vd, "Unexpected reset pictures");
+            return VLC_EGENERIC;
+
+        default:
+            msg_Err(vd, "unknown request %d", query);
+            return VLC_EGENERIC;
+    }
+
+#if TRACE_ALL
+    msg_Dbg(vd, ">>> %s: Surface: %p", __func__, sys->embed->handle.wl);
+#endif
+    return VLC_SUCCESS;
+}
+
+static void linux_dmabuf_v1_listener_format(void *data,
+               struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1,
+               uint32_t format)
+{
+    // Superceeded by _modifier
+    vout_display_t * const vd = data;
+    vout_display_sys_t * const sys = vd->sys;
+    (void)zwp_linux_dmabuf_v1;
+#if TRACE_ALL
+    msg_Dbg(vd, "%s[%p], %.4s", __func__, (void*)vd, (const char *)&format);
+#endif
+    fmt_list_add(&sys->dmabuf_fmts, format, DRM_FORMAT_MOD_LINEAR, 0);
+}
+
+static void
+linux_dmabuf_v1_listener_modifier(void *data,
+         struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1,
+         uint32_t format,
+         uint32_t modifier_hi,
+         uint32_t modifier_lo)
+{
+    vout_display_t * const vd = data;
+    vout_display_sys_t * const sys = vd->sys;
+    (void)zwp_linux_dmabuf_v1;
+#if TRACE_ALL
+    msg_Dbg(vd, "%s[%p], %.4s %08x%08x", __func__, (void*)vd, (const char *)&format, modifier_hi, modifier_lo);
+#endif
+    fmt_list_add(&sys->dmabuf_fmts, format, modifier_lo | ((uint64_t)modifier_hi << 32), 0);
+}
+
+static const struct zwp_linux_dmabuf_v1_listener linux_dmabuf_v1_listener = {
+    .format = linux_dmabuf_v1_listener_format,
+    .modifier = linux_dmabuf_v1_listener_modifier,
+};
+
+static void shm_listener_format(void *data,
+               struct wl_shm *shm,
+               uint32_t format)
+{
+    vout_display_t * const vd = data;
+    vout_display_sys_t * const sys = vd->sys;
+    (void)shm;
+
+    if (format == 0)
+        format = DRM_FORMAT_ARGB8888;
+    else if (format == 1)
+        format = DRM_FORMAT_XRGB8888;
+
+#if TRACE_ALL
+    msg_Dbg(vd, "%s[%p], %.4s", __func__, (void*)vd, (const char *)&format);
+#endif
+    fmt_list_add(&sys->shm_fmts, format, DRM_FORMAT_MOD_LINEAR, 0);
+}
+
+static const struct wl_shm_listener shm_listener = {
+    .format = shm_listener_format,
+};
+
+static void
+presentation_clock_id(void *data,
+                      struct wp_presentation * presentation,
+                      uint32_t clock_id)
+{
+    vout_display_t * const vd = data;
+    vout_display_sys_t * const sys = vd->sys;
+    (void)presentation;
+    sys->presentation_clock_id = clock_id;
+}
+
+static const struct wp_presentation_listener presentation_listener = {
+    .clock_id = presentation_clock_id,
+};
+
+
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+
+/**
+ * supported alpha modes
+ *
+ * When this object is created, it shall immediately send this
+ * event once for each alpha mode the compositor supports.
+ *
+ * For the definition of the supported values, see the
+ * wp_color_representation_surface_v1::alpha_mode enum.
+ * @param alpha_mode supported alpha mode
+ */
+static void color_representation_manager_supported_alpha_mode(void *data,
+                 struct wp_color_representation_manager_v1 *wp_color_representation_manager_v1,
+                 uint32_t alpha_mode)
+{
+    vout_display_t * const vd = data;
+    vout_display_sys_t * const sys = vd->sys;
+    VLC_UNUSED(wp_color_representation_manager_v1);
+
+    if (alpha_mode == WP_COLOR_REPRESENTATION_SURFACE_V1_ALPHA_MODE_STRAIGHT)
+        sys->has_straight_alpha = true;
+}
+
+/**
+ * supported matrix coefficients and ranges
+ *
+ * When this object is created, it shall immediately send this
+ * event once for each matrix coefficient and color range
+ * combination the compositor supports.
+ *
+ * For the definition of the supported values, see the
+ * wp_color_representation_surface_v1::coefficients and
+ * wp_color_representation_surface_v1::range enums.
+ * @param coefficients supported matrix coefficients
+ * @param range full range flag
+ */
+static void color_representation_manager_supported_coefficients_and_ranges(void *data,
+                      struct wp_color_representation_manager_v1 *wp_color_representation_manager_v1,
+                      uint32_t coefficients,
+                      uint32_t range)
+{
+    vout_display_t * const vd = data;
+    vout_display_sys_t * const sys = vd->sys;
+    VLC_UNUSED(wp_color_representation_manager_v1);
+    const unsigned int rmask = (range != WP_COLOR_REPRESENTATION_SURFACE_V1_RANGE_LIMITED) ? 1 : 2;
+
+    switch (coefficients)
+    {
+        case WP_COLOR_REPRESENTATION_SURFACE_V1_COEFFICIENTS_BT601:
+            sys->primary_map[COLOR_PRIMARIES_BT601_525].coefficients = coefficients;
+            sys->primary_map[COLOR_PRIMARIES_BT601_525].ranges |= rmask;
+            sys->primary_map[COLOR_PRIMARIES_BT601_625].coefficients = coefficients;
+            sys->primary_map[COLOR_PRIMARIES_BT601_625].ranges |= rmask;
+            break;
+        case WP_COLOR_REPRESENTATION_SURFACE_V1_COEFFICIENTS_BT709:
+            sys->primary_map[COLOR_PRIMARIES_BT709].coefficients = coefficients;
+            sys->primary_map[COLOR_PRIMARIES_BT709].ranges |= rmask;
+            break;
+        case WP_COLOR_REPRESENTATION_SURFACE_V1_COEFFICIENTS_BT2020:
+            sys->primary_map[COLOR_PRIMARIES_BT2020].coefficients = coefficients;
+            sys->primary_map[COLOR_PRIMARIES_BT2020].ranges |= rmask;
+            break;
+        case WP_COLOR_REPRESENTATION_SURFACE_V1_COEFFICIENTS_FCC:
+            sys->primary_map[COLOR_PRIMARIES_FCC1953].coefficients = coefficients;
+            sys->primary_map[COLOR_PRIMARIES_FCC1953].ranges |= rmask;
+            break;
+        default:
+            break;
+    }
+}
+
+/**
+ * all features have been sent
+ *
+ * This event is sent when all supported features have been sent.
+ */
+static void color_representation_manager_done(void *data,
+         struct wp_color_representation_manager_v1 *wp_color_representation_manager_v1)
+{
+    VLC_UNUSED(data);
+    VLC_UNUSED(wp_color_representation_manager_v1);
+}
+
+static const struct wp_color_representation_manager_v1_listener color_representation_manager_v1_listener = {
+    .supported_alpha_mode = color_representation_manager_supported_alpha_mode,
+    .supported_coefficients_and_ranges = color_representation_manager_supported_coefficients_and_ranges,
+    .done = color_representation_manager_done,
+};
+#endif
+
+static void w_bound_add(vout_display_t * const vd, w_bound_t * const b,
+                        struct wl_registry * const registry,
+                        const uint32_t name, const char *const iface, const uint32_t vers)
+{
+#if TRACE_ALL
+    msg_Dbg(vd, "global %3"PRIu32": %s version %"PRIu32, name, iface, vers);
+#endif
+    if (strcmp(iface, wl_subcompositor_interface.name) == 0)
+        b->subcompositor = wl_registry_bind(registry, name, &wl_subcompositor_interface, 1);
+    else
+    if (strcmp(iface, wl_shm_interface.name) == 0)
+    {
+        b->shm = wl_registry_bind(registry, name, &wl_shm_interface, 1);
+        wl_shm_add_listener(b->shm, &shm_listener, vd);
+    }
+    else
+    if (strcmp(iface, wp_viewporter_interface.name) == 0)
+        b->viewporter = wl_registry_bind(registry, name, &wp_viewporter_interface, 1);
+    else
+    if (!strcmp(iface, wl_compositor_interface.name))
+    {
+        if (vers >= 4)
+            b->compositor = wl_registry_bind(registry, name, &wl_compositor_interface, 4);
+        else
+            msg_Warn(vd, "Interface %s wanted v 4 got v %d", wl_compositor_interface.name, vers);
+    }
+    else
+    if (!vd->sys->use_shm && strcmp(iface, zwp_linux_dmabuf_v1_interface.name) == 0)
+    {
+        if (vers >= 3)
+        {
+            b->linux_dmabuf_v1 = wl_registry_bind(registry, name, &zwp_linux_dmabuf_v1_interface, 3);
+            zwp_linux_dmabuf_v1_add_listener(b->linux_dmabuf_v1, &linux_dmabuf_v1_listener, vd);
+        }
+        else
+            msg_Warn(vd, "Interface %s wanted v 3 got v %d", zwp_linux_dmabuf_v1_interface.name, vers);
+    }
+    else
+    if (vd->sys->want_stats && strcmp(iface, wp_presentation_interface.name) == 0)
+    {
+        b->presentation = wl_registry_bind(registry, name, &wp_presentation_interface, 1);
+        wp_presentation_add_listener(b->presentation, &presentation_listener, vd);
+    }
+#if HAVE_WAYLAND_SINGLE_PIXEL_BUFFER
+    else
+    if (strcmp(iface, wp_single_pixel_buffer_manager_v1_interface.name) == 0)
+        b->single_pixel_buffer_manager_v1 = wl_registry_bind(registry, name, &wp_single_pixel_buffer_manager_v1_interface, 1);
+#endif
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+    else
+    if (strcmp(iface, wp_color_representation_manager_v1_interface.name) == 0)
+    {
+        b->color_representation_manager_v1 = wl_registry_bind(registry, name, &wp_color_representation_manager_v1_interface, 1);
+        wp_color_representation_manager_v1_add_listener(b->color_representation_manager_v1, &color_representation_manager_v1_listener, vd);
+    }
+#endif
+}
+
+static void w_bound_destroy(w_bound_t * const b)
+{
+#if HAVE_WAYLAND_COLOR_REPRESENTATION
+    if (b->color_representation_manager_v1 != NULL)
+        wp_color_representation_manager_v1_destroy(b->color_representation_manager_v1);
+#endif
+    if (b->viewporter != NULL)
+        wp_viewporter_destroy(b->viewporter);
+    if (b->linux_dmabuf_v1 != NULL)
+        zwp_linux_dmabuf_v1_destroy(b->linux_dmabuf_v1);
+    if (b->subcompositor != NULL)
+        wl_subcompositor_destroy(b->subcompositor);
+    if (b->compositor != NULL)
+        wl_compositor_destroy(b->compositor);
+    if (b->shm != NULL)
+        wl_shm_destroy(b->shm);
+    if (b->presentation != NULL)
+        wp_presentation_destroy(b->presentation);
+#if HAVE_WAYLAND_SINGLE_PIXEL_BUFFER
+    if (b->single_pixel_buffer_manager_v1)
+        wp_single_pixel_buffer_manager_v1_destroy(b->single_pixel_buffer_manager_v1);
+#endif
+    memset(b, 0, sizeof(*b));
+}
+
+static void registry_global_cb(void *data, struct wl_registry *registry,
+                               uint32_t name, const char *iface, uint32_t vers)
+{
+    vout_display_t * const vd = data;
+    vout_display_sys_t * const sys = vd->sys;
+
+    w_bound_add(vd, &sys->bound, registry, name, iface, vers);
+}
+
+static void registry_global_remove_cb(void *data, struct wl_registry *registry,
+                                      uint32_t name)
+{
+    vout_display_t *vd = data;
+
+    msg_Dbg(vd, "global remove %3"PRIu32, name);
+    (void) registry;
+}
+
+static const struct wl_registry_listener registry_cbs =
+{
+    registry_global_cb,
+    registry_global_remove_cb,
+};
+
+struct registry_scan_bounce_env {
+    struct wl_registry * registry;
+    eq_env_t * const eq;
+    vout_display_t * const vd;
+};
+
+// Only safe place to add a listener is on pollq thread
+static void
+registry_scan_bounce_cb(void * v, short revents)
+{
+    struct registry_scan_bounce_env * rsbe = v;
+    (void)revents;
+    rsbe->registry = wl_display_get_registry(eq_wrapper(rsbe->eq)),
+    wl_registry_add_listener(rsbe->registry, &registry_cbs, rsbe->vd);
+}
+
+// N.B. Having got the registry with a wrapped display
+// by default everything we do with the newly bound interfaces will turn
+// up on the wrapped queue
+
+static int
+registry_scan(vout_display_t * const vd, vout_display_sys_t * const sys)
+{
+    struct registry_scan_bounce_env rsbe = {
+        .registry = NULL,
+        .eq = sys->eq,
+        .vd = vd
+    };
+
+    pollqueue_callback_once(rsbe.eq->pq, registry_scan_bounce_cb, &rsbe);
+
+    eventq_sync(rsbe.eq);
+    // Registry callback provokes shm & fmt callbacks so another sync needed
+    eventq_sync(rsbe.eq);
+
+    if (rsbe.registry == NULL)
+        return -1;
+
+    wl_registry_destroy(rsbe.registry);
+    return 0;
+}
+
+static void Close(vlc_object_t *obj)
+{
+    vout_display_t * const vd = (vout_display_t *)obj;
+    vout_display_sys_t * const sys = vd->sys;
+
+    msg_Dbg(vd, "<<< %s", __func__);
+
+    if (sys == NULL)
+        return;
+
+    if (sys->embed == NULL)
+        goto no_window;
+
+    if (bkg_surface_get_lock(vd, sys) != NULL)
+    {
+        unmap_all(sys, true);
+        bkg_surface_unlock(vd, sys);
+    }
+    else
+    {
+        unmap_all(sys, false);
+    }
+
+    // w_display/w_discard updated in unmap_all
+    if (sys->want_stats)
+        msg_stats(vd, &sys->stats);
+
+    region_destroy(&sys->region_all);
+    region_destroy(&sys->region_none);
+
+    pollqueue_finish(&sys->speq);
+
+    w_bound_destroy(&sys->bound);
+
+    eventq_sync(sys->eq);
+
+    eq_unref(&sys->eq);
+
+    // There is no guarantee that the compositor will release all buffers in
+    // a timely fashion or indeed at all before this function returns; having
+    // said that current compositors do seenm to be well behaved and return
+    // the buffer in a frame time or two.
+    // So finish the pollqueue with a shortish timeout, and if we do timeout
+    // just unref and hope that we will get the release sometime.
+    if (pollqueue_finish_timeout(&sys->pollq, 500) != 0)
+    {
+        msg_Warn(vd, "Not all buffers returned by exit time");
+        pollqueue_unref(&sys->pollq);
+    }
+
+    vout_display_DeleteWindow(vd, sys->embed);
+    sys->embed = NULL;
+
+    kill_pool(sys);
+    picpool_unref(&sys->subpic_pool);
+
+    free(sys->subpic_chromas);
+
+no_window:
+    fmt_list_uninit(&sys->dmabuf_fmts);
+    fmt_list_uninit(&sys->shm_fmts);
+
+#if CHECK_VDRE_COUNTS
+    msg_Info(vd, "%s: vdre_check_bkg: %d", __func__, atomic_load(&sys->vdre_check_bkg));
+    msg_Info(vd, "%s: vdre_check_fg: %d", __func__, atomic_load(&sys->vdre_check_fg));
+#endif
+
+    free(sys);
+
+    msg_Dbg(vd, ">>> %s", __func__);
+}
+
+static int Open(vlc_object_t *obj)
+{
+    vout_display_t * const vd = (vout_display_t *)obj;
+    vout_display_sys_t *sys;
+    fmt_list_t * flist = NULL;
+    video_format_t req_fmt;
+
+    if (!var_InheritBool(vd, WL_DMABUF_ENABLE_NAME))
+        return VLC_EGENERIC;
+
+    sys = calloc(1, sizeof(*sys));
+    if (unlikely(sys == NULL))
+        return VLC_ENOMEM;
+
+    vd->sys = sys;
+    if (fmt_list_init(&sys->dmabuf_fmts, 128)) {
+        msg_Err(vd, "Failed to allocate dmabuf format list!");
+        goto error;
+    }
+    if (fmt_list_init(&sys->shm_fmts, 32)) {
+        msg_Err(vd, "Failed to allocate shm format list!");
+        goto error;
+    }
+
+    sys->use_shm = var_InheritBool(vd, WL_DMABUF_USE_SHM_NAME);
+    sys->chequerboard = var_InheritBool(vd, WL_DMABUF_CHEQUERBOARD_NAME);
+
+        /* Get window */
+    sys->embed = vout_display_NewWindow(vd, VOUT_WINDOW_TYPE_WAYLAND);
+    if (sys->embed == NULL) {
+        msg_Dbg(vd, "Cannot create window - probably not using Wayland");
+        goto error;
+    }
+    sys->last_embed_surface = sys->embed->handle.wl;
+    sys->last_embed_seq = sys->embed->handle_seq;
+
+    msg_Info(vd, "<<< %s: %s %dx%d(%dx%d @ %d,%d %d/%d), cfg.display: %dx%d, source: %dx%d(%dx%d @ %d,%d %d/%d), scale=%d/%d", __func__,
+             drmu_log_fourcc(vd->fmt.i_chroma), vd->fmt.i_width, vd->fmt.i_height,
+             vd->fmt.i_visible_width, vd->fmt.i_visible_height, vd->fmt.i_x_offset, vd->fmt.i_y_offset,
+             vd->fmt.i_sar_num, vd->fmt.i_sar_den,
+             vd->cfg->display.width, vd->cfg->display.height,
+             vd->source.i_width, vd->source.i_height,
+             vd->source.i_visible_width, vd->source.i_visible_height, vd->source.i_x_offset, vd->source.i_y_offset,
+             vd->source.i_sar_num, vd->source.i_sar_den,
+             sys->embed->scale_num, sys->embed->scale_den);
+
+    if ((sys->pollq = pollqueue_new()) == NULL ||
+        (sys->speq = pollqueue_new()) == NULL)
+    {
+        msg_Err(vd, "Failed to create pollqueues");
+        goto error;
+    }
+    if ((sys->eq = eq_new(video_display(sys), sys->pollq)) == NULL)
+    {
+        msg_Err(vd, "Failed to create event Q");
+        goto error;
+    }
+
+    if (registry_scan(vd, sys) != 0)
+    {
+        msg_Err(vd, "Cannot get registry for display");
+        goto error;
+    }
+
+    if (sys->bound.compositor == NULL) {
+        msg_Warn(vd, "Interface %s missing", wl_compositor_interface.name);
+        goto error;
+    }
+    if (sys->bound.subcompositor == NULL) {
+        msg_Warn(vd, "Interface %s missing", wl_subcompositor_interface.name);
+        goto error;
+    }
+    if (sys->bound.viewporter == NULL) {
+        msg_Warn(vd, "Interface %s missing", wp_viewporter_interface.name);
+        goto error;
+    }
+    if (!sys->use_shm && sys->bound.linux_dmabuf_v1 == NULL) {
+        msg_Warn(vd, "Interface %s missing", zwp_linux_dmabuf_v1_interface.name);
+        goto error;
+    }
+
+    if (sys->bound.presentation == NULL)
+    {
+        msg_Warn(vd, "Interface %s missing - presentation stats not availible", wp_presentation_interface.name);
+    }
+    else
+    {
+        sys->pse = pres_stats_new(sys->eq);
+    }
+
+    fmt_list_sort(&sys->dmabuf_fmts);
+    fmt_list_sort(&sys->shm_fmts);
+    flist = sys->use_shm ? &sys->shm_fmts : &sys->dmabuf_fmts;
+
+    // Check PIC DRM format here
+    if (set_req_format(vd, sys, &req_fmt) != VLC_SUCCESS)
+        goto error;
+
+    // Get subpic format(s) - it is a list but VLC only looks at list[0]
+    {
+        static vlc_fourcc_t const tryfmts[] = {
+            VLC_CODEC_RGBA,
+            VLC_CODEC_BGRA,
+            VLC_CODEC_ARGB,
+            VLC_CODEC_VUYA,
+            VLC_CODEC_YUVA,
+        };
+        unsigned int n = 0;
+
+        if ((sys->subpic_chromas = calloc(ARRAY_SIZE(tryfmts) + 1, sizeof(vlc_fourcc_t))) == NULL)
+            goto error;
+        for (unsigned int i = 0; i != ARRAY_SIZE(tryfmts); ++i)
+        {
+            const video_frame_format_t vf = {.i_chroma = tryfmts[i]};
+            if (fmt_list_find(flist, drmu_vlc_fmt_info_find_vlc(&vf)) >= 0)
+                sys->subpic_chromas[n++] = tryfmts[i];
+        }
+
+        if (n == 0)
+            msg_Warn(vd, "No compatible subpic formats found");
+    }
+
+    {
+        struct dmabufs_ctl *dbsc = sys->use_shm ? dmabufs_shm_new() : dmabufs_ctl_new();
+        if (dbsc == NULL)
+        {
+            msg_Err(vd, "Failed to create dmabuf ctl");
+            goto error;
+        }
+        sys->subpic_pool = picpool_new(dbsc);
+        dmabufs_ctl_unref(&dbsc);
+        if (sys->subpic_pool == NULL)
+        {
+            msg_Err(vd, "Failed to create picpool");
+            goto error;
+        }
+    }
+
+    sys->bkg_w = vd->cfg->display.width;
+    sys->bkg_h = vd->cfg->display.height;
+
+    sys->region_all = wl_compositor_create_region(video_compositor(sys));
+    wl_region_add(sys->region_all, 0, 0, INT32_MAX, INT32_MAX);
+    sys->region_none = wl_compositor_create_region(video_compositor(sys));
+    wl_region_add(sys->region_all, 0, 0, 0, 0);
+
+    vd->fmt = req_fmt;
+
+    place_rects(vd, vd->cfg);
+
+    sys->want_stats = var_InheritBool(vd, WL_DMABUF_STATS_NAME);
+
+    // If we can invalidate the pic pool then DRI is disabled - we want DRI
+    vd->info = (vout_display_info_t){
+        .is_slow = false,
+        .has_double_click = false,
+        .needs_hide_mouse = false,
+        .has_pictures_invalid = false,
+        .subpicture_chromas = sys->subpic_chromas,
+    };
+
+    vd->pool = vd_dmabuf_pool;
+    vd->prepare = Prepare;
+    vd->display = Display;
+    vd->control = Control;
+
+    msg_Dbg(vd, ">>> %s: OK: %.4s (%#x/%#x/%#x)", __func__,
+            (char*)&vd->fmt.i_chroma,
+            vd->fmt.i_rmask, vd->fmt.i_gmask, vd->fmt.i_bmask);
+    return VLC_SUCCESS;
+
+error:
+    Close(obj);
+    msg_Dbg(vd, ">>> %s: ERROR", __func__);
+    return VLC_EGENERIC;
+}
+
+vlc_module_begin()
+    set_shortname(N_("WL DMABUF"))
+    set_description(N_("Wayland dmabuf video output"))
+    set_category(CAT_VIDEO)
+    set_subcategory(SUBCAT_VIDEO_VOUT)
+    set_capability("vout display", 310)
+    set_callbacks(Open, Close)
+    add_shortcut("wl-dmabuf")
+    add_bool(WL_DMABUF_ENABLE_NAME, true, WL_DMABUF_ENABLE_TEXT, WL_DMABUF_ENABLE_LONGTEXT, false)
+    add_bool(WL_DMABUF_USE_SHM_NAME, false, WL_DMABUF_USE_SHM_TEXT, WL_DMABUF_USE_SHM_LONGTEXT, false)
+    add_bool(WL_DMABUF_CHEQUERBOARD_NAME, false, WL_DMABUF_CHEQUERBOARD_TEXT, WL_DMABUF_CHEQUERBOARD_LONGTEXT, false)
+    add_bool(WL_DMABUF_STATS_NAME, false, WL_DMABUF_STATS_TEXT, WL_DMABUF_STATS_LONGTEXT, false)
+vlc_module_end()
