From b9fefb75e621246fa13066aaa52e1d0b25e19f88 Mon Sep 17 00:00:00 2001
From: John Cox <jc@kynesim.co.uk>
Date: Mon, 19 Aug 2024 17:34:18 +0100
Subject: [PATCH 38/41] wl_xdg_shell: Create an updated version of xdg-shell

xdg-shell has moved on since the previous version was written and
current exported interfaces from labwc do not include the unstable xdg
shell. This updates the calls and bindings to work again.


Upstream-Status: Inappropriate

RPI-Distro repo forks original vlc and applies patches

to enable raspiberry pi support.
---

 configure.ac                                  |   18 +
 modules/video_output/Makefile.am              |   63 +
 modules/video_output/wayland/wl_xdg_shell.c   | 1158 +++++++++++++++++
 .../wayland/wlr-layer-shell-unstable-v1.xml   |  407 ++++++
 4 files changed, 1646 insertions(+)
 create mode 100644 modules/video_output/wayland/wl_xdg_shell.c
 create mode 100644 modules/video_output/wayland/wlr-layer-shell-unstable-v1.xml

--- a/configure.ac
+++ b/configure.ac
@@ -3289,6 +3289,10 @@ have_wayland="no"
 have_wayland_egl="no"
 have_wayland_single_pixel_buffer="no"
 have_wayland_color_representation="no"
+have_wayland_cursor_shape="no"
+dnl This controls building wl_xdg_shell and isn't a simple xdg-shell exists
+dnl Pkg 1.20 is what exists in bullseye
+have_wayland_xdg_shell="no"
 
 AS_IF([test "${enable_wayland}" = "yes"], [
   PKG_CHECK_MODULES([WAYLAND_CLIENT], [wayland-client >= 1.5.91], [
@@ -3310,6 +3314,18 @@ AS_IF([test "${enable_wayland}" = "yes"]
       ], [
          AC_MSG_RESULT([no])
       ])
+      PKG_CHECK_EXISTS([wayland-protocols >= 1.20], [
+         AC_MSG_RESULT([yes])
+         have_wayland_xdg_shell="yes"
+      ], [
+         AC_MSG_RESULT([no])
+      ])
+      PKG_CHECK_EXISTS([wayland-protocols >= 1.32], [
+         AC_MSG_RESULT([yes])
+         have_wayland_cursor_shape="yes"
+      ], [
+         AC_MSG_RESULT([no])
+      ])
     ], [
       AC_MSG_RESULT([not found])
       AC_MSG_ERROR([$(${PKG_CONFIG} --print-errors 'wayland-protocols >= 1.4')])
@@ -3345,6 +3361,8 @@ AM_CONDITIONAL([HAVE_WAYLAND], [test "${
 AM_CONDITIONAL([HAVE_WAYLAND_EGL], [test "${have_wayland_egl}" = "yes"])
 AM_CONDITIONAL([HAVE_WAYLAND_SINGLE_PIXEL_BUFFER], [test "${have_wayland_single_pixel_buffer}" = "yes"])
 AM_CONDITIONAL([HAVE_WAYLAND_COLOR_REPRESENTATION], [test "${have_wayland_color_representation}" = "yes"])
+AM_CONDITIONAL([HAVE_WAYLAND_CURSOR_SHAPE], [test "${have_wayland_cursor_shape}" = "yes"])
+AM_CONDITIONAL([HAVE_WAYLAND_XDG_SHELL], [test "${have_wayland_xdg_shell}" = "yes"])
 
 
 dnl
--- a/modules/video_output/Makefile.am
+++ b/modules/video_output/Makefile.am
@@ -264,6 +264,14 @@ video_output/wayland/color-representatio
 		$(WAYLAND_PROTOCOLS)/staging/color-representation/color-representation-v1.xml
 	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header $< $@
 
+video_output/wayland/cursor-shape-v1-client-protocol.h: \
+		$(WAYLAND_PROTOCOLS)/staging/cursor-shape/cursor-shape-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header $< $@
+
+video_output/wayland/tablet-unstable-v2-client-protocol.h: \
+		$(WAYLAND_PROTOCOLS)/unstable/tablet/tablet-unstable-v2.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header $< $@
+
 libwl_dmabuf_plugin_la_SOURCES = video_output/wayland/wl_dmabuf.c\
 	video_output/wayland/picpool.c video_output/wayland/picpool.h\
 	video_output/wayland/dmabuf_alloc.c video_output/wayland/dmabuf_alloc.h\
@@ -331,6 +339,57 @@ video_output/wayland/xdg-shell-unstable-
 		$(WAYLAND_PROTOCOLS)/unstable/xdg-shell/xdg-shell-unstable-v5.xml
 	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code $< $@
 
+video_output/wayland/xdg-decoration-unstable-v1-client-protocol.h: \
+		$(WAYLAND_PROTOCOLS)/unstable/xdg-decoration/xdg-decoration-unstable-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header $< $@
+video_output/wayland/xdg-decoration-unstable-v1-protocol.c: \
+		$(WAYLAND_PROTOCOLS)/unstable/xdg-decoration/xdg-decoration-unstable-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code $< $@
+
+video_output/wayland/wlr-layer-shell-unstable-v1-client-protocol.h: \
+		video_output/wayland/wlr-layer-shell-unstable-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header $< $@
+video_output/wayland/wlr-layer-shell-unstable-v1-protocol.c: \
+		video_output/wayland/wlr-layer-shell-unstable-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code $< $@
+
+libwl_xdg_shell_plugin_la_SOURCES = video_output/wayland/wl_xdg_shell.c
+nodist_libwl_xdg_shell_plugin_la_SOURCES = \
+	video_output/wayland/xdg-shell-client-protocol.h \
+	video_output/wayland/xdg-shell-protocol.c \
+	video_output/wayland/xdg-decoration-unstable-v1-client-protocol.h \
+	video_output/wayland/xdg-decoration-unstable-v1-protocol.c \
+	video_output/wayland/wlr-layer-shell-unstable-v1-client-protocol.h \
+	video_output/wayland/wlr-layer-shell-unstable-v1-protocol.c
+libwl_xdg_shell_plugin_la_CPPFLAGS = $(AM_CPPFLAGS) \
+	-I$(builddir)/video_output/wayland
+libwl_xdg_shell_plugin_la_CFLAGS = $(WAYLAND_CLIENT_CFLAGS)
+libwl_xdg_shell_plugin_la_LIBADD = $(WAYLAND_CLIENT_LIBS) $(LIBPTHREAD)
+
+if HAVE_WAYLAND_CURSOR_SHAPE
+video_output/wayland/cursor-shape-v1-protocol.c: \
+		$(WAYLAND_PROTOCOLS)/staging/cursor-shape/cursor-shape-v1.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code $< $@
+# Cursor shape needs this too - wayland dependency fail!
+video_output/wayland/tablet-unstable-v2-protocol.c: \
+		$(WAYLAND_PROTOCOLS)/unstable/tablet/tablet-unstable-v2.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code $< $@
+
+nodist_libwl_xdg_shell_plugin_la_SOURCES +=\
+	video_output/wayland/tablet-unstable-v2-client-protocol.h \
+	video_output/wayland/tablet-unstable-v2-protocol.c \
+	video_output/wayland/cursor-shape-v1-client-protocol.h \
+	video_output/wayland/cursor-shape-v1-protocol.c
+libwl_xdg_shell_plugin_la_CFLAGS += -DHAVE_WAYLAND_CURSOR_SHAPE=1
+endif
+
+video_output/wayland/xdg-shell-client-protocol.h: \
+		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) client-header $< $@
+video_output/wayland/xdg-shell-protocol.c: \
+		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml
+	$(AM_V_GEN)$(WAYLAND_SCANNER) private-code $< $@
+
 video_output/wayland/server-decoration-client-protocol.h: \
 		video_output/wayland/server-decoration.xml
 video_output/wayland/server-decoration-protocol.c: \
@@ -350,6 +409,10 @@ vout_LTLIBRARIES += libwl_dmabuf_plugin.
 vout_LTLIBRARIES += libwl_shell_plugin.la
 BUILT_SOURCES += $(nodist_libxdg_shell_plugin_la_SOURCES)
 vout_LTLIBRARIES += libxdg_shell_plugin.la
+if HAVE_WAYLAND_XDG_SHELL
+BUILT_SOURCES += $(nodist_libwl_xdg_shell_plugin_la_SOURCES)
+vout_LTLIBRARIES += libwl_xdg_shell_plugin.la
+endif
 if HAVE_WAYLAND_EGL
 if HAVE_EGL
 vout_LTLIBRARIES += libegl_wl_plugin.la
--- /dev/null
+++ b/modules/video_output/wayland/wl_xdg_shell.c
@@ -0,0 +1,1158 @@
+/**
+ * @file xdg-shell.c
+ * @brief XDG shell surface provider module for VLC media player
+ */
+/*****************************************************************************
+ * Copyright © 2014, 2017 Rémi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <string.h>
+#include <poll.h>
+
+#include <wayland-client.h>
+#include "xdg-shell-client-protocol.h"
+#ifdef HAVE_WAYLAND_CURSOR_SHAPE
+#include "cursor-shape-v1-client-protocol.h"
+#include "tablet-unstable-v2-client-protocol.h"
+#endif
+#include "xdg-decoration-unstable-v1-client-protocol.h"
+#include "wlr-layer-shell-unstable-v1-client-protocol.h"
+
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_vout_window.h>
+
+#ifndef MIN
+#define MIN(a,b) ((a)<(b)?(a):(b))
+#endif
+
+#define WL_XDG_SHELL_NAME "wl-xdg-shell"
+#define WL_XDG_SHELL_TEXT N_("WL XDG Shell enable")
+#define WL_XDG_SHELL_LONGTEXT N_("WL XDG Shell enable/disable; enabled by default. "\
+    "Use --no-wl-xdg-shell to disable. This provides a simple wayland window " \
+    " if something like Qt isn't in use, and works with command-line VLCs.")
+
+#define DISPLAY_NAME "wl-display"
+#define DISPLAY_TEXT N_("Wayland display")
+#define DISPLAY_LONGTEXT N_( \
+    "Video will be rendered with this Wayland display. " \
+    "If unset the WAYLAND_DISPLAY environment variable will be used; " \
+    "if both unset then wl-xdg-shell will be disabled. " \
+    "Special values are: \"auto\": use default; \"none\": disable.")
+
+#define LAYER_NAME "wl-layer-pos"
+#define LAYER_TEXT "Create window using layer-shell"
+#define LAYER_LONGTEXT "Use wlr-layer-shell rather than xdg-shell. This " \
+    "(probably) allows positioning via --video-x,--video-y to work, but the " \
+    "window has a fixed Z which will either be on top of all normal windows " \
+    "or behind them and likely won't decorate."
+
+
+struct vout_window_sys_t
+{
+    struct wl_compositor *compositor;
+    struct wl_output *output;
+    struct xdg_wm_base *shell;
+    struct zwlr_layer_shell_v1 *layer_shell;
+    struct wl_surface *wl_surface;
+    struct xdg_surface *xdg_surface;  // Only one of xdg_surface & layer_surface should be in use
+    struct xdg_toplevel *toplevel;
+    struct zwlr_layer_surface_v1 *layer_surface;
+    struct zxdg_decoration_manager_v1 *decoration_manager;
+
+    struct wl_seat *wl_seat;
+    struct wl_pointer *wl_pointer;
+#ifdef WP_CURSOR_SHAPE_DEVICE_V1_INTERFACE
+    struct wp_cursor_shape_manager_v1 *cursor_shape_manager;
+    struct wp_cursor_shape_device_v1 *cursor_shape_device;
+#endif
+
+    vlc_mutex_t lock;
+    vlc_cond_t cond;
+
+    bool use_layer;
+    bool config1_done;
+
+    uint32_t pointer_enter_serial;
+
+    bool req_fullscreen;
+    uint32_t output_width;
+    uint32_t output_height;
+
+    // 0   Off
+    // 1   On
+    // -1  Off until 1st movement
+    int req_cursor;
+    unsigned int req_width;
+    unsigned int req_height;
+
+    unsigned int conf_width;
+    unsigned int conf_height;
+
+    bool thread_ok;
+    vlc_thread_t thread;
+};
+
+static void cleanup_wl_display_read(void *data)
+{
+    struct wl_display *display = data;
+
+    wl_display_cancel_read(display);
+}
+
+/** Background thread for Wayland shell events handling */
+static void *Thread(void *data)
+{
+    vout_window_t *wnd = data;
+    struct wl_display *display = wnd->display.wl;
+    struct pollfd ufd[1];
+
+    int canc = vlc_savecancel();
+    vlc_cleanup_push(cleanup_wl_display_read, display);
+
+    ufd[0].fd = wl_display_get_fd(display);
+    ufd[0].events = POLLIN;
+
+    for (;;)
+    {
+        while (wl_display_prepare_read(display) != 0)
+            wl_display_dispatch_pending(display);
+
+        wl_display_flush(display);
+        vlc_restorecancel(canc);
+
+        while (poll(ufd, 1, -1) < 0);
+
+        canc = vlc_savecancel();
+        wl_display_read_events(display);
+        wl_display_dispatch_pending(display);
+    }
+    vlc_assert_unreachable();
+    vlc_cleanup_pop();
+    //vlc_restorecancel(canc);
+    //return NULL;
+}
+
+static void
+set_cursor(vout_window_t * const wnd, vout_window_sys_t * const sys)
+{
+    if (!sys->wl_pointer)
+        return;
+#ifdef WP_CURSOR_SHAPE_DEVICE_V1_INTERFACE
+    if (sys->req_cursor > 0 && sys->cursor_shape_device != NULL)
+        wp_cursor_shape_device_v1_set_shape(sys->cursor_shape_device,
+                                            sys->pointer_enter_serial,
+                                            WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DEFAULT);
+    else
+#endif
+        wl_pointer_set_cursor(sys->wl_pointer, sys->pointer_enter_serial, NULL, 0, 0);
+    wl_display_flush(wnd->display.wl);
+}
+
+static void
+set_fullscreen(vout_window_sys_t *sys, bool fs)
+{
+    sys->req_fullscreen = fs;
+    if (fs)
+        xdg_toplevel_set_fullscreen(sys->toplevel, NULL);
+    else {
+        xdg_toplevel_unset_fullscreen(sys->toplevel);
+        xdg_surface_set_window_geometry(sys->xdg_surface, 0, 0, sys->req_width, sys->req_height);
+    }
+}
+
+static int Control(vout_window_t *wnd, int cmd, va_list ap)
+{
+    vout_window_sys_t *sys = wnd->sys;
+    struct wl_display *display = wnd->display.wl;
+
+    switch (cmd)
+    {
+        case VOUT_WINDOW_SET_STATE:
+            return VLC_EGENERIC;
+
+        case VOUT_WINDOW_SET_SIZE:
+        {
+            unsigned width = va_arg(ap, unsigned);
+            unsigned height = va_arg(ap, unsigned);
+
+            msg_Dbg(wnd, "Set size: %dx%d", width, height);
+            if (width == sys->req_width && height == sys->req_height)
+                break;
+            sys->req_width = width;
+            sys->req_height = height;
+            if (sys->req_fullscreen)
+                break;
+
+            if (sys->xdg_surface)
+                xdg_surface_set_window_geometry(sys->xdg_surface, 0, 0, width, height);
+            wl_surface_commit(wnd->handle.wl);
+            break;
+        }
+
+        case VOUT_WINDOW_SET_FULLSCREEN:
+        {
+            bool fs = va_arg(ap, int);
+            msg_Dbg(wnd, "Set fullscreen: %d->%d", sys->req_fullscreen, fs);
+
+            if (sys->req_fullscreen == fs || sys->use_layer)
+                break;
+
+            set_fullscreen(sys, fs);
+            wl_surface_commit(wnd->handle.wl);
+            break;
+        }
+
+        case VOUT_WINDOW_HIDE_MOUSE: /* int b_hide */
+        {
+            const bool hide_req = va_arg(ap, int);
+            vlc_mutex_lock(&sys->lock);
+            sys->req_cursor = !hide_req;
+            set_cursor(wnd, sys);
+            vlc_mutex_unlock(&sys->lock);
+            break;
+        }
+
+        default:
+            msg_Err(wnd, "request %d not implemented", cmd);
+            return VLC_EGENERIC;
+    }
+
+    wl_display_flush(display);
+    return VLC_SUCCESS;
+}
+
+// ---------------------------------------------------------------------------
+
+static void decoration_manager_destroy(struct zxdg_decoration_manager_v1 **ppDecoration_manager)
+{
+    struct zxdg_decoration_manager_v1 *decoration_manager = *ppDecoration_manager;
+    if (decoration_manager == NULL)
+        return;
+    *ppDecoration_manager = NULL;
+    zxdg_decoration_manager_v1_destroy(decoration_manager);
+}
+
+static void
+decoration_configure_cb(void *data,
+                        struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1,
+                        uint32_t mode)
+{
+    vout_window_t *const wnd = data;
+
+    msg_Dbg(wnd, "%s: mode %d", __func__, mode);
+    zxdg_toplevel_decoration_v1_destroy(zxdg_toplevel_decoration_v1);
+}
+
+static struct zxdg_toplevel_decoration_v1_listener decoration_listener = {
+    .configure = decoration_configure_cb,
+};
+
+// ---------------------------------------------------------------------------
+//
+// XDG Toplevel callbacks
+// Mostly ignored - except resize
+
+static void
+xdg_toplevel_configure_cb(void *data,
+                          struct xdg_toplevel *xdg_toplevel, int32_t w, int32_t h,
+                          struct wl_array *states)
+{
+    vout_window_t *const wnd = data;
+    vout_window_sys_t *const sys = wnd->sys;
+
+    enum xdg_toplevel_state *p;
+    msg_Dbg(wnd, "%s: %dx%d", __func__, w, h);
+    wl_array_for_each(p, states) {
+        msg_Dbg(wnd, "    State: %d", *p);
+    }
+
+    (void)xdg_toplevel;
+    (void)states;
+
+    // no window geometry event, ignore
+    if (w <= 0 || h <= 0)
+        return;
+
+    msg_Dbg(wnd, "%s: Width=%"PRId32", Height=%"PRId32, __func__, w, h);
+    sys->conf_width = w;
+    sys->conf_height = h;
+}
+
+static void
+xdg_toplevel_close_cb(void *data, struct xdg_toplevel *xdg_toplevel)
+{
+    vout_window_t *const wnd = data;
+    (void)xdg_toplevel;
+
+    msg_Dbg(wnd, "%s", __func__);
+    vout_window_ReportClose(wnd);
+}
+
+#ifdef XDG_TOPLEVEL_CONFIGURE_BOUNDS_SINCE_VERSION
+static void
+xdg_toplevel_configure_bounds_cb(void *data,
+                                 struct xdg_toplevel *xdg_toplevel,
+                                 int32_t width, int32_t height)
+{
+    vout_window_t *const wnd = data;
+    (void)data;
+    (void)xdg_toplevel;
+    (void)width;
+    (void)height;
+    msg_Dbg(wnd, "%s: %dx%d", __func__, width, height);
+}
+#endif
+
+#ifdef XDG_TOPLEVEL_WM_CAPABILITIES_SINCE_VERSION
+static void
+xdg_toplevel_wm_capabilities_cb(void *data,
+                                struct xdg_toplevel *xdg_toplevel,
+                                struct wl_array *capabilities)
+{
+    (void)data;
+    (void)xdg_toplevel;
+    (void)capabilities;
+}
+#endif
+
+static const struct xdg_toplevel_listener xdg_toplevel_listener = {
+    .configure = xdg_toplevel_configure_cb,
+    .close = xdg_toplevel_close_cb,
+#ifdef XDG_TOPLEVEL_CONFIGURE_BOUNDS_SINCE_VERSION
+    .configure_bounds = xdg_toplevel_configure_bounds_cb,
+#endif
+#ifdef XDG_TOPLEVEL_WM_CAPABILITIES_SINCE_VERSION
+    .wm_capabilities = xdg_toplevel_wm_capabilities_cb,
+#endif
+};
+
+// ---------------------------------------------------------------------------
+
+static void
+xdg_surface_configure_cb(void *data, struct xdg_surface *xdg_surface, uint32_t serial)
+{
+    vout_window_t *const wnd = data;
+    vout_window_sys_t *const sys = wnd->sys;
+
+    msg_Dbg(wnd, "new configuration: (serial: %"PRIu32", %dx%d)", serial, sys->conf_width, sys->conf_height);
+
+    /* Zero width or zero height means client (we) should choose.
+     * DO NOT REPORT those values to video output... */
+    if (sys->conf_width != 0 && sys->conf_height != 0)
+        vout_window_ReportSize(wnd, sys->conf_width, sys->conf_height);
+    else if (sys->req_fullscreen)
+    {
+        msg_Dbg(wnd, "Use fullscreen size %dx%d", sys->output_width, sys->output_height);
+        vout_window_ReportSize(wnd, sys->output_width, sys->output_height);
+    }
+
+    sys->conf_width = 0;
+    sys->conf_height = 0;
+
+    /* TODO: report fullscreen state, not implemented in VLC */
+    xdg_surface_ack_configure(xdg_surface, serial);
+
+    if (!sys->config1_done)
+    {
+        sys->config1_done = true;
+        vlc_cond_broadcast(&sys->cond);
+    }
+}
+
+static const struct xdg_surface_listener xdg_surface_cbs =
+{
+    xdg_surface_configure_cb,
+};
+
+static void xdg_shell_ping_cb(void *data, struct xdg_wm_base *shell,
+                              uint32_t serial)
+{
+    (void) data;
+    xdg_wm_base_pong(shell, serial);
+}
+
+static const struct xdg_wm_base_listener xdg_shell_cbs =
+{
+    xdg_shell_ping_cb,
+};
+
+// ----------------------------------------------------------------------------
+
+static void layer_surface_configure(void * data, struct zwlr_layer_surface_v1 * layer_surface, uint32_t serial, uint32_t w, uint32_t h)
+{
+    vout_window_t * const wnd = data;
+    vout_window_sys_t * const sys = wnd->sys;
+
+    msg_Info(wnd, "%s: ser: %d, %dx%d", __func__, serial, w, h);
+
+    if (w != 0 && h != 0)
+        vout_window_ReportSize(wnd, w, h);
+
+    zwlr_layer_surface_v1_ack_configure(layer_surface, serial);
+
+    if (!sys->config1_done)
+    {
+        sys->config1_done = true;
+        vlc_cond_broadcast(&sys->cond);
+    }
+}
+
+static void layer_surface_closed(void * data, struct zwlr_layer_surface_v1 * layer_surface)
+{
+    vout_window_t *wnd = data;
+    VLC_UNUSED(layer_surface);
+
+    msg_Info(wnd, "%s", __func__);
+    vout_window_ReportClose(wnd);
+}
+
+static const struct zwlr_layer_surface_v1_listener layer_surface_cbs =
+{
+    .configure = layer_surface_configure,
+    .closed = layer_surface_closed,
+};
+
+// ----------------------------------------------------------------------------
+//
+// Mouse
+
+static void
+pointer_destroy(struct wl_pointer **ppPointer)
+{
+    struct wl_pointer * const p = *ppPointer;
+    if (p == NULL)
+        return;
+    *ppPointer = NULL;
+    wl_pointer_destroy(p);
+}
+
+#ifdef WP_CURSOR_SHAPE_DEVICE_V1_INTERFACE
+static void
+cursor_shape_manager_destroy(struct wp_cursor_shape_manager_v1 **ppCursor_shape_manager)
+{
+    struct wp_cursor_shape_manager_v1 * const p = *ppCursor_shape_manager;
+    if (p == NULL)
+        return;
+    *ppCursor_shape_manager = NULL;
+    wp_cursor_shape_manager_v1_destroy(p);
+}
+
+static void
+cursor_shape_device_destroy(struct wp_cursor_shape_device_v1 **ppCursor_shape_device)
+{
+    struct wp_cursor_shape_device_v1 * const p = *ppCursor_shape_device;
+    if (p == NULL)
+        return;
+    *ppCursor_shape_device = NULL;
+    wp_cursor_shape_device_v1_destroy(p);
+}
+#else
+// Avoid having to ifdef these on use
+#define cursor_shape_manager_destroy(x)
+#define cursor_shape_device_destroy(x)
+#endif
+
+static void pointer_enter_cb(void *data,
+          struct wl_pointer *wl_pointer,
+          uint32_t serial,
+          struct wl_surface *surface,
+          wl_fixed_t surface_x,
+          wl_fixed_t surface_y)
+{
+    vout_window_t * const wnd = data;
+    vout_window_sys_t * const sys = wnd->sys;
+
+    if (surface != wnd->handle.wl)
+    {
+        msg_Warn(wnd, "%s: Surface mismatch", __func__);
+        return;
+    }
+
+    if (wl_pointer != sys->wl_pointer)
+    {
+        msg_Warn(wnd, "%s: Pointer mismatch", __func__);
+    }
+    else
+    {
+        vlc_mutex_lock(&sys->lock);
+        sys->pointer_enter_serial = serial;
+        set_cursor(wnd, sys);
+        vlc_mutex_unlock(&sys->lock);
+    }
+
+    vout_window_ReportMouseMoved(wnd, wl_fixed_to_int(surface_x), wl_fixed_to_int(surface_y));
+
+    msg_Dbg(wnd, "%s[%u]: @%d,%d", __func__, serial, wl_fixed_to_int(surface_x), wl_fixed_to_int(surface_y));
+}
+
+static void pointer_leave_cb(void *data,
+          struct wl_pointer *wl_pointer,
+          uint32_t serial,
+          struct wl_surface *surface)
+{
+    vout_window_t * const wnd = data;
+
+    VLC_UNUSED(data);
+    VLC_UNUSED(wl_pointer);
+    VLC_UNUSED(serial);
+    VLC_UNUSED(surface);
+
+    msg_Dbg(wnd, "%s[%u]", __func__, serial);
+}
+
+static void pointer_motion_cb(void *data,
+           struct wl_pointer *wl_pointer,
+           uint32_t time,
+           wl_fixed_t surface_x,
+           wl_fixed_t surface_y)
+{
+    vout_window_t * const wnd = data;
+    vout_window_sys_t * const sys = wnd->sys;
+
+    if (sys->req_cursor < 0)
+    {
+        vlc_mutex_lock(&sys->lock);
+        if (sys->req_cursor < 0)
+            sys->req_cursor = 1;
+        set_cursor(wnd, sys);
+        vlc_mutex_unlock(&sys->lock);
+    }
+
+    VLC_UNUSED(wl_pointer);
+    VLC_UNUSED(time);
+
+    vout_window_ReportMouseMoved(wnd, wl_fixed_to_int(surface_x), wl_fixed_to_int(surface_y));
+//    msg_Dbg(wnd, "%s: @%d,%d", __func__, wl_fixed_to_int(surface_x), wl_fixed_to_int(surface_y));
+}
+
+static void 
+pointer_button_cb(void *data,
+           struct wl_pointer *wl_pointer,
+           uint32_t serial,
+           uint32_t time,
+           uint32_t button,
+           uint32_t state)
+{
+    vout_window_t * const wnd = data;
+
+    // The button is a button code as defined in the Linux kernel's
+    // linux/input-event-codes.h header file, e.g. BTN_LEFT.
+
+    VLC_UNUSED(wl_pointer);
+    VLC_UNUSED(serial);
+    VLC_UNUSED(time);
+
+    if (state == WL_POINTER_BUTTON_STATE_RELEASED)
+        vout_window_ReportMouseReleased(wnd, button);
+    else if (state == WL_POINTER_BUTTON_STATE_PRESSED)
+        vout_window_ReportMousePressed(wnd, button);
+
+    msg_Dbg(wnd, "%s: Button %d, State: %d", __func__, button, state);
+}
+
+static void pointer_axis_cb(void *data,
+         struct wl_pointer *wl_pointer,
+         uint32_t time,
+         uint32_t axis,
+         wl_fixed_t value)
+{
+    VLC_UNUSED(data);
+    VLC_UNUSED(wl_pointer);
+    VLC_UNUSED(time);
+    VLC_UNUSED(axis);
+    VLC_UNUSED(value);
+}
+
+static void pointer_frame_cb(void *data,
+          struct wl_pointer *wl_pointer)
+{
+    // Maybe accumulate pointer & buttons then report in bulk here?
+    VLC_UNUSED(data);
+    VLC_UNUSED(wl_pointer);
+}
+
+static void
+pointer_axis_source_cb(void *data,
+            struct wl_pointer *wl_pointer,
+            uint32_t axis_source)
+{
+    VLC_UNUSED(data);
+    VLC_UNUSED(wl_pointer);
+    VLC_UNUSED(axis_source);
+}
+
+static void
+pointer_axis_stop_cb(void *data,
+          struct wl_pointer *wl_pointer,
+          uint32_t time,
+          uint32_t axis)
+{
+    VLC_UNUSED(data);
+    VLC_UNUSED(wl_pointer);
+    VLC_UNUSED(time);
+    VLC_UNUSED(axis);
+}
+
+static void
+pointer_axis_discrete_cb(void *data,
+              struct wl_pointer *wl_pointer,
+              uint32_t axis,
+              int32_t discrete)
+{
+    VLC_UNUSED(data);
+    VLC_UNUSED(wl_pointer);
+    VLC_UNUSED(axis);
+    VLC_UNUSED(discrete);
+}
+
+#ifdef WL_POINTER_AXIS_VALUE120_SINCE_VERSION
+static void pointer_axis_value120_cb(void *data,
+              struct wl_pointer *wl_pointer,
+              uint32_t axis,
+              int32_t value120)
+{
+    VLC_UNUSED(data);
+    VLC_UNUSED(wl_pointer);
+    VLC_UNUSED(axis);
+    VLC_UNUSED(value120);
+}
+#endif
+
+#ifdef WL_POINTER_AXIS_RELATIVE_DIRECTION_SINCE_VERSION
+static void pointer_axis_relative_direction_cb(void *data,
+                struct wl_pointer *wl_pointer,
+                uint32_t axis,
+                uint32_t direction)
+{
+    VLC_UNUSED(data);
+    VLC_UNUSED(wl_pointer);
+    VLC_UNUSED(axis);
+    VLC_UNUSED(direction);
+}
+#endif
+
+static const struct wl_pointer_listener pointer_cbs = {
+    .enter = pointer_enter_cb,
+    .leave = pointer_leave_cb,
+    .motion = pointer_motion_cb,
+    .button = pointer_button_cb,
+    .axis = pointer_axis_cb,
+    .frame = pointer_frame_cb,
+    .axis_source = pointer_axis_source_cb,
+    .axis_stop = pointer_axis_stop_cb,
+    .axis_discrete = pointer_axis_discrete_cb,
+#ifdef WL_POINTER_AXIS_VALUE120_SINCE_VERSION
+    .axis_value120 = pointer_axis_value120_cb,
+#endif
+#ifdef WL_POINTER_AXIS_RELATIVE_DIRECTION_SINCE_VERSION
+    .axis_relative_direction = pointer_axis_relative_direction_cb,
+#endif
+};
+
+static void
+seat_capabilities_cb(void *data, struct wl_seat *wl_seat, uint32_t capabilities)
+{
+    vout_window_t * const wnd = data;
+    vout_window_sys_t * const sys = wnd->sys;
+    VLC_UNUSED(wl_seat);
+    msg_Dbg(wnd, "%s: Caps: %#"PRIx32, __func__, capabilities);
+
+    if ((capabilities & WL_SEAT_CAPABILITY_POINTER) != 0)
+    {
+        if (sys->wl_pointer != NULL)
+            /* Do nothing */;
+        else if ((sys->wl_pointer = wl_seat_get_pointer(wl_seat)) == NULL)
+            msg_Dbg(wnd, "%s: Ponter capability but no pointer", __func__);
+        else
+        {
+            wl_pointer_add_listener(sys->wl_pointer, &pointer_cbs, wnd);
+#ifdef WP_CURSOR_SHAPE_DEVICE_V1_INTERFACE
+            if (sys->cursor_shape_manager != NULL)
+                sys->cursor_shape_device = wp_cursor_shape_manager_v1_get_pointer(sys->cursor_shape_manager, sys->wl_pointer);
+#endif
+        }
+    }
+    else
+    {
+        cursor_shape_device_destroy(&sys->cursor_shape_device);
+        pointer_destroy(&sys->wl_pointer);
+    }
+}
+
+static void
+seat_name_cb(void *data, struct wl_seat *wl_seat, const char *name)
+{
+    vout_window_t * const wnd = data;
+    VLC_UNUSED(wl_seat);
+    msg_Dbg(wnd, "%s: %s", __func__, name);
+}
+
+static const struct wl_seat_listener seat_cbs = {
+    .capabilities = seat_capabilities_cb,
+    .name = seat_name_cb
+};
+
+// ----------------------------------------------------------------------------
+//
+// Get output info
+//
+// Maybe don't need/want this. It is an attempt to get the fullscreen size out
+// earlier due to XDG apparently requiring a buffer attached before the
+// fullscreen config occurs.
+//
+// If XDG did what I think it should (i.e. return the size before a buffer is
+// attached so you can size the buffer correctly) this would be completely
+// redundant
+
+static void
+output_destroy(struct wl_output ** const ppOutput)
+{
+    struct wl_output * const output = *ppOutput;
+
+    if (output == NULL)
+        return;
+    *ppOutput = NULL;
+    wl_output_destroy(output);
+}
+
+static void
+output_geometry_cb(void *data,
+                   struct wl_output *wl_output,
+                   int32_t x,
+                   int32_t y,
+                   int32_t physical_width,
+                   int32_t physical_height,
+                   int32_t subpixel,
+                   const char *make,
+                   const char *model,
+                   int32_t transform)
+{
+    vout_window_t *const wnd = data;
+    VLC_UNUSED(wl_output);
+    msg_Dbg(wnd, "%s: @%d,%d, %dx%dmm, subpixel %d, make='%s', model='%s', transform=%d", __func__,
+            x, y, physical_width, physical_height,
+            subpixel, make, model, transform);
+}
+
+static void
+output_mode_cb(void *data,
+               struct wl_output *wl_output,
+               uint32_t flags,
+               int32_t width,
+               int32_t height,
+               int32_t refresh)
+{
+    vout_window_t *const wnd = data;
+    vout_window_sys_t * const sys = wnd->sys;
+    VLC_UNUSED(wl_output);
+
+    sys->output_width = width;
+    sys->output_height = height;
+
+    msg_Dbg(wnd, "%s: flags=%#x %dx%dpels, refresh=%d", __func__,
+            flags, width, height, refresh);
+}
+
+static void
+output_done_cb(void *data,
+               struct wl_output *wl_output)
+{
+    vout_window_t *const wnd = data;
+    VLC_UNUSED(wl_output);
+    msg_Dbg(wnd, "%s", __func__);
+}
+
+static void
+output_scale_cb(void *data,
+                struct wl_output *wl_output,
+                int32_t factor)
+{
+    vout_window_t *const wnd = data;
+    VLC_UNUSED(wl_output);
+    msg_Dbg(wnd, "%s: %d", __func__, factor);
+}
+
+static void
+output_name_cb(void *data,
+               struct wl_output *wl_output,
+               const char *name)
+{
+    vout_window_t *const wnd = data;
+    VLC_UNUSED(wl_output);
+    msg_Dbg(wnd, "%s: %s", __func__, name);
+}
+
+static void
+output_description_cb(void *data,
+                      struct wl_output *wl_output,
+                      const char *description)
+{
+    vout_window_t *const wnd = data;
+    VLC_UNUSED(wl_output);
+    msg_Dbg(wnd, "%s: %s", __func__, description);
+}
+
+static const struct wl_output_listener output_cbs =
+{
+    .geometry = output_geometry_cb,
+    .mode = output_mode_cb,
+    .done = output_done_cb,
+    .scale = output_scale_cb,
+    .name = output_name_cb,
+    .description = output_description_cb,
+};
+
+// ----------------------------------------------------------------------------
+
+static void registry_global_cb(void *data, struct wl_registry *registry,
+                               uint32_t name, const char *iface, uint32_t vers)
+{
+    vout_window_t *wnd = data;
+    vout_window_sys_t *sys = wnd->sys;
+
+    msg_Dbg(wnd, "global %3"PRIu32": %s version %"PRIu32, name, iface, vers);
+
+    if (!strcmp(iface, wl_compositor_interface.name))
+    {
+        sys->compositor = wl_registry_bind(registry, name,
+                                           &wl_compositor_interface, MIN(6, vers));
+    } else
+    if (!strcmp(iface, xdg_wm_base_interface.name))
+    {
+        sys->shell = wl_registry_bind(registry, name, &xdg_wm_base_interface, 1);
+        xdg_wm_base_add_listener(sys->shell, &xdg_shell_cbs, wnd);
+    } else
+    if (!strcmp(iface, wl_output_interface.name) && vers >= 3)
+    {
+        sys->output = wl_registry_bind(registry, name, &wl_output_interface, MIN(4, vers));
+        wl_output_add_listener(sys->output, &output_cbs, wnd);
+    } else
+    if (!strcmp(iface, wl_seat_interface.name) && vers >= 5)
+    {
+        sys->wl_seat = wl_registry_bind(registry, name, &wl_seat_interface, MIN(9, vers));
+        wl_seat_add_listener(sys->wl_seat, &seat_cbs, wnd);
+    } else
+    if (!strcmp(iface, zwlr_layer_shell_v1_interface.name))
+    {
+        sys->layer_shell = wl_registry_bind(registry, name, &zwlr_layer_shell_v1_interface, MIN(5, vers));
+    } else
+#ifdef WP_CURSOR_SHAPE_DEVICE_V1_INTERFACE
+    if (!strcmp(iface, wp_cursor_shape_manager_v1_interface.name))
+    {
+        sys->cursor_shape_manager = wl_registry_bind(registry, name, &wp_cursor_shape_manager_v1_interface, 1);
+    } else
+#endif
+    if (strcmp(iface, zxdg_decoration_manager_v1_interface.name) == 0)
+    {
+        sys->decoration_manager = wl_registry_bind(registry, name, &zxdg_decoration_manager_v1_interface, 1);
+    }
+}
+
+static void registry_global_remove_cb(void *data, struct wl_registry *registry,
+                                      uint32_t name)
+{
+    vout_window_t *wnd = data;
+
+    msg_Dbg(wnd, "global remove %3"PRIu32, name);
+    (void) registry;
+}
+
+static const struct wl_registry_listener registry_cbs =
+{
+    registry_global_cb,
+    registry_global_remove_cb,
+};
+
+static void
+layer_shell_destroy(struct zwlr_layer_shell_v1 ** ppLayer_shell)
+{
+    struct zwlr_layer_shell_v1 * const layer_shell = *ppLayer_shell;
+    *ppLayer_shell = NULL;
+    if (layer_shell)
+        zwlr_layer_shell_v1_destroy(layer_shell);
+}
+
+static void
+layer_surface_destroy(struct zwlr_layer_surface_v1 ** ppLayer_surface)
+{
+    struct zwlr_layer_surface_v1 * const layer_surface = *ppLayer_surface;
+    *ppLayer_surface = NULL;
+    if (layer_surface)
+        zwlr_layer_surface_v1_destroy(layer_surface);
+}
+
+// Look for a wayland display name first in an explicit option then in the
+// environment
+static struct wl_display *
+get_wl_display(vout_window_t * const wnd)
+{
+    char *const dpy_opt = var_InheritString(wnd, DISPLAY_NAME);
+    char * dpy_name = dpy_opt;
+    struct wl_display * display;
+
+    if (dpy_name == NULL)
+        dpy_name = getenv("WAYLAND_DISPLAY");
+    if (dpy_name == NULL || strcmp(dpy_name, "none") == 0)
+        return NULL;
+
+    if ((display = wl_display_connect(strcmp(dpy_name, "auto") == 0 ? NULL : dpy_name)) == NULL)
+        msg_Warn(wnd, "WL XDG No display: '%s'", dpy_name);
+
+    free(dpy_opt);
+    return display;
+}
+
+static int
+wants_layer_shell(vout_window_t * const wnd, vout_window_sys_t * const sys)
+{
+    const bool wants_layer = var_InheritBool(wnd, LAYER_NAME);
+
+    if (!wants_layer)
+        return false;
+
+    if (sys->layer_shell == NULL)
+    {
+        msg_Err(wnd, "WLR Layer Shell not supported on this system");
+        return false;
+    }
+
+    return true;
+}
+
+/**
+ * Destroys a XDG shell surface.
+ */
+static void Close(vout_window_t *wnd)
+{
+    vout_window_sys_t *sys = wnd->sys;
+
+    if (sys->thread_ok)
+    {
+        vlc_cancel(sys->thread);
+        vlc_join(sys->thread, NULL);
+    }
+
+    if (sys->toplevel)
+        xdg_toplevel_destroy(sys->toplevel);
+    if (sys->xdg_surface)
+        xdg_surface_destroy(sys->xdg_surface);
+    layer_surface_destroy(&sys->layer_surface);
+    if (wnd->handle.wl) {
+        wl_surface_destroy(wnd->handle.wl);
+        wnd->handle.wl = NULL;
+    }
+    decoration_manager_destroy(&sys->decoration_manager);
+    if (sys->shell)
+        xdg_wm_base_destroy(sys->shell);
+    cursor_shape_device_destroy(&sys->cursor_shape_device);
+    pointer_destroy(&sys->wl_pointer);
+    cursor_shape_manager_destroy(&sys->cursor_shape_manager);
+    layer_shell_destroy(&sys->layer_shell);
+    output_destroy(&sys->output);
+    if (sys->wl_seat)
+        wl_seat_destroy(sys->wl_seat);
+    if (sys->compositor)
+        wl_compositor_destroy(sys->compositor);
+    if (wnd->display.wl) {
+        wl_display_disconnect(wnd->display.wl);
+        wnd->display.wl = NULL;
+    }
+
+    wnd->type = VOUT_WINDOW_TYPE_INVALID;
+    wnd->sys = NULL;
+    vlc_cond_destroy(&sys->cond);
+    vlc_mutex_destroy(&sys->lock);
+    free(sys);
+}
+
+/**
+ * Creates a Wayland shell surface.
+ */
+static int Open(vout_window_t *wnd, const vout_window_cfg_t *cfg)
+{
+    if (cfg->type != VOUT_WINDOW_TYPE_INVALID
+     && cfg->type != VOUT_WINDOW_TYPE_WAYLAND)
+        return VLC_EGENERIC;
+
+    if (!var_InheritBool(wnd, WL_XDG_SHELL_NAME))
+        return VLC_EGENERIC;
+
+    struct wl_display *const display = get_wl_display(wnd);
+    if (display == NULL)
+        return VLC_EGENERIC;
+
+    vout_window_sys_t *const sys = calloc(1, sizeof (*sys));
+    if (unlikely(sys == NULL))
+    {
+        wl_display_disconnect(display);
+        return VLC_ENOMEM;
+    }
+
+    wnd->sys = sys;
+    vlc_mutex_init(&sys->lock);
+    vlc_cond_init(&sys->cond);
+    wnd->handle.wl = NULL;  // Ensure NULL for error Close
+    wnd->display.wl = display;
+
+    /* Connect to the display server */
+
+    msg_Info(wnd, "<<< WL XDG: %dx%d fs %d standalone %d", cfg->width, cfg->height, cfg->is_fullscreen, cfg->is_standalone);
+
+    /* Find the interesting singleton(s) */
+    struct wl_registry *registry = wl_display_get_registry(display);
+    if (registry == NULL)
+        goto error;
+
+    wl_registry_add_listener(registry, &registry_cbs, wnd);
+    wl_display_roundtrip(display);
+    wl_registry_destroy(registry);
+
+    if (sys->compositor == NULL || sys->shell == NULL)
+    {
+        msg_Info(wnd, ">>> WL XDG No compositor or shell");
+        goto error;
+    }
+
+    /* Create a surface */
+    struct wl_surface *surface = wl_compositor_create_surface(sys->compositor);
+    if (surface == NULL)
+        goto error;
+    wnd->handle.wl = surface;  // Ensure NULL for error Close
+
+    sys->req_width = cfg->width;
+    sys->req_height = cfg->height;
+
+    if (wants_layer_shell(wnd, sys))
+    {
+        int posX = var_InheritInteger(wnd, "video-x");
+        int posY = var_InheritInteger(wnd, "video-y");
+
+        msg_Info(wnd, "Create layer shell @ %d,%d", posX, posY);
+
+        sys->use_layer = true;
+
+        sys->layer_surface = zwlr_layer_shell_v1_get_layer_surface(sys->layer_shell, surface, NULL, ZWLR_LAYER_SHELL_V1_LAYER_TOP, "vlc-video");
+        zwlr_layer_surface_v1_add_listener(sys->layer_surface, &layer_surface_cbs, wnd);
+        zwlr_layer_surface_v1_set_anchor(sys->layer_surface, ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP | ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT);
+        zwlr_layer_surface_v1_set_margin(sys->layer_surface, posY, 0, 0, posX);
+    }
+    else
+    {
+        struct xdg_surface *xdg_surface =
+            xdg_wm_base_get_xdg_surface(sys->shell, surface);
+        if (xdg_surface == NULL)
+            goto error;
+
+        sys->xdg_surface = xdg_surface;
+        xdg_surface_add_listener(xdg_surface, &xdg_surface_cbs, wnd);
+
+        sys->toplevel = xdg_surface_get_toplevel(sys->xdg_surface);
+        xdg_toplevel_add_listener(sys->toplevel, &xdg_toplevel_listener, wnd);
+
+        char *title = var_InheritString(wnd, "video-title");
+        xdg_toplevel_set_title(sys->toplevel,
+                              (title != NULL) ? title : _("VLC media player"));
+        free(title);
+
+        char *app_id = var_InheritString(wnd, "app-id");
+        if (app_id != NULL)
+        {
+            xdg_toplevel_set_app_id(sys->toplevel, app_id);
+            free(app_id);
+        }
+
+        if (!sys->decoration_manager)
+        {
+            msg_Dbg(wnd, "No decoration manager");
+        }
+        else
+        {
+            const bool want_deco = var_InheritBool(wnd, "video-deco");
+            struct zxdg_toplevel_decoration_v1 *decoration =
+                zxdg_decoration_manager_v1_get_toplevel_decoration(sys->decoration_manager, sys->toplevel);
+            zxdg_toplevel_decoration_v1_add_listener(decoration, &decoration_listener, wnd);
+            zxdg_toplevel_decoration_v1_set_mode(decoration,
+                                                 want_deco ?
+                                                         ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE :
+                                                         ZXDG_TOPLEVEL_DECORATION_V1_MODE_CLIENT_SIDE);
+            // decoration destroyed in the callback
+        }
+
+        set_fullscreen(sys, cfg->is_fullscreen);
+    }
+
+    wl_surface_commit(surface);
+
+    //if (var_InheritBool (wnd, "keyboard-events"))
+    //    do_something();
+
+    wl_display_roundtrip(display);
+    wl_display_roundtrip(display);
+
+    wnd->type = VOUT_WINDOW_TYPE_WAYLAND;
+    wnd->control = Control;
+    wnd->info.has_double_click = false;
+
+    if (vlc_clone(&sys->thread, Thread, wnd, VLC_THREAD_PRIORITY_LOW))
+        goto error;
+    sys->thread_ok = true;
+
+    vlc_mutex_lock(&sys->lock);
+    mutex_cleanup_push(&sys->lock); // release the mutex in case of cancellation
+
+    vlc_tick_t timeout = mdate() + 1000000;
+    while (!sys->config1_done)
+        if (vlc_cond_timedwait(&sys->cond, &sys->lock, timeout))
+        {
+            msg_Err(wnd, "Window configure timed out");
+            break;
+        }
+
+    vlc_cleanup_pop();
+    vlc_mutex_unlock(&sys->lock);
+
+    msg_Dbg(wnd, ">>> WL XDG: OK");
+    return VLC_SUCCESS;
+
+error:
+    Close(wnd);
+
+    msg_Dbg(wnd, ">>> WL XDG: Error");
+    return VLC_EGENERIC;
+}
+
+vlc_module_begin()
+    set_shortname(N_("WL XDG shell"))
+    set_description(N_("Wayland XDG shell surface"))
+    set_category(CAT_VIDEO)
+    set_subcategory(SUBCAT_VIDEO_VOUT)
+    set_capability("vout window", 21)
+    set_callbacks(Open, Close)
+
+    add_string(DISPLAY_NAME, NULL, DISPLAY_TEXT, DISPLAY_LONGTEXT, true)
+    add_bool(LAYER_NAME, false, LAYER_TEXT, LAYER_LONGTEXT, false)
+    add_bool(WL_XDG_SHELL_NAME, true, WL_XDG_SHELL_TEXT, WL_XDG_SHELL_LONGTEXT, false)
+
+vlc_module_end()
--- /dev/null
+++ b/modules/video_output/wayland/wlr-layer-shell-unstable-v1.xml
@@ -0,0 +1,407 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="wlr_layer_shell_unstable_v1">
+  <copyright>
+    Copyright © 2017 Drew DeVault
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <interface name="zwlr_layer_shell_v1" version="5">
+    <description summary="create surfaces that are layers of the desktop">
+      Clients can use this interface to assign the surface_layer role to
+      wl_surfaces. Such surfaces are assigned to a "layer" of the output and
+      rendered with a defined z-depth respective to each other. They may also be
+      anchored to the edges and corners of a screen and specify input handling
+      semantics. This interface should be suitable for the implementation of
+      many desktop shell components, and a broad number of other applications
+      that interact with the desktop.
+    </description>
+
+    <request name="get_layer_surface">
+      <description summary="create a layer_surface from a surface">
+        Create a layer surface for an existing surface. This assigns the role of
+        layer_surface, or raises a protocol error if another role is already
+        assigned.
+
+        Creating a layer surface from a wl_surface which has a buffer attached
+        or committed is a client error, and any attempts by a client to attach
+        or manipulate a buffer prior to the first layer_surface.configure call
+        must also be treated as errors.
+
+        After creating a layer_surface object and setting it up, the client
+        must perform an initial commit without any buffer attached.
+        The compositor will reply with a layer_surface.configure event.
+        The client must acknowledge it and is then allowed to attach a buffer
+        to map the surface.
+
+        You may pass NULL for output to allow the compositor to decide which
+        output to use. Generally this will be the one that the user most
+        recently interacted with.
+
+        Clients can specify a namespace that defines the purpose of the layer
+        surface.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_layer_surface_v1"/>
+      <arg name="surface" type="object" interface="wl_surface"/>
+      <arg name="output" type="object" interface="wl_output" allow-null="true"/>
+      <arg name="layer" type="uint" enum="layer" summary="layer to add this surface to"/>
+      <arg name="namespace" type="string" summary="namespace for the layer surface"/>
+    </request>
+
+    <enum name="error">
+      <entry name="role" value="0" summary="wl_surface has another role"/>
+      <entry name="invalid_layer" value="1" summary="layer value is invalid"/>
+      <entry name="already_constructed" value="2" summary="wl_surface has a buffer attached or committed"/>
+    </enum>
+
+    <enum name="layer">
+      <description summary="available layers for surfaces">
+        These values indicate which layers a surface can be rendered in. They
+        are ordered by z depth, bottom-most first. Traditional shell surfaces
+        will typically be rendered between the bottom and top layers.
+        Fullscreen shell surfaces are typically rendered at the top layer.
+        Multiple surfaces can share a single layer, and ordering within a
+        single layer is undefined.
+      </description>
+
+      <entry name="background" value="0"/>
+      <entry name="bottom" value="1"/>
+      <entry name="top" value="2"/>
+      <entry name="overlay" value="3"/>
+    </enum>
+
+    <!-- Version 3 additions -->
+
+    <request name="destroy" type="destructor" since="3">
+      <description summary="destroy the layer_shell object">
+        This request indicates that the client will not use the layer_shell
+        object any more. Objects that have been created through this instance
+        are not affected.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="zwlr_layer_surface_v1" version="5">
+    <description summary="layer metadata interface">
+      An interface that may be implemented by a wl_surface, for surfaces that
+      are designed to be rendered as a layer of a stacked desktop-like
+      environment.
+
+      Layer surface state (layer, size, anchor, exclusive zone,
+      margin, interactivity) is double-buffered, and will be applied at the
+      time wl_surface.commit of the corresponding wl_surface is called.
+
+      Attaching a null buffer to a layer surface unmaps it.
+
+      Unmapping a layer_surface means that the surface cannot be shown by the
+      compositor until it is explicitly mapped again. The layer_surface
+      returns to the state it had right after layer_shell.get_layer_surface.
+      The client can re-map the surface by performing a commit without any
+      buffer attached, waiting for a configure event and handling it as usual.
+    </description>
+
+    <request name="set_size">
+      <description summary="sets the size of the surface">
+        Sets the size of the surface in surface-local coordinates. The
+        compositor will display the surface centered with respect to its
+        anchors.
+
+        If you pass 0 for either value, the compositor will assign it and
+        inform you of the assignment in the configure event. You must set your
+        anchor to opposite edges in the dimensions you omit; not doing so is a
+        protocol error. Both values are 0 by default.
+
+        Size is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="width" type="uint"/>
+      <arg name="height" type="uint"/>
+    </request>
+
+    <request name="set_anchor">
+      <description summary="configures the anchor point of the surface">
+        Requests that the compositor anchor the surface to the specified edges
+        and corners. If two orthogonal edges are specified (e.g. 'top' and
+        'left'), then the anchor point will be the intersection of the edges
+        (e.g. the top left corner of the output); otherwise the anchor point
+        will be centered on that edge, or in the center if none is specified.
+
+        Anchor is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="anchor" type="uint" enum="anchor"/>
+    </request>
+
+    <request name="set_exclusive_zone">
+      <description summary="configures the exclusive geometry of this surface">
+        Requests that the compositor avoids occluding an area with other
+        surfaces. The compositor's use of this information is
+        implementation-dependent - do not assume that this region will not
+        actually be occluded.
+
+        A positive value is only meaningful if the surface is anchored to one
+        edge or an edge and both perpendicular edges. If the surface is not
+        anchored, anchored to only two perpendicular edges (a corner), anchored
+        to only two parallel edges or anchored to all edges, a positive value
+        will be treated the same as zero.
+
+        A positive zone is the distance from the edge in surface-local
+        coordinates to consider exclusive.
+
+        Surfaces that do not wish to have an exclusive zone may instead specify
+        how they should interact with surfaces that do. If set to zero, the
+        surface indicates that it would like to be moved to avoid occluding
+        surfaces with a positive exclusive zone. If set to -1, the surface
+        indicates that it would not like to be moved to accommodate for other
+        surfaces, and the compositor should extend it all the way to the edges
+        it is anchored to.
+
+        For example, a panel might set its exclusive zone to 10, so that
+        maximized shell surfaces are not shown on top of it. A notification
+        might set its exclusive zone to 0, so that it is moved to avoid
+        occluding the panel, but shell surfaces are shown underneath it. A
+        wallpaper or lock screen might set their exclusive zone to -1, so that
+        they stretch below or over the panel.
+
+        The default value is 0.
+
+        Exclusive zone is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="zone" type="int"/>
+    </request>
+
+    <request name="set_margin">
+      <description summary="sets a margin from the anchor point">
+        Requests that the surface be placed some distance away from the anchor
+        point on the output, in surface-local coordinates. Setting this value
+        for edges you are not anchored to has no effect.
+
+        The exclusive zone includes the margin.
+
+        Margin is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="top" type="int"/>
+      <arg name="right" type="int"/>
+      <arg name="bottom" type="int"/>
+      <arg name="left" type="int"/>
+    </request>
+
+    <enum name="keyboard_interactivity">
+      <description summary="types of keyboard interaction possible for a layer shell surface">
+        Types of keyboard interaction possible for layer shell surfaces. The
+        rationale for this is twofold: (1) some applications are not interested
+        in keyboard events and not allowing them to be focused can improve the
+        desktop experience; (2) some applications will want to take exclusive
+        keyboard focus.
+      </description>
+
+      <entry name="none" value="0">
+        <description summary="no keyboard focus is possible">
+          This value indicates that this surface is not interested in keyboard
+          events and the compositor should never assign it the keyboard focus.
+
+          This is the default value, set for newly created layer shell surfaces.
+
+          This is useful for e.g. desktop widgets that display information or
+          only have interaction with non-keyboard input devices.
+        </description>
+      </entry>
+      <entry name="exclusive" value="1">
+        <description summary="request exclusive keyboard focus">
+          Request exclusive keyboard focus if this surface is above the shell surface layer.
+
+          For the top and overlay layers, the seat will always give
+          exclusive keyboard focus to the top-most layer which has keyboard
+          interactivity set to exclusive. If this layer contains multiple
+          surfaces with keyboard interactivity set to exclusive, the compositor
+          determines the one receiving keyboard events in an implementation-
+          defined manner. In this case, no guarantee is made when this surface
+          will receive keyboard focus (if ever).
+
+          For the bottom and background layers, the compositor is allowed to use
+          normal focus semantics.
+
+          This setting is mainly intended for applications that need to ensure
+          they receive all keyboard events, such as a lock screen or a password
+          prompt.
+        </description>
+      </entry>
+      <entry name="on_demand" value="2" since="4">
+        <description summary="request regular keyboard focus semantics">
+          This requests the compositor to allow this surface to be focused and
+          unfocused by the user in an implementation-defined manner. The user
+          should be able to unfocus this surface even regardless of the layer
+          it is on.
+
+          Typically, the compositor will want to use its normal mechanism to
+          manage keyboard focus between layer shell surfaces with this setting
+          and regular toplevels on the desktop layer (e.g. click to focus).
+          Nevertheless, it is possible for a compositor to require a special
+          interaction to focus or unfocus layer shell surfaces (e.g. requiring
+          a click even if focus follows the mouse normally, or providing a
+          keybinding to switch focus between layers).
+
+          This setting is mainly intended for desktop shell components (e.g.
+          panels) that allow keyboard interaction. Using this option can allow
+          implementing a desktop shell that can be fully usable without the
+          mouse.
+        </description>
+      </entry>
+    </enum>
+
+    <request name="set_keyboard_interactivity">
+      <description summary="requests keyboard events">
+        Set how keyboard events are delivered to this surface. By default,
+        layer shell surfaces do not receive keyboard events; this request can
+        be used to change this.
+
+        This setting is inherited by child surfaces set by the get_popup
+        request.
+
+        Layer surfaces receive pointer, touch, and tablet events normally. If
+        you do not want to receive them, set the input region on your surface
+        to an empty region.
+
+        Keyboard interactivity is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="keyboard_interactivity" type="uint" enum="keyboard_interactivity"/>
+    </request>
+
+    <request name="get_popup">
+      <description summary="assign this layer_surface as an xdg_popup parent">
+        This assigns an xdg_popup's parent to this layer_surface.  This popup
+        should have been created via xdg_surface::get_popup with the parent set
+        to NULL, and this request must be invoked before committing the popup's
+        initial state.
+
+        See the documentation of xdg_popup for more details about what an
+        xdg_popup is and how it is used.
+      </description>
+      <arg name="popup" type="object" interface="xdg_popup"/>
+    </request>
+
+    <request name="ack_configure">
+      <description summary="ack a configure event">
+        When a configure event is received, if a client commits the
+        surface in response to the configure event, then the client
+        must make an ack_configure request sometime before the commit
+        request, passing along the serial of the configure event.
+
+        If the client receives multiple configure events before it
+        can respond to one, it only has to ack the last configure event.
+
+        A client is not required to commit immediately after sending
+        an ack_configure request - it may even ack_configure several times
+        before its next surface commit.
+
+        A client may send multiple ack_configure requests before committing, but
+        only the last request sent before a commit indicates which configure
+        event the client really is responding to.
+      </description>
+      <arg name="serial" type="uint" summary="the serial from the configure event"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the layer_surface">
+        This request destroys the layer surface.
+      </description>
+    </request>
+
+    <event name="configure">
+      <description summary="suggest a surface change">
+        The configure event asks the client to resize its surface.
+
+        Clients should arrange their surface for the new states, and then send
+        an ack_configure request with the serial sent in this configure event at
+        some point before committing the new surface.
+
+        The client is free to dismiss all but the last configure event it
+        received.
+
+        The width and height arguments specify the size of the window in
+        surface-local coordinates.
+
+        The size is a hint, in the sense that the client is free to ignore it if
+        it doesn't resize, pick a smaller size (to satisfy aspect ratio or
+        resize in steps of NxM pixels). If the client picks a smaller size and
+        is anchored to two opposite anchors (e.g. 'top' and 'bottom'), the
+        surface will be centered on this axis.
+
+        If the width or height arguments are zero, it means the client should
+        decide its own window dimension.
+      </description>
+      <arg name="serial" type="uint"/>
+      <arg name="width" type="uint"/>
+      <arg name="height" type="uint"/>
+    </event>
+
+    <event name="closed">
+      <description summary="surface should be closed">
+        The closed event is sent by the compositor when the surface will no
+        longer be shown. The output may have been destroyed or the user may
+        have asked for it to be removed. Further changes to the surface will be
+        ignored. The client should destroy the resource after receiving this
+        event, and create a new surface if they so choose.
+      </description>
+    </event>
+
+    <enum name="error">
+      <entry name="invalid_surface_state" value="0" summary="provided surface state is invalid"/>
+      <entry name="invalid_size" value="1" summary="size is invalid"/>
+      <entry name="invalid_anchor" value="2" summary="anchor bitfield is invalid"/>
+      <entry name="invalid_keyboard_interactivity" value="3" summary="keyboard interactivity is invalid"/>
+      <entry name="invalid_exclusive_edge" value="4" summary="exclusive edge is invalid given the surface anchors"/>
+    </enum>
+
+    <enum name="anchor" bitfield="true">
+      <entry name="top" value="1" summary="the top edge of the anchor rectangle"/>
+      <entry name="bottom" value="2" summary="the bottom edge of the anchor rectangle"/>
+      <entry name="left" value="4" summary="the left edge of the anchor rectangle"/>
+      <entry name="right" value="8" summary="the right edge of the anchor rectangle"/>
+    </enum>
+
+    <!-- Version 2 additions -->
+
+    <request name="set_layer" since="2">
+      <description summary="change the layer of the surface">
+        Change the layer that the surface is rendered on.
+
+        Layer is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="layer" type="uint" enum="zwlr_layer_shell_v1.layer" summary="layer to move this surface to"/>
+    </request>
+
+    <!-- Version 5 additions -->
+
+    <request name="set_exclusive_edge" since="5">
+      <description summary="set the edge the exclusive zone will be applied to">
+        Requests an edge for the exclusive zone to apply. The exclusive
+        edge will be automatically deduced from anchor points when possible,
+        but when the surface is anchored to a corner, it will be necessary
+        to set it explicitly to disambiguate, as it is not possible to deduce
+        which one of the two corner edges should be used.
+
+        The edge must be one the surface is anchored to, otherwise the
+        invalid_exclusive_edge protocol error will be raised.
+      </description>
+      <arg name="edge" type="uint" enum="anchor"/>
+    </request>
+  </interface>
+</protocol>
